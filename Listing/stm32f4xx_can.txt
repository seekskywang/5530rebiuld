; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_can.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_can.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_can.crf ..\Libraries\FWlib\src\stm32f4xx_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;701      */
;;;702    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b141              CBZ      r1,|L1.20|
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;706      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;707      /* abort transmission */
;;;708      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d00b              BEQ      |L1.30|
000006  2902              CMP      r1,#2
000008  d103              BNE      |L1.18|
;;;709      {
;;;710        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;711          break;
;;;712        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
;;;713          break;
;;;714        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
00000a  6881              LDR      r1,[r0,#8]
00000c  f4410100          ORR      r1,r1,#0x800000
000010  6081              STR      r1,[r0,#8]
                  |L1.18|
;;;715          break;
;;;716        default:
;;;717          break;
;;;718      }
;;;719    }
000012  4770              BX       lr
                  |L1.20|
000014  6881              LDR      r1,[r0,#8]            ;710
000016  f0410180          ORR      r1,r1,#0x80           ;710
00001a  6081              STR      r1,[r0,#8]            ;710
00001c  4770              BX       lr
                  |L1.30|
00001e  6881              LDR      r1,[r0,#8]            ;712
000020  f4414100          ORR      r1,r1,#0x8000         ;712
000024  6081              STR      r1,[r0,#8]            ;712
000026  4770              BX       lr
;;;720    /**
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1428     */
;;;1429   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4a0a              LDR      r2,|L2.44|
;;;1430   {
;;;1431     uint32_t flagtmp=0;
;;;1432     /* Check the parameters */
;;;1433     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1434     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1435     
;;;1436     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4291              CMP      r1,r2
000004  d102              BNE      |L2.12|
;;;1437     {
;;;1438       /* Clear the selected CAN flags */
;;;1439       CANx->ESR = (uint32_t)RESET;
000006  2100              MOVS     r1,#0
000008  6181              STR      r1,[r0,#0x18]
;;;1440     }
;;;1441     else /* MSR or TSR or RF0R or RF1R */
;;;1442     {
;;;1443       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1444   
;;;1445       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1446       {
;;;1447         /* Receive Flags */
;;;1448         CANx->RF0R = (uint32_t)(flagtmp);
;;;1449       }
;;;1450       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1451       {
;;;1452         /* Receive Flags */
;;;1453         CANx->RF1R = (uint32_t)(flagtmp);
;;;1454       }
;;;1455       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1456       {
;;;1457         /* Transmit Flags */
;;;1458         CANx->TSR = (uint32_t)(flagtmp);
;;;1459       }
;;;1460       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1461       {
;;;1462         /* Operating mode Flags */
;;;1463         CANx->MSR = (uint32_t)(flagtmp);
;;;1464       }
;;;1465     }
;;;1466   }
00000a  4770              BX       lr
                  |L2.12|
00000c  f3c10213          UBFX     r2,r1,#0,#20          ;1443
000010  018b              LSLS     r3,r1,#6              ;1445
000012  d501              BPL      |L2.24|
000014  60c2              STR      r2,[r0,#0xc]          ;1448
000016  4770              BX       lr
                  |L2.24|
000018  014b              LSLS     r3,r1,#5              ;1450
00001a  d501              BPL      |L2.32|
00001c  6102              STR      r2,[r0,#0x10]         ;1453
00001e  4770              BX       lr
                  |L2.32|
000020  0109              LSLS     r1,r1,#4              ;1455
000022  d501              BPL      |L2.40|
000024  6082              STR      r2,[r0,#8]            ;1458
000026  4770              BX       lr
                  |L2.40|
000028  6042              STR      r2,[r0,#4]            ;1463
00002a  4770              BX       lr
;;;1467   
                          ENDP

                  |L2.44|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1592     */
;;;1593   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1594   {
;;;1595     /* Check the parameters */
;;;1596     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1597     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1598   
;;;1599     switch (CAN_IT)
;;;1600     {
;;;1601       case CAN_IT_TME:
;;;1602         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1603         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1604         break;
;;;1605       case CAN_IT_FF0:
;;;1606         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1607         CANx->RF0R = CAN_RF0R_FULL0; 
000002  2308              MOVS     r3,#8
;;;1608         break;
;;;1609       case CAN_IT_FOV0:
;;;1610         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1611         CANx->RF0R = CAN_RF0R_FOVR0; 
000004  2410              MOVS     r4,#0x10
;;;1612         break;
;;;1613       case CAN_IT_FF1:
;;;1614         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1615         CANx->RF1R = CAN_RF1R_FULL1;  
;;;1616         break;
;;;1617       case CAN_IT_FOV1:
;;;1618         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1619         CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1620         break;
;;;1621       case CAN_IT_WKU:
;;;1622         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1623         CANx->MSR = CAN_MSR_WKUI;  
;;;1624         break;
;;;1625       case CAN_IT_SLK:
;;;1626         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1627         CANx->MSR = CAN_MSR_SLAKI;   
;;;1628         break;
;;;1629       case CAN_IT_EWG:
;;;1630         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1631         CANx->MSR = CAN_MSR_ERRI;
000006  2204              MOVS     r2,#4
000008  f5b17f00          CMP      r1,#0x200             ;1599
00000c  d033              BEQ      |L3.118|
00000e  dc11              BGT      |L3.52|
000010  2920              CMP      r1,#0x20              ;1599
000012  d02a              BEQ      |L3.106|
000014  dc07              BGT      |L3.38|
000016  2901              CMP      r1,#1                 ;1599
000018  d022              BEQ      |L3.96|
00001a  2904              CMP      r1,#4                 ;1599
00001c  d023              BEQ      |L3.102|
00001e  2908              CMP      r1,#8                 ;1599
000020  d100              BNE      |L3.36|
000022  60c4              STR      r4,[r0,#0xc]          ;1611
                  |L3.36|
;;;1632          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1633         break;
;;;1634       case CAN_IT_EPV:
;;;1635         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1636         CANx->MSR = CAN_MSR_ERRI; 
;;;1637          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1638         break;
;;;1639       case CAN_IT_BOF:
;;;1640         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1641         CANx->MSR = CAN_MSR_ERRI; 
;;;1642          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1643          break;
;;;1644       case CAN_IT_LEC:
;;;1645         /*  Clear LEC bits */
;;;1646         CANx->ESR = RESET; 
;;;1647         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1648         CANx->MSR = CAN_MSR_ERRI; 
;;;1649         break;
;;;1650       case CAN_IT_ERR:
;;;1651         /*Clear LEC bits */
;;;1652         CANx->ESR = RESET; 
;;;1653         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1654         CANx->MSR = CAN_MSR_ERRI; 
;;;1655          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1656          break;
;;;1657       default:
;;;1658          break;
;;;1659      }
;;;1660   }
000024  bd30              POP      {r4,r5,pc}
                  |L3.38|
000026  2940              CMP      r1,#0x40              ;1599
000028  d021              BEQ      |L3.110|
00002a  f5b17f80          CMP      r1,#0x100             ;1599
00002e  d1f9              BNE      |L3.36|
000030  6042              STR      r2,[r0,#4]            ;1631
                  |L3.50|
000032  bd30              POP      {r4,r5,pc}
                  |L3.52|
000034  2500              MOVS     r5,#0                 ;1646
000036  f5b14f00          CMP      r1,#0x8000            ;1599
00003a  d020              BEQ      |L3.126|
00003c  dc08              BGT      |L3.80|
00003e  f5b16f80          CMP      r1,#0x400             ;1599
000042  d01a              BEQ      |L3.122|
000044  f5b16f00          CMP      r1,#0x800             ;1599
000048  d1f3              BNE      |L3.50|
00004a  6185              STR      r5,[r0,#0x18]         ;1646
00004c  6042              STR      r2,[r0,#4]            ;1648
                  |L3.78|
00004e  bd30              POP      {r4,r5,pc}
                  |L3.80|
000050  f5b13f80          CMP      r1,#0x10000           ;1599
000054  d00d              BEQ      |L3.114|
000056  f5b13f00          CMP      r1,#0x20000           ;1599
00005a  d1f8              BNE      |L3.78|
00005c  6044              STR      r4,[r0,#4]            ;1627
00005e  bd30              POP      {r4,r5,pc}
                  |L3.96|
000060  4908              LDR      r1,|L3.132|
000062  6081              STR      r1,[r0,#8]            ;1603
000064  bd30              POP      {r4,r5,pc}
                  |L3.102|
000066  60c3              STR      r3,[r0,#0xc]          ;1607
000068  bd30              POP      {r4,r5,pc}
                  |L3.106|
00006a  6103              STR      r3,[r0,#0x10]         ;1615
00006c  bd30              POP      {r4,r5,pc}
                  |L3.110|
00006e  6104              STR      r4,[r0,#0x10]         ;1619
000070  bd30              POP      {r4,r5,pc}
                  |L3.114|
000072  6043              STR      r3,[r0,#4]            ;1623
000074  bd30              POP      {r4,r5,pc}
                  |L3.118|
000076  6042              STR      r2,[r0,#4]            ;1636
000078  bd30              POP      {r4,r5,pc}
                  |L3.122|
00007a  6042              STR      r2,[r0,#4]            ;1641
00007c  bd30              POP      {r4,r5,pc}
                  |L3.126|
00007e  6185              STR      r5,[r0,#0x18]         ;1652
000080  6042              STR      r2,[r0,#4]            ;1654
000082  bd30              POP      {r4,r5,pc}
;;;1661    /**
                          ENDP

                  |L3.132|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;491      */
;;;492    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;497      
;;;498      if (NewState != DISABLE)
;;;499      {
;;;500        /* Enable Debug Freeze  */
;;;501        CANx->MCR |= MCR_DBF;
000002  6801              LDR      r1,[r0,#0]
000004  f4413180          ORR      r1,r1,#0x10000
000008  6001              STR      r1,[r0,#0]
;;;502      }
;;;503      else
;;;504      {
;;;505        /* Disable Debug Freeze */
;;;506        CANx->MCR &= ~MCR_DBF;
;;;507      }
;;;508    }
00000a  4770              BX       lr
                  |L4.12|
00000c  6801              LDR      r1,[r0,#0]            ;506
00000e  f4213180          BIC      r1,r1,#0x10000        ;506
000012  6001              STR      r1,[r0,#0]            ;506
000014  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;165      */
;;;166    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;167    {
;;;168      /* Check the parameters */
;;;169      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;170     
;;;171      if (CANx == CAN1)
000002  490c              LDR      r1,|L5.52|
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L5.30|
;;;172      {
;;;173        /* Enable CAN1 reset state */
;;;174        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  064c              LSLS     r4,r1,#25
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;175        /* Release CAN1 from reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L5.30|
;;;177      }
;;;178      else
;;;179      {  
;;;180        /* Enable CAN2 reset state */
;;;181        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  068c              LSLS     r4,r1,#26
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;182        /* Release CAN2 from reset state */
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000028  4620              MOV      r0,r4
00002a  e8bd4010          POP      {r4,lr}
00002e  2100              MOVS     r1,#0
000030  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;184      }
;;;185    }
;;;186    
                          ENDP

                  |L5.52|
                          DCD      0x40006400

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;797      */
;;;798    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b121              CBZ      r1,|L6.12|
;;;799    {
;;;800      /* Check the parameters */
;;;801      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;802      assert_param(IS_CAN_FIFO(FIFONumber));
;;;803      /* Release FIFO0 */
;;;804      if (FIFONumber == CAN_FIFO0)
;;;805      {
;;;806        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;807      }
;;;808      /* Release FIFO1 */
;;;809      else /* FIFONumber == CAN_FIFO1 */
;;;810      {
;;;811        CANx->RF1R |= CAN_RF1R_RFOM1;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410120          ORR      r1,r1,#0x20
000008  6101              STR      r1,[r0,#0x10]
;;;812      }
;;;813    }
00000a  4770              BX       lr
                  |L6.12|
00000c  68c1              LDR      r1,[r0,#0xc]          ;806
00000e  f0410120          ORR      r1,r1,#0x20           ;806
000012  60c1              STR      r1,[r0,#0xc]          ;806
000014  4770              BX       lr
;;;814    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;332      */
;;;333    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;334    {
;;;335      uint32_t filter_number_bit_pos = 0;
;;;336      /* Check the parameters */
;;;337      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;338      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;339      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;340      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;341      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;342    
;;;343      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000002  7a82              LDRB     r2,[r0,#0xa]
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;344    
;;;345      /* Initialisation mode for the filter */
;;;346      CAN1->FMR |= FMR_FINIT;
000008  4b2e              LDR      r3,|L7.196|
00000a  681a              LDR      r2,[r3,#0]
00000c  f0420201          ORR      r2,r2,#1
000010  601a              STR      r2,[r3,#0]
;;;347    
;;;348      /* Filter Deactivation */
;;;349      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000012  4c2c              LDR      r4,|L7.196|
000014  341c              ADDS     r4,r4,#0x1c
000016  6822              LDR      r2,[r4,#0]
000018  438a              BICS     r2,r2,r1
00001a  6022              STR      r2,[r4,#0]
;;;350    
;;;351      /* Filter Scale */
;;;352      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
;;;353      {
;;;354        /* 16-bit scale for the filter */
;;;355        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00001c  4a29              LDR      r2,|L7.196|
;;;356    
;;;357        /* First 16-bit identifier and First 16-bit mask */
;;;358        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;359        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00001e  4e29              LDR      r6,|L7.196|
000020  7b05              LDRB     r5,[r0,#0xc]          ;352
000022  320c              ADDS     r2,r2,#0xc            ;355
000024  3640              ADDS     r6,r6,#0x40
;;;360           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;361            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;362    
;;;363        /* Second 16-bit identifier and Second 16-bit mask */
;;;364        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;365        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000026  1d37              ADDS     r7,r6,#4
000028  b9a5              CBNZ     r5,|L7.84|
00002a  6815              LDR      r5,[r2,#0]            ;355
00002c  438d              BICS     r5,r5,r1              ;355
00002e  6015              STR      r5,[r2,#0]            ;355
000030  8845              LDRH     r5,[r0,#2]            ;359
000032  f8b0c006          LDRH     r12,[r0,#6]           ;359
000036  ea45450c          ORR      r5,r5,r12,LSL #16     ;359
00003a  f890c00a          LDRB     r12,[r0,#0xa]         ;359
00003e  f846503c          STR      r5,[r6,r12,LSL #3]    ;359
000042  8805              LDRH     r5,[r0,#0]
000044  f8b0c004          LDRH     r12,[r0,#4]
000048  ea45450c          ORR      r5,r5,r12,LSL #16
00004c  f890c00a          LDRB     r12,[r0,#0xa]
000050  f847503c          STR      r5,[r7,r12,LSL #3]
                  |L7.84|
;;;366           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;367            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;368      }
;;;369    
;;;370      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
000054  7b05              LDRB     r5,[r0,#0xc]
000056  2d01              CMP      r5,#1
000058  d110              BNE      |L7.124|
;;;371      {
;;;372        /* 32-bit scale for the filter */
;;;373        CAN1->FS1R |= filter_number_bit_pos;
00005a  6815              LDR      r5,[r2,#0]
00005c  430d              ORRS     r5,r5,r1
00005e  6015              STR      r5,[r2,#0]
;;;374        /* 32-bit identifier or First 32-bit identifier */
;;;375        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000060  8842              LDRH     r2,[r0,#2]
000062  8805              LDRH     r5,[r0,#0]
000064  ea424205          ORR      r2,r2,r5,LSL #16
000068  7a85              LDRB     r5,[r0,#0xa]
00006a  f8462035          STR      r2,[r6,r5,LSL #3]
;;;376           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;377            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;378        /* 32-bit mask or Second 32-bit identifier */
;;;379        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00006e  88c2              LDRH     r2,[r0,#6]
000070  8885              LDRH     r5,[r0,#4]
000072  ea424205          ORR      r2,r2,r5,LSL #16
000076  7a85              LDRB     r5,[r0,#0xa]
000078  f8472035          STR      r2,[r7,r5,LSL #3]
                  |L7.124|
;;;380           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;381            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;382      }
;;;383    
;;;384      /* Filter Mode */
;;;385      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
;;;386      {
;;;387        /*Id/Mask mode for the filter*/
;;;388        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00007c  4a11              LDR      r2,|L7.196|
00007e  7ac5              LDRB     r5,[r0,#0xb]          ;385
000080  1d12              ADDS     r2,r2,#4
000082  b13d              CBZ      r5,|L7.148|
;;;389      }
;;;390      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;391      {
;;;392        /*Identifier list mode for the filter*/
;;;393        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
000084  6815              LDR      r5,[r2,#0]
000086  430d              ORRS     r5,r5,r1
000088  6015              STR      r5,[r2,#0]
                  |L7.138|
;;;394      }
;;;395    
;;;396      /* Filter FIFO assignment */
;;;397      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
;;;398      {
;;;399        /* FIFO 0 assignation for the filter */
;;;400        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
00008a  4a0e              LDR      r2,|L7.196|
00008c  8905              LDRH     r5,[r0,#8]            ;397
00008e  3214              ADDS     r2,r2,#0x14
000090  b125              CBZ      r5,|L7.156|
000092  e006              B        |L7.162|
                  |L7.148|
000094  6815              LDR      r5,[r2,#0]            ;388
000096  438d              BICS     r5,r5,r1              ;388
000098  6015              STR      r5,[r2,#0]            ;388
00009a  e7f6              B        |L7.138|
                  |L7.156|
00009c  6815              LDR      r5,[r2,#0]
00009e  438d              BICS     r5,r5,r1
0000a0  6015              STR      r5,[r2,#0]
                  |L7.162|
;;;401      }
;;;402    
;;;403      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000a2  8905              LDRH     r5,[r0,#8]
0000a4  2d01              CMP      r5,#1
0000a6  d102              BNE      |L7.174|
;;;404      {
;;;405        /* FIFO 1 assignation for the filter */
;;;406        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000a8  6815              LDR      r5,[r2,#0]
0000aa  430d              ORRS     r5,r5,r1
0000ac  6015              STR      r5,[r2,#0]
                  |L7.174|
;;;407      }
;;;408      
;;;409      /* Filter activation */
;;;410      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000ae  7b40              LDRB     r0,[r0,#0xd]
0000b0  2801              CMP      r0,#1
0000b2  d102              BNE      |L7.186|
;;;411      {
;;;412        CAN1->FA1R |= filter_number_bit_pos;
0000b4  6820              LDR      r0,[r4,#0]
0000b6  4308              ORRS     r0,r0,r1
0000b8  6020              STR      r0,[r4,#0]
                  |L7.186|
;;;413      }
;;;414    
;;;415      /* Leave the initialisation mode for the filter */
;;;416      CAN1->FMR &= ~FMR_FINIT;
0000ba  6818              LDR      r0,[r3,#0]
0000bc  f0200001          BIC      r0,r0,#1
0000c0  6018              STR      r0,[r3,#0]
;;;417    }
0000c2  bdf0              POP      {r4-r7,pc}
;;;418    
                          ENDP

                  |L7.196|
                          DCD      0x40006600

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;1328     */
;;;1329   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4602              MOV      r2,r0
;;;1330   {
;;;1331     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1332     
;;;1333     /* Check the parameters */
;;;1334     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1335     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1336     
;;;1337   
;;;1338     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000004  f4110f70          TST      r1,#0xf00000
000008  d005              BEQ      |L8.22|
;;;1339     { 
;;;1340       /* Check the status of the specified CAN flag */
;;;1341       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00000a  6992              LDR      r2,[r2,#0x18]
00000c  400a              ANDS     r2,r2,r1
00000e  0311              LSLS     r1,r2,#12
000010  d000              BEQ      |L8.20|
;;;1342       { 
;;;1343         /* CAN_FLAG is set */
;;;1344         bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L8.20|
;;;1345       }
;;;1346       else
;;;1347       { 
;;;1348         /* CAN_FLAG is reset */
;;;1349         bitstatus = RESET;
;;;1350       }
;;;1351     }
;;;1352     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
;;;1353     { 
;;;1354       /* Check the status of the specified CAN flag */
;;;1355       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1356       { 
;;;1357         /* CAN_FLAG is set */
;;;1358         bitstatus = SET;
;;;1359       }
;;;1360       else
;;;1361       { 
;;;1362         /* CAN_FLAG is reset */
;;;1363         bitstatus = RESET;
;;;1364       }
;;;1365     }
;;;1366     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
;;;1367     { 
;;;1368       /* Check the status of the specified CAN flag */
;;;1369       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1370       { 
;;;1371         /* CAN_FLAG is set */
;;;1372         bitstatus = SET;
;;;1373       }
;;;1374       else
;;;1375       { 
;;;1376         /* CAN_FLAG is reset */
;;;1377         bitstatus = RESET;
;;;1378       }
;;;1379     }
;;;1380     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
;;;1381     { 
;;;1382       /* Check the status of the specified CAN flag */
;;;1383       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1384       { 
;;;1385         /* CAN_FLAG is set */
;;;1386         bitstatus = SET;
;;;1387       }
;;;1388       else
;;;1389       { 
;;;1390         /* CAN_FLAG is reset */
;;;1391         bitstatus = RESET;
;;;1392       }
;;;1393     }
;;;1394     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1395     { 
;;;1396       /* Check the status of the specified CAN flag */
;;;1397       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1398       { 
;;;1399         /* CAN_FLAG is set */
;;;1400         bitstatus = SET;
;;;1401       }
;;;1402       else
;;;1403       { 
;;;1404         /* CAN_FLAG is reset */
;;;1405         bitstatus = RESET;
;;;1406       }
;;;1407     }
;;;1408     /* Return the CAN_FLAG status */
;;;1409     return  bitstatus;
;;;1410   }
000014  4770              BX       lr
                  |L8.22|
000016  01cb              LSLS     r3,r1,#7              ;1352
000018  d505              BPL      |L8.38|
00001a  6852              LDR      r2,[r2,#4]            ;1355
00001c  400a              ANDS     r2,r2,r1              ;1355
00001e  0311              LSLS     r1,r2,#12             ;1355
000020  d0f8              BEQ      |L8.20|
000022  2001              MOVS     r0,#1                 ;1358
                  |L8.36|
000024  4770              BX       lr
                  |L8.38|
000026  010b              LSLS     r3,r1,#4              ;1366
000028  d505              BPL      |L8.54|
00002a  6892              LDR      r2,[r2,#8]            ;1369
00002c  400a              ANDS     r2,r2,r1              ;1369
00002e  0311              LSLS     r1,r2,#12             ;1369
000030  d0f8              BEQ      |L8.36|
000032  2001              MOVS     r0,#1                 ;1372
                  |L8.52|
000034  4770              BX       lr
                  |L8.54|
000036  018b              LSLS     r3,r1,#6              ;1380
000038  d505              BPL      |L8.70|
00003a  68d2              LDR      r2,[r2,#0xc]          ;1383
00003c  400a              ANDS     r2,r2,r1              ;1383
00003e  0311              LSLS     r1,r2,#12             ;1383
000040  d0f8              BEQ      |L8.52|
000042  2001              MOVS     r0,#1                 ;1386
                  |L8.68|
000044  4770              BX       lr
                  |L8.70|
000046  6912              LDR      r2,[r2,#0x10]         ;1397
000048  400a              ANDS     r2,r2,r1              ;1397
00004a  0311              LSLS     r1,r2,#12             ;1397
00004c  d0fa              BEQ      |L8.68|
00004e  2001              MOVS     r0,#1                 ;1400
000050  4770              BX       lr
;;;1411   
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1488     */
;;;1489   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  4602              MOV      r2,r0
;;;1490   {
;;;1491     ITStatus itstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1492     /* Check the parameters */
;;;1493     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1494     assert_param(IS_CAN_IT(CAN_IT));
;;;1495     
;;;1496     /* check the interrupt enable bit */
;;;1497    if((CANx->IER & CAN_IT) != RESET)
000004  6953              LDR      r3,[r2,#0x14]
000006  420b              TST      r3,r1
000008  d05d              BEQ      |L9.198|
;;;1498    {
;;;1499      /* in case the Interrupt is enabled, .... */
;;;1500       switch (CAN_IT)
00000a  f5b17f80          CMP      r1,#0x100
00000e  d04a              BEQ      |L9.166|
000010  dc16              BGT      |L9.64|
000012  2908              CMP      r1,#8
000014  d037              BEQ      |L9.134|
000016  dc09              BGT      |L9.44|
000018  2901              CMP      r1,#1
00001a  d02c              BEQ      |L9.118|
00001c  2902              CMP      r1,#2
00001e  d02e              BEQ      |L9.126|
000020  2904              CMP      r1,#4
000022  d150              BNE      |L9.198|
;;;1501       {
;;;1502         case CAN_IT_TME:
;;;1503           /* Check CAN_TSR_RQCPx bits */
;;;1504           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
;;;1505           break;
;;;1506         case CAN_IT_FMP0:
;;;1507           /* Check CAN_RF0R_FMP0 bit */
;;;1508           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
;;;1509           break;
;;;1510         case CAN_IT_FF0:
;;;1511           /* Check CAN_RF0R_FULL0 bit */
;;;1512           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
000024  68d0              LDR      r0,[r2,#0xc]
000026  2108              MOVS     r1,#8
000028  f7ffbffe          B.W      CheckITStatus
                  |L9.44|
00002c  2910              CMP      r1,#0x10              ;1500
00002e  d02e              BEQ      |L9.142|
000030  2920              CMP      r1,#0x20              ;1500
000032  d030              BEQ      |L9.150|
000034  2940              CMP      r1,#0x40              ;1500
000036  d146              BNE      |L9.198|
;;;1513           break;
;;;1514         case CAN_IT_FOV0:
;;;1515           /* Check CAN_RF0R_FOVR0 bit */
;;;1516           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
;;;1517           break;
;;;1518         case CAN_IT_FMP1:
;;;1519           /* Check CAN_RF1R_FMP1 bit */
;;;1520           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
;;;1521           break;
;;;1522         case CAN_IT_FF1:
;;;1523           /* Check CAN_RF1R_FULL1 bit */
;;;1524           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
;;;1525           break;
;;;1526         case CAN_IT_FOV1:
;;;1527           /* Check CAN_RF1R_FOVR1 bit */
;;;1528           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
000038  6910              LDR      r0,[r2,#0x10]
00003a  2110              MOVS     r1,#0x10
00003c  f7ffbffe          B.W      CheckITStatus
                  |L9.64|
000040  f5b14f00          CMP      r1,#0x8000            ;1500
000044  d03b              BEQ      |L9.190|
000046  dc0c              BGT      |L9.98|
000048  f5b17f00          CMP      r1,#0x200             ;1500
00004c  d02f              BEQ      |L9.174|
00004e  f5b16f80          CMP      r1,#0x400             ;1500
000052  d030              BEQ      |L9.182|
000054  f5b16f00          CMP      r1,#0x800             ;1500
000058  d135              BNE      |L9.198|
;;;1529           break;
;;;1530         case CAN_IT_WKU:
;;;1531           /* Check CAN_MSR_WKUI bit */
;;;1532           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
;;;1533           break;
;;;1534         case CAN_IT_SLK:
;;;1535           /* Check CAN_MSR_SLAKI bit */
;;;1536           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
;;;1537           break;
;;;1538         case CAN_IT_EWG:
;;;1539           /* Check CAN_ESR_EWGF bit */
;;;1540           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
;;;1541           break;
;;;1542         case CAN_IT_EPV:
;;;1543           /* Check CAN_ESR_EPVF bit */
;;;1544           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
;;;1545           break;
;;;1546         case CAN_IT_BOF:
;;;1547           /* Check CAN_ESR_BOFF bit */
;;;1548           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
;;;1549           break;
;;;1550         case CAN_IT_LEC:
;;;1551           /* Check CAN_ESR_LEC bit */
;;;1552           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
00005a  6990              LDR      r0,[r2,#0x18]
00005c  2170              MOVS     r1,#0x70
00005e  f7ffbffe          B.W      CheckITStatus
                  |L9.98|
000062  f5b13f80          CMP      r1,#0x10000           ;1500
000066  d01a              BEQ      |L9.158|
000068  f5b13f00          CMP      r1,#0x20000           ;1500
00006c  d12b              BNE      |L9.198|
00006e  6850              LDR      r0,[r2,#4]            ;1536
000070  2110              MOVS     r1,#0x10              ;1536
000072  f7ffbffe          B.W      CheckITStatus
                  |L9.118|
000076  6890              LDR      r0,[r2,#8]            ;1504
000078  4913              LDR      r1,|L9.200|
00007a  f7ffbffe          B.W      CheckITStatus
                  |L9.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;1508
000080  2103              MOVS     r1,#3                 ;1508
000082  f7ffbffe          B.W      CheckITStatus
                  |L9.134|
000086  68d0              LDR      r0,[r2,#0xc]          ;1516
000088  2110              MOVS     r1,#0x10              ;1516
00008a  f7ffbffe          B.W      CheckITStatus
                  |L9.142|
00008e  6910              LDR      r0,[r2,#0x10]         ;1520
000090  2103              MOVS     r1,#3                 ;1520
000092  f7ffbffe          B.W      CheckITStatus
                  |L9.150|
000096  6910              LDR      r0,[r2,#0x10]         ;1524
000098  2108              MOVS     r1,#8                 ;1524
00009a  f7ffbffe          B.W      CheckITStatus
                  |L9.158|
00009e  6850              LDR      r0,[r2,#4]            ;1532
0000a0  2108              MOVS     r1,#8                 ;1532
0000a2  f7ffbffe          B.W      CheckITStatus
                  |L9.166|
0000a6  6990              LDR      r0,[r2,#0x18]         ;1540
0000a8  2101              MOVS     r1,#1                 ;1540
0000aa  f7ffbffe          B.W      CheckITStatus
                  |L9.174|
0000ae  6990              LDR      r0,[r2,#0x18]         ;1544
0000b0  2102              MOVS     r1,#2                 ;1544
0000b2  f7ffbffe          B.W      CheckITStatus
                  |L9.182|
0000b6  6990              LDR      r0,[r2,#0x18]         ;1548
0000b8  2104              MOVS     r1,#4                 ;1548
0000ba  f7ffbffe          B.W      CheckITStatus
                  |L9.190|
;;;1553           break;
;;;1554         case CAN_IT_ERR:
;;;1555           /* Check CAN_MSR_ERRI bit */ 
;;;1556           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
0000be  6850              LDR      r0,[r2,#4]
0000c0  2104              MOVS     r1,#4
0000c2  f7ffbffe          B.W      CheckITStatus
                  |L9.198|
;;;1557           break;
;;;1558         default:
;;;1559           /* in case of error, return RESET */
;;;1560           itstatus = RESET;
;;;1561           break;
;;;1562       }
;;;1563     }
;;;1564     else
;;;1565     {
;;;1566      /* in case the Interrupt is not enabled, return RESET */
;;;1567       itstatus  = RESET;
;;;1568     }
;;;1569     
;;;1570     /* Return the CAN_IT status */
;;;1571     return  itstatus;
;;;1572   }
0000c6  4770              BX       lr
;;;1573   
                          ENDP

                  |L9.200|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1083     */
;;;1084   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1085   {
;;;1086     uint8_t counter=0;
;;;1087     
;;;1088     /* Check the parameters */
;;;1089     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1090     
;;;1091     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1092     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
000002  f3c04007          UBFX     r0,r0,#16,#8
;;;1093     
;;;1094     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1095     return counter;
;;;1096   }
000006  4770              BX       lr
;;;1097   /**
                          ENDP


                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=1

                  CAN_GetLastErrorCode PROC
;;;1038     */
;;;1039   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1040   {
;;;1041     uint8_t errorcode=0;
;;;1042     
;;;1043     /* Check the parameters */
;;;1044     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1045     
;;;1046     /* Get the error code*/
;;;1047     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000002  f3c01002          UBFX     r0,r0,#4,#3
000006  0100              LSLS     r0,r0,#4
;;;1048     
;;;1049     /* Return the error code*/
;;;1050     return errorcode;
;;;1051   }
000008  4770              BX       lr
;;;1052   
                          ENDP


                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetReceiveErrorCounter PROC
;;;1063     */
;;;1064   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1065   {
;;;1066     uint8_t counter=0;
;;;1067     
;;;1068     /* Check the parameters */
;;;1069     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1070     
;;;1071     /* Get the Receive Error Counter*/
;;;1072     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000002  0e00              LSRS     r0,r0,#24
;;;1073     
;;;1074     /* Return the Receive Error Counter*/
;;;1075     return counter;
;;;1076   }
000004  4770              BX       lr
;;;1077   
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;1288     */
;;;1289   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L13.10|
;;;1290   {
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1293     assert_param(IS_CAN_IT(CAN_IT));
;;;1294     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1295   
;;;1296     if (NewState != DISABLE)
;;;1297     {
;;;1298       /* Enable the selected CANx interrupt */
;;;1299       CANx->IER |= CAN_IT;
000002  6942              LDR      r2,[r0,#0x14]
000004  430a              ORRS     r2,r2,r1
000006  6142              STR      r2,[r0,#0x14]
;;;1300     }
;;;1301     else
;;;1302     {
;;;1303       /* Disable the selected CANx interrupt */
;;;1304       CANx->IER &= ~CAN_IT;
;;;1305     }
;;;1306   }
000008  4770              BX       lr
                  |L13.10|
00000a  6942              LDR      r2,[r0,#0x14]         ;1304
00000c  438a              BICS     r2,r2,r1              ;1304
00000e  6142              STR      r2,[r0,#0x14]         ;1304
000010  4770              BX       lr
;;;1307   /**
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;195      */
;;;196    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;199      uint32_t wait_ack = 0x00000000;
000002  2200              MOVS     r2,#0
;;;200      /* Check the parameters */
;;;201      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;202      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;203      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;204      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;205      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;206      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;207      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;208      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;209      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;210      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;211      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;212      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;213    
;;;214      /* Exit from sleep mode */
;;;215      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000004  6803              LDR      r3,[r0,#0]
000006  f0230302          BIC      r3,r3,#2
00000a  6003              STR      r3,[r0,#0]
;;;216    
;;;217      /* Request initialisation */
;;;218      CANx->MCR |= CAN_MCR_INRQ ;
00000c  6803              LDR      r3,[r0,#0]
00000e  f0430301          ORR      r3,r3,#1
000012  6003              STR      r3,[r0,#0]
;;;219    
;;;220      /* Wait the acknowledge */
;;;221      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000014  f64f73ff          MOV      r3,#0xffff
000018  e000              B        |L14.28|
                  |L14.26|
;;;222      {
;;;223        wait_ack++;
00001a  1c52              ADDS     r2,r2,#1
                  |L14.28|
00001c  6844              LDR      r4,[r0,#4]            ;221
00001e  07e4              LSLS     r4,r4,#31             ;221
000020  d101              BNE      |L14.38|
000022  429a              CMP      r2,r3                 ;221
000024  d1f9              BNE      |L14.26|
                  |L14.38|
;;;224      }
;;;225    
;;;226      /* Check acknowledge */
;;;227      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
000026  6842              LDR      r2,[r0,#4]
000028  07d2              LSLS     r2,r2,#31
00002a  d03e              BEQ      |L14.170|
;;;228      {
;;;229        InitStatus = CAN_InitStatus_Failed;
;;;230      }
;;;231      else 
;;;232      {
;;;233        /* Set the time triggered communication mode */
;;;234        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00002c  798a              LDRB     r2,[r1,#6]
00002e  2a01              CMP      r2,#1
000030  d03d              BEQ      |L14.174|
;;;235        {
;;;236          CANx->MCR |= CAN_MCR_TTCM;
;;;237        }
;;;238        else
;;;239        {
;;;240          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000032  6802              LDR      r2,[r0,#0]
000034  f0220280          BIC      r2,r2,#0x80
000038  6002              STR      r2,[r0,#0]
                  |L14.58|
;;;241        }
;;;242    
;;;243        /* Set the automatic bus-off management */
;;;244        if (CAN_InitStruct->CAN_ABOM == ENABLE)
00003a  79ca              LDRB     r2,[r1,#7]
00003c  2a01              CMP      r2,#1
00003e  d03b              BEQ      |L14.184|
;;;245        {
;;;246          CANx->MCR |= CAN_MCR_ABOM;
;;;247        }
;;;248        else
;;;249        {
;;;250          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000040  6802              LDR      r2,[r0,#0]
000042  f0220240          BIC      r2,r2,#0x40
000046  6002              STR      r2,[r0,#0]
                  |L14.72|
;;;251        }
;;;252    
;;;253        /* Set the automatic wake-up mode */
;;;254        if (CAN_InitStruct->CAN_AWUM == ENABLE)
000048  7a0a              LDRB     r2,[r1,#8]
00004a  2a01              CMP      r2,#1
00004c  d039              BEQ      |L14.194|
;;;255        {
;;;256          CANx->MCR |= CAN_MCR_AWUM;
;;;257        }
;;;258        else
;;;259        {
;;;260          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
00004e  6802              LDR      r2,[r0,#0]
000050  f0220220          BIC      r2,r2,#0x20
000054  6002              STR      r2,[r0,#0]
                  |L14.86|
;;;261        }
;;;262    
;;;263        /* Set the no automatic retransmission */
;;;264        if (CAN_InitStruct->CAN_NART == ENABLE)
000056  7a4a              LDRB     r2,[r1,#9]
000058  2a01              CMP      r2,#1
00005a  d037              BEQ      |L14.204|
;;;265        {
;;;266          CANx->MCR |= CAN_MCR_NART;
;;;267        }
;;;268        else
;;;269        {
;;;270          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
00005c  6802              LDR      r2,[r0,#0]
00005e  f0220210          BIC      r2,r2,#0x10
000062  6002              STR      r2,[r0,#0]
                  |L14.100|
;;;271        }
;;;272    
;;;273        /* Set the receive FIFO locked mode */
;;;274        if (CAN_InitStruct->CAN_RFLM == ENABLE)
000064  7a8a              LDRB     r2,[r1,#0xa]
000066  2a01              CMP      r2,#1
000068  d035              BEQ      |L14.214|
;;;275        {
;;;276          CANx->MCR |= CAN_MCR_RFLM;
;;;277        }
;;;278        else
;;;279        {
;;;280          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
00006a  6802              LDR      r2,[r0,#0]
00006c  f0220208          BIC      r2,r2,#8
000070  6002              STR      r2,[r0,#0]
                  |L14.114|
;;;281        }
;;;282    
;;;283        /* Set the transmit FIFO priority */
;;;284        if (CAN_InitStruct->CAN_TXFP == ENABLE)
000072  7aca              LDRB     r2,[r1,#0xb]
000074  2a01              CMP      r2,#1
000076  d033              BEQ      |L14.224|
;;;285        {
;;;286          CANx->MCR |= CAN_MCR_TXFP;
;;;287        }
;;;288        else
;;;289        {
;;;290          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
000078  6802              LDR      r2,[r0,#0]
00007a  f0220204          BIC      r2,r2,#4
00007e  6002              STR      r2,[r0,#0]
                  |L14.128|
;;;291        }
;;;292    
;;;293        /* Set the bit timing register */
;;;294        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
000080  788a              LDRB     r2,[r1,#2]
000082  78cc              LDRB     r4,[r1,#3]
000084  0792              LSLS     r2,r2,#30
000086  ea426204          ORR      r2,r2,r4,LSL #24
00008a  790c              LDRB     r4,[r1,#4]
00008c  ea424204          ORR      r2,r2,r4,LSL #16
000090  794c              LDRB     r4,[r1,#5]
000092  8809              LDRH     r1,[r1,#0]
000094  ea425204          ORR      r2,r2,r4,LSL #20
000098  1e49              SUBS     r1,r1,#1
00009a  430a              ORRS     r2,r2,r1
00009c  61c2              STR      r2,[r0,#0x1c]
;;;295                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;296                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;297                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;298                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;299    
;;;300        /* Request leave initialisation */
;;;301        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
00009e  6801              LDR      r1,[r0,#0]
0000a0  f0210101          BIC      r1,r1,#1
0000a4  6001              STR      r1,[r0,#0]
;;;302    
;;;303       /* Wait the acknowledge */
;;;304       wait_ack = 0;
0000a6  2100              MOVS     r1,#0
;;;305    
;;;306       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0000a8  e020              B        |L14.236|
                  |L14.170|
0000aa  2000              MOVS     r0,#0                 ;229
;;;307       {
;;;308         wait_ack++;
;;;309       }
;;;310    
;;;311        /* ...and check acknowledged */
;;;312        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
;;;313        {
;;;314          InitStatus = CAN_InitStatus_Failed;
;;;315        }
;;;316        else
;;;317        {
;;;318          InitStatus = CAN_InitStatus_Success ;
;;;319        }
;;;320      }
;;;321    
;;;322      /* At this step, return the status of initialization */
;;;323      return InitStatus;
;;;324    }
0000ac  bd10              POP      {r4,pc}
                  |L14.174|
0000ae  6802              LDR      r2,[r0,#0]            ;236
0000b0  f0420280          ORR      r2,r2,#0x80           ;236
0000b4  6002              STR      r2,[r0,#0]            ;236
0000b6  e7c0              B        |L14.58|
                  |L14.184|
0000b8  6802              LDR      r2,[r0,#0]            ;246
0000ba  f0420240          ORR      r2,r2,#0x40           ;246
0000be  6002              STR      r2,[r0,#0]            ;246
0000c0  e7c2              B        |L14.72|
                  |L14.194|
0000c2  6802              LDR      r2,[r0,#0]            ;256
0000c4  f0420220          ORR      r2,r2,#0x20           ;256
0000c8  6002              STR      r2,[r0,#0]            ;256
0000ca  e7c4              B        |L14.86|
                  |L14.204|
0000cc  6802              LDR      r2,[r0,#0]            ;266
0000ce  f0420210          ORR      r2,r2,#0x10           ;266
0000d2  6002              STR      r2,[r0,#0]            ;266
0000d4  e7c6              B        |L14.100|
                  |L14.214|
0000d6  6802              LDR      r2,[r0,#0]            ;276
0000d8  f0420208          ORR      r2,r2,#8              ;276
0000dc  6002              STR      r2,[r0,#0]            ;276
0000de  e7c8              B        |L14.114|
                  |L14.224|
0000e0  6802              LDR      r2,[r0,#0]            ;286
0000e2  f0420204          ORR      r2,r2,#4              ;286
0000e6  6002              STR      r2,[r0,#0]            ;286
0000e8  e7ca              B        |L14.128|
                  |L14.234|
0000ea  1c49              ADDS     r1,r1,#1              ;308
                  |L14.236|
0000ec  6842              LDR      r2,[r0,#4]            ;306
0000ee  07d2              LSLS     r2,r2,#31             ;306
0000f0  d001              BEQ      |L14.246|
0000f2  4299              CMP      r1,r3                 ;306
0000f4  d1f9              BNE      |L14.234|
                  |L14.246|
0000f6  6840              LDR      r0,[r0,#4]            ;312
0000f8  07c0              LSLS     r0,r0,#31             ;312
0000fa  d001              BEQ      |L14.256|
0000fc  2000              MOVS     r0,#0                 ;314
0000fe  bd10              POP      {r4,pc}
                  |L14.256|
000100  2001              MOVS     r0,#1                 ;318
000102  bd10              POP      {r4,pc}
;;;325    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;820      */
;;;821    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;822    {
;;;823      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;824      /* Check the parameters */
;;;825      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;826      assert_param(IS_CAN_FIFO(FIFONumber));
;;;827      if (FIFONumber == CAN_FIFO0)
000004  b129              CBZ      r1,|L15.18|
;;;828      {
;;;829        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
;;;830      }
;;;831      else if (FIFONumber == CAN_FIFO1)
000006  2901              CMP      r1,#1
000008  d102              BNE      |L15.16|
;;;832      {
;;;833        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
00000a  6910              LDR      r0,[r2,#0x10]
00000c  f0000003          AND      r0,r0,#3
                  |L15.16|
;;;834      }
;;;835      else
;;;836      {
;;;837        message_pending = 0;
;;;838      }
;;;839      return message_pending;
;;;840    }
000010  4770              BX       lr
                  |L15.18|
000012  68d0              LDR      r0,[r2,#0xc]          ;829
000014  f0000003          AND      r0,r0,#3              ;829
000018  4770              BX       lr
;;;841    /**
                          ENDP


                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=1

                  CAN_OperatingModeRequest PROC
;;;870      */
;;;871    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  2300              MOVS     r3,#0
;;;872    {
;;;873      uint8_t status = CAN_ModeStatus_Failed;
;;;874      
;;;875      /* Timeout for INAK or also for SLAK bits*/
;;;876      uint32_t timeout = INAK_TIMEOUT; 
000002  f64f72ff          MOV      r2,#0xffff
;;;877    
;;;878      /* Check the parameters */
;;;879      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;880      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;881    
;;;882      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
000006  b121              CBZ      r1,|L16.18|
;;;883      {
;;;884        /* Request initialisation */
;;;885        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
;;;886    
;;;887        /* Wait the acknowledge */
;;;888        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
;;;889        {
;;;890          timeout--;
;;;891        }
;;;892        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
;;;893        {
;;;894          status = CAN_ModeStatus_Failed;
;;;895        }
;;;896        else
;;;897        {
;;;898          status = CAN_ModeStatus_Success;
;;;899        }
;;;900      }
;;;901      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
000008  2901              CMP      r1,#1
00000a  d01a              BEQ      |L16.66|
;;;902      {
;;;903        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;904        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
;;;905    
;;;906        /* Wait the acknowledge */
;;;907        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
;;;908        {
;;;909          timeout--;
;;;910        }
;;;911        if ((CANx->MSR & CAN_MODE_MASK) != 0)
;;;912        {
;;;913          status = CAN_ModeStatus_Failed;
;;;914        }
;;;915        else
;;;916        {
;;;917          status = CAN_ModeStatus_Success;
;;;918        }
;;;919      }
;;;920      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00000c  2902              CMP      r1,#2
00000e  d02a              BEQ      |L16.102|
000010  e040              B        |L16.148|
                  |L16.18|
000012  6801              LDR      r1,[r0,#0]            ;885
000014  f0210102          BIC      r1,r1,#2              ;885
000018  f0410101          ORR      r1,r1,#1              ;885
00001c  6001              STR      r1,[r0,#0]            ;885
00001e  e000              B        |L16.34|
                  |L16.32|
000020  1e52              SUBS     r2,r2,#1              ;890
                  |L16.34|
000022  6841              LDR      r1,[r0,#4]            ;888
000024  f0010103          AND      r1,r1,#3              ;888
000028  2901              CMP      r1,#1                 ;888
00002a  d001              BEQ      |L16.48|
00002c  2a00              CMP      r2,#0                 ;888
00002e  d1f7              BNE      |L16.32|
                  |L16.48|
000030  6840              LDR      r0,[r0,#4]            ;892
000032  f0000003          AND      r0,r0,#3              ;892
000036  2801              CMP      r0,#1                 ;892
000038  d001              BEQ      |L16.62|
00003a  2300              MOVS     r3,#0                 ;894
00003c  e02a              B        |L16.148|
                  |L16.62|
00003e  2301              MOVS     r3,#1                 ;898
000040  e028              B        |L16.148|
                  |L16.66|
000042  6801              LDR      r1,[r0,#0]            ;904
000044  f0210103          BIC      r1,r1,#3              ;904
000048  6001              STR      r1,[r0,#0]            ;904
00004a  e000              B        |L16.78|
                  |L16.76|
00004c  1e52              SUBS     r2,r2,#1              ;909
                  |L16.78|
00004e  6841              LDR      r1,[r0,#4]            ;907
000050  0789              LSLS     r1,r1,#30             ;907
000052  d001              BEQ      |L16.88|
000054  2a00              CMP      r2,#0                 ;907
000056  d1f9              BNE      |L16.76|
                  |L16.88|
000058  6840              LDR      r0,[r0,#4]            ;911
00005a  0780              LSLS     r0,r0,#30             ;911
00005c  d001              BEQ      |L16.98|
00005e  2300              MOVS     r3,#0                 ;913
000060  e018              B        |L16.148|
                  |L16.98|
000062  2301              MOVS     r3,#1                 ;917
000064  e016              B        |L16.148|
                  |L16.102|
;;;921      {
;;;922        /* Request Sleep mode */
;;;923        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  f0410102          ORR      r1,r1,#2
000070  6001              STR      r1,[r0,#0]
;;;924    
;;;925        /* Wait the acknowledge */
;;;926        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
000072  e000              B        |L16.118|
                  |L16.116|
;;;927        {
;;;928          timeout--;
000074  1e52              SUBS     r2,r2,#1
                  |L16.118|
000076  6841              LDR      r1,[r0,#4]            ;926
000078  f0010103          AND      r1,r1,#3              ;926
00007c  2902              CMP      r1,#2                 ;926
00007e  d001              BEQ      |L16.132|
000080  2a00              CMP      r2,#0                 ;926
000082  d1f7              BNE      |L16.116|
                  |L16.132|
;;;929        }
;;;930        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000084  6840              LDR      r0,[r0,#4]
000086  f0000003          AND      r0,r0,#3
00008a  2802              CMP      r0,#2
00008c  d001              BEQ      |L16.146|
;;;931        {
;;;932          status = CAN_ModeStatus_Failed;
00008e  2300              MOVS     r3,#0
000090  e000              B        |L16.148|
                  |L16.146|
;;;933        }
;;;934        else
;;;935        {
;;;936          status = CAN_ModeStatus_Success;
000092  2301              MOVS     r3,#1
                  |L16.148|
;;;937        }
;;;938      }
;;;939      else
;;;940      {
;;;941        status = CAN_ModeStatus_Failed;
;;;942      }
;;;943    
;;;944      return  (uint8_t) status;
000094  4618              MOV      r0,r3
;;;945    }
000096  4770              BX       lr
;;;946    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;748      */
;;;749    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b510              PUSH     {r4,lr}
;;;750    {
;;;751      /* Check the parameters */
;;;752      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;753      assert_param(IS_CAN_FIFO(FIFONumber));
;;;754      /* Get the Id */
;;;755      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000002  eb001301          ADD      r3,r0,r1,LSL #4
000006  f8d341b0          LDR      r4,[r3,#0x1b0]
00000a  f0040404          AND      r4,r4,#4
00000e  7214              STRB     r4,[r2,#8]
;;;756      if (RxMessage->IDE == CAN_Id_Standard)
000010  b39c              CBZ      r4,|L17.122|
;;;757      {
;;;758        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;759      }
;;;760      else
;;;761      {
;;;762        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000012  f8d341b0          LDR      r4,[r3,#0x1b0]
000016  08e4              LSRS     r4,r4,#3
000018  6054              STR      r4,[r2,#4]
                  |L17.26|
;;;763      }
;;;764      
;;;765      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
00001a  f50373d8          ADD      r3,r3,#0x1b0
00001e  681c              LDR      r4,[r3,#0]
000020  f0040402          AND      r4,r4,#2
000024  7254              STRB     r4,[r2,#9]
;;;766      /* Get the DLC */
;;;767      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000026  685c              LDR      r4,[r3,#4]
000028  f004040f          AND      r4,r4,#0xf
00002c  7294              STRB     r4,[r2,#0xa]
;;;768      /* Get the FMI */
;;;769      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
00002e  685c              LDR      r4,[r3,#4]
000030  ea4f2414          LSR      r4,r4,#8
000034  74d4              STRB     r4,[r2,#0x13]
;;;770      /* Get the data field */
;;;771      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000036  689c              LDR      r4,[r3,#8]
000038  72d4              STRB     r4,[r2,#0xb]
;;;772      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
00003a  689c              LDR      r4,[r3,#8]
00003c  ea4f2414          LSR      r4,r4,#8
000040  7314              STRB     r4,[r2,#0xc]
;;;773      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000042  689c              LDR      r4,[r3,#8]
000044  ea4f4414          LSR      r4,r4,#16
000048  7354              STRB     r4,[r2,#0xd]
;;;774      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00004a  689c              LDR      r4,[r3,#8]
00004c  ea4f6414          LSR      r4,r4,#24
000050  7394              STRB     r4,[r2,#0xe]
;;;775      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000052  68dc              LDR      r4,[r3,#0xc]
000054  73d4              STRB     r4,[r2,#0xf]
;;;776      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
000056  68dc              LDR      r4,[r3,#0xc]
000058  ea4f2414          LSR      r4,r4,#8
00005c  7414              STRB     r4,[r2,#0x10]
;;;777      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
00005e  68dc              LDR      r4,[r3,#0xc]
000060  ea4f4414          LSR      r4,r4,#16
000064  7454              STRB     r4,[r2,#0x11]
;;;778      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
000066  68db              LDR      r3,[r3,#0xc]
000068  ea4f6313          LSR      r3,r3,#24
00006c  7493              STRB     r3,[r2,#0x12]
;;;779      /* Release the FIFO */
;;;780      /* Release FIFO0 */
;;;781      if (FIFONumber == CAN_FIFO0)
00006e  b151              CBZ      r1,|L17.134|
;;;782      {
;;;783        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;784      }
;;;785      /* Release FIFO1 */
;;;786      else /* FIFONumber == CAN_FIFO1 */
;;;787      {
;;;788        CANx->RF1R |= CAN_RF1R_RFOM1;
000070  6901              LDR      r1,[r0,#0x10]
000072  f0410120          ORR      r1,r1,#0x20
000076  6101              STR      r1,[r0,#0x10]
                  |L17.120|
;;;789      }
;;;790    }
000078  bd10              POP      {r4,pc}
                  |L17.122|
00007a  e7ff              B        |L17.124|
                  |L17.124|
00007c  f8d341b0          LDR      r4,[r3,#0x1b0]        ;758
000080  0d64              LSRS     r4,r4,#21             ;758
000082  6014              STR      r4,[r2,#0]            ;758
000084  e7c9              B        |L17.26|
                  |L17.134|
000086  68c1              LDR      r1,[r0,#0xc]          ;783
000088  f0410120          ORR      r1,r1,#0x20           ;783
00008c  60c1              STR      r1,[r0,#0xc]          ;783
00008e  e7f3              B        |L17.120|
;;;791    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;466      */
;;;467    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  4909              LDR      r1,|L18.40|
;;;468    {
;;;469      /* Check the parameters */
;;;470      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;471      
;;;472      /* Enter Initialisation mode for the filter */
;;;473      CAN1->FMR |= FMR_FINIT;
000002  680a              LDR      r2,[r1,#0]
000004  f0420201          ORR      r2,r2,#1
000008  600a              STR      r2,[r1,#0]
;;;474      
;;;475      /* Select the start slave bank */
;;;476      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000a  680a              LDR      r2,[r1,#0]
00000c  f643730e          MOV      r3,#0x3f0e
000010  439a              BICS     r2,r2,r3
000012  600a              STR      r2,[r1,#0]
;;;477      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000014  680a              LDR      r2,[r1,#0]
000016  ea422000          ORR      r0,r2,r0,LSL #8
00001a  6008              STR      r0,[r1,#0]
;;;478      
;;;479      /* Leave Initialisation mode for the filter */
;;;480      CAN1->FMR &= ~FMR_FINIT;
00001c  6808              LDR      r0,[r1,#0]
00001e  f0200001          BIC      r0,r0,#1
000022  6008              STR      r0,[r1,#0]
;;;481    }
000024  4770              BX       lr
;;;482    
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;951      */
;;;952    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  2100              MOVS     r1,#0
;;;953    {
;;;954      uint8_t sleepstatus = CAN_Sleep_Failed;
;;;955      
;;;956      /* Check the parameters */
;;;957      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;958        
;;;959      /* Request Sleep mode */
;;;960       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000002  6802              LDR      r2,[r0,#0]
000004  f0220201          BIC      r2,r2,#1
000008  f0420202          ORR      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;961       
;;;962      /* Sleep mode status */
;;;963      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
00000e  6840              LDR      r0,[r0,#4]
000010  f0000003          AND      r0,r0,#3
000014  2802              CMP      r0,#2
000016  d100              BNE      |L19.26|
;;;964      {
;;;965        /* Sleep mode not entered */
;;;966        sleepstatus =  CAN_Sleep_Ok;
000018  2101              MOVS     r1,#1
                  |L19.26|
;;;967      }
;;;968      /* return sleep mode status */
;;;969       return (uint8_t)sleepstatus;
00001a  4608              MOV      r0,r1
;;;970    }
00001c  4770              BX       lr
;;;971    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;423      */
;;;424    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;425    {
;;;426      /* Reset CAN init structure parameters values */
;;;427      
;;;428      /* Initialize the time triggered communication mode */
;;;429      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;430      
;;;431      /* Initialize the automatic bus-off management */
;;;432      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;433      
;;;434      /* Initialize the automatic wake-up mode */
;;;435      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;436      
;;;437      /* Initialize the no automatic retransmission */
;;;438      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;439      
;;;440      /* Initialize the receive FIFO locked mode */
;;;441      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;442      
;;;443      /* Initialize the transmit FIFO priority */
;;;444      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;445      
;;;446      /* Initialize the CAN_Mode member */
;;;447      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;448      
;;;449      /* Initialize the CAN_SJW member */
;;;450      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;451      
;;;452      /* Initialize the CAN_BS1 member */
;;;453      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;454      
;;;455      /* Initialize the CAN_BS2 member */
;;;456      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;457      
;;;458      /* Initialize the CAN_Prescaler member */
;;;459      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;460    }
00001e  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=1

                  CAN_TTComModeCmd PROC
;;;521      */
;;;522    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b1b1              CBZ      r1,|L21.48|
;;;523    {
;;;524      /* Check the parameters */
;;;525      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;526      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;527      if (NewState != DISABLE)
;;;528      {
;;;529        /* Enable the TTCM mode */
;;;530        CANx->MCR |= CAN_MCR_TTCM;
000002  6801              LDR      r1,[r0,#0]
000004  f0410180          ORR      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;531    
;;;532        /* Set TGT bits */
;;;533        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
00000a  f8d01184          LDR      r1,[r0,#0x184]
00000e  f4417180          ORR      r1,r1,#0x100
000012  f8c01184          STR      r1,[r0,#0x184]
;;;534        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
000016  f8d01194          LDR      r1,[r0,#0x194]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  f8c01194          STR      r1,[r0,#0x194]
;;;535        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
000022  f8d011a4          LDR      r1,[r0,#0x1a4]
000026  f4417180          ORR      r1,r1,#0x100
00002a  f8c011a4          STR      r1,[r0,#0x1a4]
;;;536      }
;;;537      else
;;;538      {
;;;539        /* Disable the TTCM mode */
;;;540        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
;;;541    
;;;542        /* Reset TGT bits */
;;;543        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
;;;544        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
;;;545        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
;;;546      }
;;;547    }
00002e  4770              BX       lr
                  |L21.48|
000030  6801              LDR      r1,[r0,#0]            ;540
000032  f0210180          BIC      r1,r1,#0x80           ;540
000036  6001              STR      r1,[r0,#0]            ;540
000038  f8d01184          LDR      r1,[r0,#0x184]        ;543
00003c  f4217180          BIC      r1,r1,#0x100          ;543
000040  f8c01184          STR      r1,[r0,#0x184]        ;543
000044  f8d01194          LDR      r1,[r0,#0x194]        ;544
000048  f4217180          BIC      r1,r1,#0x100          ;544
00004c  f8c01194          STR      r1,[r0,#0x194]        ;544
000050  f8d011a4          LDR      r1,[r0,#0x1a4]        ;545
000054  f4217180          BIC      r1,r1,#0x100          ;545
000058  f8c011a4          STR      r1,[r0,#0x1a4]        ;545
00005c  4770              BX       lr
;;;548    /**
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;575      */
;;;576    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;577    {
000002  4602              MOV      r2,r0
;;;578      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;579      /* Check the parameters */
;;;580      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;581      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;582      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;583      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;584    
;;;585      /* Select one empty transmit mailbox */
;;;586      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  015b              LSLS     r3,r3,#5
00000a  d40a              BMI      |L22.34|
;;;587      {
;;;588        transmit_mailbox = 0;
;;;589      }
;;;590      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
00000c  6890              LDR      r0,[r2,#8]
00000e  0100              LSLS     r0,r0,#4
000010  d501              BPL      |L22.22|
;;;591      {
;;;592        transmit_mailbox = 1;
000012  2001              MOVS     r0,#1
000014  e005              B        |L22.34|
                  |L22.22|
;;;593      }
;;;594      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000016  6890              LDR      r0,[r2,#8]
000018  00c0              LSLS     r0,r0,#3
00001a  d501              BPL      |L22.32|
;;;595      {
;;;596        transmit_mailbox = 2;
00001c  2002              MOVS     r0,#2
00001e  e000              B        |L22.34|
                  |L22.32|
;;;597      }
;;;598      else
;;;599      {
;;;600        transmit_mailbox = CAN_TxStatus_NoMailBox;
000020  2004              MOVS     r0,#4
                  |L22.34|
;;;601      }
;;;602    
;;;603      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
000022  2804              CMP      r0,#4
000024  d040              BEQ      |L22.168|
;;;604      {
;;;605        /* Set up the Id */
;;;606        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
000026  eb021200          ADD      r2,r2,r0,LSL #4
00002a  f8d23180          LDR      r3,[r2,#0x180]
00002e  f0030301          AND      r3,r3,#1
000032  f8c23180          STR      r3,[r2,#0x180]
;;;607        if (TxMessage->IDE == CAN_Id_Standard)
000036  7a0b              LDRB     r3,[r1,#8]
000038  b3bb              CBZ      r3,|L22.170|
;;;608        {
;;;609          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;610          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;611                                                      TxMessage->RTR);
;;;612        }
;;;613        else
;;;614        {
;;;615          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;616          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
00003a  f8d24180          LDR      r4,[r2,#0x180]
00003e  684d              LDR      r5,[r1,#4]
000040  431c              ORRS     r4,r4,r3
000042  7a4b              LDRB     r3,[r1,#9]
000044  ea4303c5          ORR      r3,r3,r5,LSL #3
000048  431c              ORRS     r4,r4,r3
00004a  f8c24180          STR      r4,[r2,#0x180]
                  |L22.78|
;;;617                                                      TxMessage->IDE | \
;;;618                                                      TxMessage->RTR);
;;;619        }
;;;620        
;;;621        /* Set up the DLC */
;;;622        TxMessage->DLC &= (uint8_t)0x0000000F;
00004e  7a8b              LDRB     r3,[r1,#0xa]
000050  f003030f          AND      r3,r3,#0xf
000054  728b              STRB     r3,[r1,#0xa]
;;;623        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
000056  f50272c0          ADD      r2,r2,#0x180
00005a  6853              LDR      r3,[r2,#4]
00005c  f023030f          BIC      r3,r3,#0xf
000060  6053              STR      r3,[r2,#4]
;;;624        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
000062  6853              LDR      r3,[r2,#4]
000064  7a8c              LDRB     r4,[r1,#0xa]
000066  ea430304          ORR      r3,r3,r4
00006a  6053              STR      r3,[r2,#4]
;;;625    
;;;626        /* Set up the data field */
;;;627        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
00006c  7acb              LDRB     r3,[r1,#0xb]
00006e  7b8c              LDRB     r4,[r1,#0xe]
000070  7b0d              LDRB     r5,[r1,#0xc]
000072  ea436304          ORR      r3,r3,r4,LSL #24
000076  7b4c              LDRB     r4,[r1,#0xd]
000078  ea4f4404          LSL      r4,r4,#16
00007c  ea442405          ORR      r4,r4,r5,LSL #8
000080  ea430304          ORR      r3,r3,r4
000084  6093              STR      r3,[r2,#8]
;;;628                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;629                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;630                                                 ((uint32_t)TxMessage->Data[0]));
;;;631        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000086  7bcb              LDRB     r3,[r1,#0xf]
000088  7c8c              LDRB     r4,[r1,#0x12]
00008a  ea436304          ORR      r3,r3,r4,LSL #24
00008e  7c4c              LDRB     r4,[r1,#0x11]
000090  7c09              LDRB     r1,[r1,#0x10]
000092  ea4f4404          LSL      r4,r4,#16
000096  ea442101          ORR      r1,r4,r1,LSL #8
00009a  ea430301          ORR      r3,r3,r1
00009e  60d3              STR      r3,[r2,#0xc]
;;;632                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;633                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;634                                                 ((uint32_t)TxMessage->Data[4]));
;;;635        /* Request transmission */
;;;636        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
0000a0  6811              LDR      r1,[r2,#0]
0000a2  f0410101          ORR      r1,r1,#1
0000a6  6011              STR      r1,[r2,#0]
                  |L22.168|
;;;637      }
;;;638      return transmit_mailbox;
;;;639    }
0000a8  bd30              POP      {r4,r5,pc}
                  |L22.170|
0000aa  e7ff              B        |L22.172|
                  |L22.172|
0000ac  f8d23180          LDR      r3,[r2,#0x180]        ;610
0000b0  7a4c              LDRB     r4,[r1,#9]            ;610
0000b2  4323              ORRS     r3,r3,r4              ;610
0000b4  680c              LDR      r4,[r1,#0]            ;610
0000b6  ea435344          ORR      r3,r3,r4,LSL #21      ;610
0000ba  f8c23180          STR      r3,[r2,#0x180]        ;610
0000be  e7c6              B        |L22.78|
;;;640    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;647      */
;;;648    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  2200              MOVS     r2,#0
;;;649    {
;;;650      uint32_t state = 0;
;;;651    
;;;652      /* Check the parameters */
;;;653      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;654      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;655     
;;;656      switch (TransmitMailbox)
000002  b121              CBZ      r1,|L23.14|
000004  2901              CMP      r1,#1
000006  d006              BEQ      |L23.22|
000008  2902              CMP      r1,#2
00000a  d10b              BNE      |L23.36|
00000c  e007              B        |L23.30|
                  |L23.14|
;;;657      {
;;;658        case (CAN_TXMAILBOX_0): 
;;;659          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
00000e  6882              LDR      r2,[r0,#8]
000010  4818              LDR      r0,|L23.116|
000012  4002              ANDS     r2,r2,r0
;;;660          break;
000014  e006              B        |L23.36|
                  |L23.22|
;;;661        case (CAN_TXMAILBOX_1): 
;;;662          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000016  6882              LDR      r2,[r0,#8]
000018  4817              LDR      r0,|L23.120|
00001a  4002              ANDS     r2,r2,r0
;;;663          break;
00001c  e002              B        |L23.36|
                  |L23.30|
;;;664        case (CAN_TXMAILBOX_2): 
;;;665          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
00001e  6882              LDR      r2,[r0,#8]
000020  4816              LDR      r0,|L23.124|
000022  4002              ANDS     r2,r2,r0
                  |L23.36|
;;;666          break;
;;;667        default:
;;;668          state = CAN_TxStatus_Failed;
;;;669          break;
;;;670      }
;;;671      switch (state)
000024  4916              LDR      r1,|L23.128|
000026  1a50              SUBS     r0,r2,r1
000028  428a              CMP      r2,r1
00002a  d018              BEQ      |L23.94|
00002c  dc07              BGT      |L23.62|
00002e  b192              CBZ      r2,|L23.86|
000030  f06f6080          MVN      r0,#0x4000000
000034  1810              ADDS     r0,r2,r0
000036  d010              BEQ      |L23.90|
000038  2802              CMP      r0,#2
00003a  d109              BNE      |L23.80|
00003c  e013              B        |L23.102|
                  |L23.62|
00003e  f5b07f00          CMP      r0,#0x200
000042  d012              BEQ      |L23.106|
000044  490f              LDR      r1,|L23.132|
000046  1840              ADDS     r0,r0,r1
000048  d00b              BEQ      |L23.98|
00004a  f5b03f00          CMP      r0,#0x20000
00004e  d00e              BEQ      |L23.110|
                  |L23.80|
;;;672      {
;;;673          /* transmit pending  */
;;;674        case (0x0): state = CAN_TxStatus_Pending;
;;;675          break;
;;;676          /* transmit failed  */
;;;677         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;678          break;
;;;679         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;680          break;
;;;681         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;682          break;
;;;683          /* transmit succeeded  */
;;;684        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;685          break;
;;;686        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;687          break;
;;;688        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;689          break;
;;;690        default: state = CAN_TxStatus_Failed;
000050  2000              MOVS     r0,#0
                  |L23.82|
;;;691          break;
;;;692      }
;;;693      return (uint8_t) state;
000052  b2c0              UXTB     r0,r0
;;;694    }
000054  4770              BX       lr
                  |L23.86|
000056  2002              MOVS     r0,#2                 ;674
000058  e7fb              B        |L23.82|
                  |L23.90|
00005a  2000              MOVS     r0,#0                 ;677
00005c  e7f9              B        |L23.82|
                  |L23.94|
00005e  2000              MOVS     r0,#0                 ;679
000060  e7f7              B        |L23.82|
                  |L23.98|
000062  2000              MOVS     r0,#0                 ;681
000064  e7f5              B        |L23.82|
                  |L23.102|
000066  2001              MOVS     r0,#1                 ;684
000068  e7f3              B        |L23.82|
                  |L23.106|
00006a  2001              MOVS     r0,#1                 ;686
00006c  e7f1              B        |L23.82|
                  |L23.110|
00006e  2001              MOVS     r0,#1                 ;688
000070  e7ef              B        |L23.82|
;;;695    
                          ENDP

000072  0000              DCW      0x0000
                  |L23.116|
                          DCD      0x04000003
                  |L23.120|
                          DCD      0x08000300
                  |L23.124|
                          DCD      0x10030000
                  |L23.128|
                          DCD      0x08000100
                  |L23.132|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;976      */
;;;977    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  f64f71ff          MOV      r1,#0xffff
;;;978    {
;;;979      uint32_t wait_slak = SLAK_TIMEOUT;
;;;980      uint8_t wakeupstatus = CAN_WakeUp_Failed;
000004  2300              MOVS     r3,#0
;;;981      
;;;982      /* Check the parameters */
;;;983      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;984        
;;;985      /* Wake up request */
;;;986      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000006  6802              LDR      r2,[r0,#0]
000008  f0220202          BIC      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;987        
;;;988      /* Sleep mode status */
;;;989      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
00000e  e000              B        |L24.18|
                  |L24.16|
;;;990      {
;;;991       wait_slak--;
000010  1e49              SUBS     r1,r1,#1
                  |L24.18|
000012  6842              LDR      r2,[r0,#4]            ;989
000014  0792              LSLS     r2,r2,#30             ;989
000016  d501              BPL      |L24.28|
000018  2900              CMP      r1,#0                 ;989
00001a  d1f9              BNE      |L24.16|
                  |L24.28|
;;;992      }
;;;993      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00001c  6840              LDR      r0,[r0,#4]
00001e  0780              LSLS     r0,r0,#30
000020  d400              BMI      |L24.36|
;;;994      {
;;;995       /* wake up done : Sleep mode exited */
;;;996        wakeupstatus = CAN_WakeUp_Ok;
000022  2301              MOVS     r3,#1
                  |L24.36|
;;;997      }
;;;998      /* return wakeup status */
;;;999      return (uint8_t)wakeupstatus;
000024  4618              MOV      r0,r3
;;;1000   }
000026  4770              BX       lr
;;;1001   /**
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1670     */
;;;1671   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1672   {
;;;1673     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1674     
;;;1675     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  420a              TST      r2,r1
000006  d000              BEQ      |L25.10|
;;;1676     {
;;;1677       /* CAN_IT is set */
;;;1678       pendingbitstatus = SET;
000008  2001              MOVS     r0,#1
                  |L25.10|
;;;1679     }
;;;1680     else
;;;1681     {
;;;1682       /* CAN_IT is reset */
;;;1683       pendingbitstatus = RESET;
;;;1684     }
;;;1685     return pendingbitstatus;
;;;1686   }
00000a  4770              BX       lr
;;;1687   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_can.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_can_c_347dae01____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REVSH|
#line 128
|__asm___15_stm32f4xx_can_c_347dae01____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
