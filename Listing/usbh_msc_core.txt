; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usbh_msc_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usbh_msc_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usbh_msc_core.crf ..\USB\STM32_USB_HOST_Library\Class\MSC\src\usbh_msc_core.c]
                          THUMB

                          AREA ||i.USBH_MSC_BOTReset||, CODE, READONLY, ALIGN=1

                  USBH_MSC_BOTReset PROC
;;;472      */
;;;473    static USBH_Status USBH_MSC_BOTReset(USB_OTG_CORE_HANDLE *pdev,
000000  2221              MOVS     r2,#0x21
;;;474                                  USBH_HOST *phost)
;;;475    {
;;;476      
;;;477      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_TYPE_CLASS | \
000002  750a              STRB     r2,[r1,#0x14]
;;;478                                  USB_REQ_RECIPIENT_INTERFACE;
;;;479      
;;;480      phost->Control.setup.b.bRequest = USB_REQ_BOT_RESET;
000004  22ff              MOVS     r2,#0xff
000006  754a              STRB     r2,[r1,#0x15]
;;;481      phost->Control.setup.b.wValue.w = 0;
000008  2200              MOVS     r2,#0
00000a  82ca              STRH     r2,[r1,#0x16]
;;;482      phost->Control.setup.b.wIndex.w = 0;
00000c  830a              STRH     r2,[r1,#0x18]
;;;483      phost->Control.setup.b.wLength.w = 0;           
00000e  834a              STRH     r2,[r1,#0x1a]
;;;484      
;;;485      return USBH_CtlReq(pdev, phost, 0 , 0 ); 
000010  2300              MOVS     r3,#0
000012  461a              MOV      r2,r3
000014  f7ffbffe          B.W      USBH_CtlReq
;;;486    }
;;;487    
                          ENDP


                          AREA ||i.USBH_MSC_ClassRequest||, CODE, READONLY, ALIGN=2

                  USBH_MSC_ClassRequest PROC
;;;265    
;;;266    static USBH_Status USBH_MSC_ClassRequest(USB_OTG_CORE_HANDLE *pdev , 
000000  4901              LDR      r1,|L2.8|
;;;267                                            void *phost)
;;;268    {   
;;;269      
;;;270      USBH_Status status = USBH_OK ;
;;;271      USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_INIT_STATE;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;272      
;;;273      return status; 
;;;274    }
000006  4770              BX       lr
;;;275    
                          ENDP

                  |L2.8|
                          DCD      USBH_MSC_BOTXferParam

                          AREA ||i.USBH_MSC_ErrorHandle||, CODE, READONLY, ALIGN=2

                  USBH_MSC_ErrorHandle PROC
;;;517    
;;;518    void USBH_MSC_ErrorHandle(uint8_t status)
000000  490a              LDR      r1,|L3.44|
;;;519    {  
;;;520        if(status == USBH_MSC_FAIL)
;;;521        { 
;;;522          MSCErrorCount++;
;;;523          if(MSCErrorCount < USBH_MSC_ERROR_RETRY_LIMIT)
;;;524          { /* Try MSC level error recovery, Issue the request Sense to get 
;;;525            Drive error reason  */
;;;526            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_REQUEST_SENSE;
;;;527            USBH_MSC_BOTXferParam.CmdStateMachine = CMD_SEND_STATE;
;;;528          }
;;;529          else
;;;530          {
;;;531            /* Error trials exceeded the limit, go to unrecovered state */
;;;532            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
000002  220a              MOVS     r2,#0xa
000004  2801              CMP      r0,#1                 ;520
000006  d003              BEQ      |L3.16|
;;;533          }
;;;534        } 
;;;535        else if(status == USBH_MSC_PHASE_ERROR)
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L3.14|
;;;536        {
;;;537          /* Phase error, Go to Unrecoovered state */
;;;538          USBH_MSC_BOTXferParam.MSCState = USBH_MSC_UNRECOVERED_STATE;
00000c  700a              STRB     r2,[r1,#0]
                  |L3.14|
;;;539        }
;;;540        else if(status == USBH_MSC_BUSY)
;;;541        {
;;;542          /*No change in state*/
;;;543        }
;;;544    }
00000e  4770              BX       lr
                  |L3.16|
000010  4b07              LDR      r3,|L3.48|
000012  7818              LDRB     r0,[r3,#0]            ;522  ; MSCErrorCount
000014  1c40              ADDS     r0,r0,#1              ;522
000016  b2c0              UXTB     r0,r0                 ;522
000018  7018              STRB     r0,[r3,#0]            ;522
00001a  280a              CMP      r0,#0xa               ;523
00001c  d204              BCS      |L3.40|
00001e  2006              MOVS     r0,#6                 ;526
000020  7008              STRB     r0,[r1,#0]            ;526
000022  2001              MOVS     r0,#1                 ;527
000024  70c8              STRB     r0,[r1,#3]            ;527
000026  4770              BX       lr
                  |L3.40|
000028  700a              STRB     r2,[r1,#0]            ;532
00002a  4770              BX       lr
;;;545    
                          ENDP

                  |L3.44|
                          DCD      USBH_MSC_BOTXferParam
                  |L3.48|
                          DCD      ||.data||

                          AREA ||i.USBH_MSC_GETMaxLUN||, CODE, READONLY, ALIGN=2

                  USBH_MSC_GETMaxLUN PROC
;;;496      */
;;;497    static USBH_Status USBH_MSC_GETMaxLUN(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  22a1              MOVS     r2,#0xa1
;;;498    {
;;;499      phost->Control.setup.b.bmRequestType = USB_D2H | USB_REQ_TYPE_CLASS | \
000002  750a              STRB     r2,[r1,#0x14]
;;;500                                  USB_REQ_RECIPIENT_INTERFACE;
;;;501      
;;;502      phost->Control.setup.b.bRequest = USB_REQ_GET_MAX_LUN;
000004  22fe              MOVS     r2,#0xfe
000006  754a              STRB     r2,[r1,#0x15]
;;;503      phost->Control.setup.b.wValue.w = 0;
000008  2200              MOVS     r2,#0
00000a  82ca              STRH     r2,[r1,#0x16]
;;;504      phost->Control.setup.b.wIndex.w = 0;
00000c  830a              STRH     r2,[r1,#0x18]
;;;505      phost->Control.setup.b.wLength.w = 1;           
00000e  2201              MOVS     r2,#1
000010  834a              STRH     r2,[r1,#0x1a]
;;;506      
;;;507      return USBH_CtlReq(pdev, phost, MSC_Machine.buff , 1 ); 
000012  2301              MOVS     r3,#1
000014  4a01              LDR      r2,|L4.28|
000016  f7ffbffe          B.W      USBH_CtlReq
;;;508    }
;;;509    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ||.bss||+0x8

                          AREA ||i.USBH_MSC_Handle||, CODE, READONLY, ALIGN=2

                  USBH_MSC_Handle PROC
;;;284    
;;;285    static USBH_Status USBH_MSC_Handle(USB_OTG_CORE_HANDLE *pdev , 
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;286                                       void   *phost)
;;;287    {
000004  460d              MOV      r5,r1
;;;288      USBH_HOST *pphost = phost;
;;;289        
;;;290      USBH_Status status = USBH_BUSY;
000006  2401              MOVS     r4,#1
;;;291      uint8_t mscStatus = USBH_MSC_BUSY;
;;;292      uint8_t appliStatus = 0;
;;;293      
;;;294      static uint8_t maxLunExceed = FALSE;
;;;295      
;;;296        
;;;297      if(HCD_IsDeviceConnected(pdev))
000008  9800              LDR      r0,[sp,#0]
00000a  f7fffffe          BL       HCD_IsDeviceConnected
00000e  2800              CMP      r0,#0
000010  d018              BEQ      |L5.68|
;;;298      {   
;;;299        switch(USBH_MSC_BOTXferParam.MSCState)
000012  4e4d              LDR      r6,|L5.328|
;;;300        {
;;;301        case USBH_MSC_BOT_INIT_STATE:
;;;302          USBH_MSC_Init(pdev);
;;;303          USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOT_RESET;  
;;;304          break;
;;;305          
;;;306        case USBH_MSC_BOT_RESET:   
;;;307          /* Issue BOT RESET request */
;;;308          status = USBH_MSC_BOTReset(pdev, phost);
;;;309          if(status == USBH_OK )
;;;310          {
;;;311            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_GET_MAX_LUN;
;;;312          }
;;;313          
;;;314          if(status == USBH_NOT_SUPPORTED )
;;;315          {
;;;316           /* If the Command has failed, then we need to move to Next State, after
;;;317            STALL condition is cleared by Control-Transfer */
;;;318            USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_GET_MAX_LUN; 
;;;319    
;;;320            /* a Clear Feature should be issued here */
;;;321            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
;;;322          }  
;;;323          break;
;;;324          
;;;325        case USBH_MSC_GET_MAX_LUN:
;;;326          /* Issue GetMaxLUN request */
;;;327          status = USBH_MSC_GETMaxLUN(pdev, phost);
;;;328          
;;;329          if(status == USBH_OK )
;;;330          {
;;;331            MSC_Machine.maxLun = *(MSC_Machine.buff) ;
000014  f8df9134          LDR      r9,|L5.332|
;;;332            
;;;333            /* If device has more that one logical unit then it is not supported */
;;;334            if((MSC_Machine.maxLun > 0) && (maxLunExceed == FALSE))
000018  4f4d              LDR      r7,|L5.336|
00001a  7830              LDRB     r0,[r6,#0]            ;299  ; USBH_MSC_BOTXferParam
00001c  46a2              MOV      r10,r4                ;290
00001e  f04f0800          MOV      r8,#0                 ;292
000022  f04f0b08          MOV      r11,#8                ;299
000026  280b              CMP      r0,#0xb               ;299
000028  d20c              BCS      |L5.68|
00002a  e8dff000          TBB      [pc,r0]               ;299
00002e  060c              DCB      0x06,0x0c
000030  1a44515e          DCB      0x1a,0x44,0x51,0x5e
000034  6b767b37          DCB      0x6b,0x76,0x7b,0x37
000038  8900              DCB      0x89,0x00
00003a  9800              LDR      r0,[sp,#0]            ;302
00003c  f7fffffe          BL       USBH_MSC_Init
000040  f886a000          STRB     r10,[r6,#0]           ;303
                  |L5.68|
000044  e07d              B        |L5.322|
000046  4629              MOV      r1,r5                 ;308
000048  9800              LDR      r0,[sp,#0]            ;308
00004a  f7fffffe          BL       USBH_MSC_BOTReset
00004e  4604              MOV      r4,r0                 ;308
000050  2002              MOVS     r0,#2                 ;299
000052  b904              CBNZ     r4,|L5.86|
000054  7030              STRB     r0,[r6,#0]            ;311
                  |L5.86|
000056  2c03              CMP      r4,#3                 ;314
000058  d173              BNE      |L5.322|
00005a  7070              STRB     r0,[r6,#1]            ;318
00005c  2009              MOVS     r0,#9                 ;321
00005e  7030              STRB     r0,[r6,#0]            ;321
000060  e06f              B        |L5.322|
000062  4629              MOV      r1,r5                 ;327
000064  9800              LDR      r0,[sp,#0]            ;327
000066  f7fffffe          BL       USBH_MSC_GETMaxLUN
00006a  4604              MOV      r4,r0                 ;327
00006c  2103              MOVS     r1,#3                 ;291
00006e  b93c              CBNZ     r4,|L5.128|
000070  f8990008          LDRB     r0,[r9,#8]            ;331  ; MSC_Machine
000074  f8890048          STRB     r0,[r9,#0x48]         ;331
000078  b108              CBZ      r0,|L5.126|
00007a  7878              LDRB     r0,[r7,#1]  ; maxLunExceed
00007c  b118              CBZ      r0,|L5.134|
                  |L5.126|
;;;335            {
;;;336              maxLunExceed = TRUE;
;;;337              pphost->usr_cb->DeviceNotSupported();
;;;338              
;;;339              break;
;;;340            }
;;;341            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_TEST_UNIT_READY;
00007e  7031              STRB     r1,[r6,#0]
                  |L5.128|
;;;342          }
;;;343          
;;;344          if(status == USBH_NOT_SUPPORTED )
000080  2c03              CMP      r4,#3
000082  d007              BEQ      |L5.148|
000084  e05d              B        |L5.322|
                  |L5.134|
000086  f887a001          STRB     r10,[r7,#1]           ;336
00008a  f8d50080          LDR      r0,[r5,#0x80]         ;337
00008e  6c00              LDR      r0,[r0,#0x40]         ;337
000090  4780              BLX      r0                    ;337
000092  e056              B        |L5.322|
                  |L5.148|
;;;345          {
;;;346                   /* If the Command has failed, then we need to move to Next State, after
;;;347            STALL condition is cleared by Control-Transfer */
;;;348            USBH_MSC_BOTXferParam.MSCStateBkp = USBH_MSC_TEST_UNIT_READY; 
000094  7071              STRB     r1,[r6,#1]
;;;349            
;;;350            /* a Clear Feature should be issued here */
;;;351            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_CTRL_ERROR_STATE;
000096  2009              MOVS     r0,#9
000098  7030              STRB     r0,[r6,#0]
00009a  e052              B        |L5.322|
;;;352          }    
;;;353          break;
;;;354          
;;;355        case USBH_MSC_CTRL_ERROR_STATE:
;;;356          /* Issue Clearfeature request */
;;;357          status = USBH_ClrFeature(pdev,
00009c  796b              LDRB     r3,[r5,#5]
00009e  2200              MOVS     r2,#0
0000a0  4629              MOV      r1,r5
0000a2  9800              LDR      r0,[sp,#0]
0000a4  f7fffffe          BL       USBH_ClrFeature
0000a8  4604              MOV      r4,r0
;;;358                                   phost,
;;;359                                   0x00,
;;;360                                   pphost->Control.hc_num_out);
;;;361          if(status == USBH_OK )
0000aa  bb24              CBNZ     r4,|L5.246|
;;;362          {
;;;363            /* If GetMaxLun Request not support, assume Single LUN configuration */
;;;364            MSC_Machine.maxLun = 0;  
0000ac  f8898048          STRB     r8,[r9,#0x48]
;;;365            
;;;366            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;     
0000b0  7870              LDRB     r0,[r6,#1]  ; USBH_MSC_BOTXferParam
0000b2  7030              STRB     r0,[r6,#0]
0000b4  e045              B        |L5.322|
;;;367          }
;;;368          break;  
;;;369          
;;;370        case USBH_MSC_TEST_UNIT_READY:
;;;371          /* Issue SCSI command TestUnitReady */ 
;;;372          mscStatus = USBH_MSC_TestUnitReady(pdev);
0000b6  9800              LDR      r0,[sp,#0]
0000b8  f7fffffe          BL       USBH_MSC_TestUnitReady
;;;373          
;;;374          if(mscStatus == USBH_MSC_OK )
0000bc  b110              CBZ      r0,|L5.196|
;;;375          {
;;;376            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_READ_CAPACITY10;
;;;377            MSCErrorCount = 0;
;;;378            status = USBH_OK;
;;;379          }
;;;380          else
;;;381          {
;;;382            USBH_MSC_ErrorHandle(mscStatus);
0000be  f7fffffe          BL       USBH_MSC_ErrorHandle
0000c2  e03e              B        |L5.322|
                  |L5.196|
0000c4  2004              MOVS     r0,#4                 ;376
0000c6  7030              STRB     r0,[r6,#0]            ;376
0000c8  f8878000          STRB     r8,[r7,#0]            ;377
0000cc  2400              MOVS     r4,#0                 ;378
0000ce  e038              B        |L5.322|
;;;383          } 
;;;384          break;
;;;385          
;;;386        case USBH_MSC_READ_CAPACITY10:
;;;387          /* Issue READ_CAPACITY10 SCSI command */
;;;388          mscStatus = USBH_MSC_ReadCapacity10(pdev);
0000d0  9800              LDR      r0,[sp,#0]
0000d2  f7fffffe          BL       USBH_MSC_ReadCapacity10
;;;389          if(mscStatus == USBH_MSC_OK )
0000d6  b110              CBZ      r0,|L5.222|
;;;390          {
;;;391            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_MODE_SENSE6;
;;;392            MSCErrorCount = 0;
;;;393            status = USBH_OK;
;;;394          }
;;;395          else
;;;396          {
;;;397            USBH_MSC_ErrorHandle(mscStatus);
0000d8  f7fffffe          BL       USBH_MSC_ErrorHandle
0000dc  e031              B        |L5.322|
                  |L5.222|
0000de  2005              MOVS     r0,#5                 ;391
0000e0  7030              STRB     r0,[r6,#0]            ;391
0000e2  f8878000          STRB     r8,[r7,#0]            ;392
0000e6  2400              MOVS     r4,#0                 ;393
0000e8  e02b              B        |L5.322|
;;;398          }
;;;399          break;
;;;400    
;;;401        case USBH_MSC_MODE_SENSE6:
;;;402          /* Issue ModeSense6 SCSI command for detecting if device is write-protected */
;;;403          mscStatus = USBH_MSC_ModeSense6(pdev);
0000ea  9800              LDR      r0,[sp,#0]
0000ec  f7fffffe          BL       USBH_MSC_ModeSense6
;;;404          if(mscStatus == USBH_MSC_OK )
0000f0  b110              CBZ      r0,|L5.248|
;;;405          {
;;;406            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
;;;407            MSCErrorCount = 0;
;;;408            status = USBH_OK;
;;;409          }
;;;410          else
;;;411          {
;;;412            USBH_MSC_ErrorHandle(mscStatus);
0000f2  f7fffffe          BL       USBH_MSC_ErrorHandle
                  |L5.246|
0000f6  e024              B        |L5.322|
                  |L5.248|
0000f8  f886b000          STRB     r11,[r6,#0]           ;406
0000fc  f8878000          STRB     r8,[r7,#0]            ;407
000100  2400              MOVS     r4,#0                 ;408
000102  e01e              B        |L5.322|
;;;413          }
;;;414          break;
;;;415          
;;;416        case USBH_MSC_REQUEST_SENSE:
;;;417          /* Issue RequestSense SCSI command for retreiving error code */
;;;418          mscStatus = USBH_MSC_RequestSense(pdev);
000104  9800              LDR      r0,[sp,#0]
000106  f7fffffe          BL       USBH_MSC_RequestSense
;;;419          if(mscStatus == USBH_MSC_OK )
00010a  b110              CBZ      r0,|L5.274|
;;;420          {
;;;421            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_BOTXferParam.MSCStateBkp;
;;;422            status = USBH_OK;
;;;423          }
;;;424          else
;;;425          {
;;;426            USBH_MSC_ErrorHandle(mscStatus);
00010c  f7fffffe          BL       USBH_MSC_ErrorHandle
000110  e017              B        |L5.322|
                  |L5.274|
000112  7870              LDRB     r0,[r6,#1]            ;421  ; USBH_MSC_BOTXferParam
000114  7030              STRB     r0,[r6,#0]            ;421
000116  2400              MOVS     r4,#0                 ;422
000118  e013              B        |L5.322|
;;;427          }  
;;;428          break;
;;;429          
;;;430        case USBH_MSC_BOT_USB_TRANSFERS:
;;;431          /* Process the BOT state machine */
;;;432          USBH_MSC_HandleBOTXfer(pdev , phost);
00011a  4629              MOV      r1,r5
00011c  9800              LDR      r0,[sp,#0]
00011e  f7fffffe          BL       USBH_MSC_HandleBOTXfer
;;;433          break;
000122  e00e              B        |L5.322|
;;;434        
;;;435        case USBH_MSC_DEFAULT_APPLI_STATE:
;;;436          /* Process Application callback for MSC */
;;;437          appliStatus = pphost->usr_cb->UserApplication();
000124  f8d50080          LDR      r0,[r5,#0x80]
000128  6bc0              LDR      r0,[r0,#0x3c]
00012a  4780              BLX      r0
00012c  b2c0              UXTB     r0,r0
;;;438          if(appliStatus == 0)
00012e  b110              CBZ      r0,|L5.310|
;;;439          {
;;;440            USBH_MSC_BOTXferParam.MSCState = USBH_MSC_DEFAULT_APPLI_STATE;
;;;441          }
;;;442          else if (appliStatus == 1) 
000130  2801              CMP      r0,#1
000132  d003              BEQ      |L5.316|
000134  e005              B        |L5.322|
                  |L5.310|
000136  f886b000          STRB     r11,[r6,#0]           ;440
00013a  e002              B        |L5.322|
                  |L5.316|
;;;443          {
;;;444            /* De-init requested from application layer */
;;;445            status =  USBH_APPLY_DEINIT;
00013c  2406              MOVS     r4,#6
00013e  e000              B        |L5.322|
;;;446          }
;;;447          break;
;;;448          
;;;449        case USBH_MSC_UNRECOVERED_STATE:
;;;450          
;;;451          status = USBH_UNRECOVERED_ERROR;
000140  2404              MOVS     r4,#4
                  |L5.322|
;;;452          
;;;453          break;
;;;454          
;;;455        default:
;;;456          break; 
;;;457          
;;;458        }
;;;459      }
;;;460       return status;
000142  4620              MOV      r0,r4
;;;461    }
000144  e8bd9ffc          POP      {r2-r12,pc}
;;;462    
                          ENDP

                  |L5.328|
                          DCD      USBH_MSC_BOTXferParam
                  |L5.332|
                          DCD      ||.bss||
                  |L5.336|
                          DCD      ||.data||

                          AREA ||i.USBH_MSC_InterfaceDeInit||, CODE, READONLY, ALIGN=2

                  USBH_MSC_InterfaceDeInit PROC
;;;239      */
;;;240    void USBH_MSC_InterfaceDeInit ( USB_OTG_CORE_HANDLE *pdev,
000000  b570              PUSH     {r4-r6,lr}
;;;241                                    void *phost)
;;;242    {	
000002  4604              MOV      r4,r0
;;;243      if ( MSC_Machine.hc_num_out)
000004  4d0b              LDR      r5,|L6.52|
000006  2600              MOVS     r6,#0
000008  7869              LDRB     r1,[r5,#1]  ; MSC_Machine
00000a  b139              CBZ      r1,|L6.28|
;;;244      {
;;;245        USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_out);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       USB_OTG_HC_Halt
;;;246        USBH_Free_Channel  (pdev, MSC_Machine.hc_num_out);
000012  7869              LDRB     r1,[r5,#1]  ; MSC_Machine
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USBH_Free_Channel
;;;247        MSC_Machine.hc_num_out = 0;     /* Reset the Channel as Free */
00001a  706e              STRB     r6,[r5,#1]
                  |L6.28|
;;;248      }
;;;249       
;;;250      if ( MSC_Machine.hc_num_in)
00001c  7829              LDRB     r1,[r5,#0]  ; MSC_Machine
00001e  2900              CMP      r1,#0
000020  d007              BEQ      |L6.50|
;;;251      {
;;;252        USB_OTG_HC_Halt(pdev, MSC_Machine.hc_num_in);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USB_OTG_HC_Halt
;;;253        USBH_Free_Channel  (pdev, MSC_Machine.hc_num_in);
000028  7829              LDRB     r1,[r5,#0]  ; MSC_Machine
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USBH_Free_Channel
;;;254        MSC_Machine.hc_num_in = 0;     /* Reset the Channel as Free */
000030  702e              STRB     r6,[r5,#0]
                  |L6.50|
;;;255      } 
;;;256    }
000032  bd70              POP      {r4-r6,pc}
;;;257    
                          ENDP

                  |L6.52|
                          DCD      ||.bss||

                          AREA ||i.USBH_MSC_InterfaceInit||, CODE, READONLY, ALIGN=2

                  USBH_MSC_InterfaceInit PROC
;;;170      */
;;;171    static USBH_Status USBH_MSC_InterfaceInit ( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;172                                            void *phost)
;;;173    {	 
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;174      USBH_HOST *pphost = phost;
;;;175      
;;;176      if((pphost->device_prop.Itf_Desc[0].bInterfaceClass == MSC_CLASS) && \
000008  f8940043          LDRB     r0,[r4,#0x43]
00000c  2808              CMP      r0,#8
00000e  d103              BNE      |L7.24|
;;;177         (pphost->device_prop.Itf_Desc[0].bInterfaceProtocol == MSC_PROTOCOL))
000010  f8940045          LDRB     r0,[r4,#0x45]
000014  2850              CMP      r0,#0x50
000016  d006              BEQ      |L7.38|
                  |L7.24|
;;;178      {
;;;179        if(pphost->device_prop.Ep_Desc[0][0].bEndpointAddress & 0x80)
;;;180        {
;;;181          MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
;;;182          MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][0].wMaxPacketSize;
;;;183        }
;;;184        else
;;;185        {
;;;186          MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][0].bEndpointAddress);
;;;187          MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0] [0].wMaxPacketSize;      
;;;188        }
;;;189        
;;;190        if(pphost->device_prop.Ep_Desc[0][1].bEndpointAddress & 0x80)
;;;191        {
;;;192          MSC_Machine.MSBulkInEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
;;;193          MSC_Machine.MSBulkInEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
;;;194        }
;;;195        else
;;;196        {
;;;197          MSC_Machine.MSBulkOutEp = (pphost->device_prop.Ep_Desc[0][1].bEndpointAddress);
;;;198          MSC_Machine.MSBulkOutEpSize  = pphost->device_prop.Ep_Desc[0][1].wMaxPacketSize;      
;;;199        }
;;;200        
;;;201        MSC_Machine.hc_num_out = USBH_Alloc_Channel(pdev, 
;;;202                                                    MSC_Machine.MSBulkOutEp);
;;;203        MSC_Machine.hc_num_in = USBH_Alloc_Channel(pdev,
;;;204                                                    MSC_Machine.MSBulkInEp);  
;;;205        
;;;206        /* Open the new channels */
;;;207        USBH_Open_Channel  (pdev,
;;;208                            MSC_Machine.hc_num_out,
;;;209                            pphost->device_prop.address,
;;;210                            pphost->device_prop.speed,
;;;211                            EP_TYPE_BULK,
;;;212                            MSC_Machine.MSBulkOutEpSize);  
;;;213        
;;;214        USBH_Open_Channel  (pdev,
;;;215                            MSC_Machine.hc_num_in,
;;;216                            pphost->device_prop.address,
;;;217                            pphost->device_prop.speed,
;;;218                            EP_TYPE_BULK,
;;;219                            MSC_Machine.MSBulkInEpSize);    
;;;220        
;;;221      }
;;;222      
;;;223      else
;;;224      {
;;;225        pphost->usr_cb->DeviceNotSupported(); 
000018  f8d40080          LDR      r0,[r4,#0x80]
00001c  6c00              LDR      r0,[r0,#0x40]
00001e  4780              BLX      r0
                  |L7.32|
;;;226      }
;;;227      
;;;228      return USBH_OK ;
000020  2000              MOVS     r0,#0
;;;229     
;;;230    }
000022  e8bd81fc          POP      {r2-r8,pc}
                  |L7.38|
000026  f8940052          LDRB     r0,[r4,#0x52]         ;179
00002a  4e1c              LDR      r6,|L7.156|
00002c  0601              LSLS     r1,r0,#24             ;179
00002e  d504              BPL      |L7.58|
000030  70f0              STRB     r0,[r6,#3]            ;181
000032  f8b40054          LDRH     r0,[r4,#0x54]         ;182
000036  80b0              STRH     r0,[r6,#4]            ;182
000038  e003              B        |L7.66|
                  |L7.58|
00003a  70b0              STRB     r0,[r6,#2]            ;186
00003c  f8b40054          LDRH     r0,[r4,#0x54]         ;187
000040  80f0              STRH     r0,[r6,#6]            ;187
                  |L7.66|
000042  f894005a          LDRB     r0,[r4,#0x5a]         ;190
000046  0601              LSLS     r1,r0,#24             ;190
000048  d504              BPL      |L7.84|
00004a  70f0              STRB     r0,[r6,#3]            ;192
00004c  f8b4005c          LDRH     r0,[r4,#0x5c]         ;193
000050  80b0              STRH     r0,[r6,#4]            ;193
000052  e003              B        |L7.92|
                  |L7.84|
000054  70b0              STRB     r0,[r6,#2]            ;197
000056  f8b4005c          LDRH     r0,[r4,#0x5c]         ;198
00005a  80f0              STRH     r0,[r6,#6]            ;198
                  |L7.92|
00005c  78b1              LDRB     r1,[r6,#2]            ;201  ; MSC_Machine
00005e  4628              MOV      r0,r5                 ;201
000060  f7fffffe          BL       USBH_Alloc_Channel
000064  7070              STRB     r0,[r6,#1]            ;201
000066  78f1              LDRB     r1,[r6,#3]            ;203  ; MSC_Machine
000068  4628              MOV      r0,r5                 ;203
00006a  f7fffffe          BL       USBH_Alloc_Channel
00006e  7030              STRB     r0,[r6,#0]            ;203
000070  88f0              LDRH     r0,[r6,#6]            ;207  ; MSC_Machine
000072  2702              MOVS     r7,#2                 ;207
000074  e9cd7000          STRD     r7,r0,[sp,#0]         ;207
000078  f1040420          ADD      r4,r4,#0x20           ;207
00007c  7871              LDRB     r1,[r6,#1]            ;207  ; MSC_Machine
00007e  7863              LDRB     r3,[r4,#1]            ;207
000080  7822              LDRB     r2,[r4,#0]            ;207
000082  4628              MOV      r0,r5                 ;207
000084  f7fffffe          BL       USBH_Open_Channel
000088  88b0              LDRH     r0,[r6,#4]            ;214  ; MSC_Machine
00008a  e9cd7000          STRD     r7,r0,[sp,#0]         ;214
00008e  7863              LDRB     r3,[r4,#1]            ;214
000090  7822              LDRB     r2,[r4,#0]            ;214
000092  7831              LDRB     r1,[r6,#0]            ;214  ; MSC_Machine
000094  4628              MOV      r0,r5                 ;214
000096  f7fffffe          BL       USBH_Open_Channel
00009a  e7c1              B        |L7.32|
;;;231    
                          ENDP

                  |L7.156|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MSC_Machine
                          %        74

                          AREA ||.data||, DATA, ALIGN=0

                  MSCErrorCount
000000  00                DCB      0x00
                  maxLunExceed
000001  00                DCB      0x00

                          AREA ||area_number.12||, DATA, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.data||
                  USBH_MSC_cb
                          DCD      USBH_MSC_InterfaceInit
                          DCD      USBH_MSC_InterfaceDeInit
                          DCD      USBH_MSC_ClassRequest
                          DCD      USBH_MSC_Handle

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  MSC_Setup
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Class\\MSC\\src\\usbh_msc_core.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_usbh_msc_core_c_0007fda2____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_usbh_msc_core_c_0007fda2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_usbh_msc_core_c_0007fda2____REVSH|
#line 128
|__asm___15_usbh_msc_core_c_0007fda2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
