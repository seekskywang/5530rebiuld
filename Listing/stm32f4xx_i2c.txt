; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_i2c.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_i2c.crf ..\Libraries\FWlib\src\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;717      */
;;;718    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L1.12|
;;;719    {
;;;720      /* Check the parameters */
;;;721      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;722      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;723      if (NewState != DISABLE)
;;;724      {
;;;725        /* Enable the selected I2C ARP */
;;;726        I2Cx->CR1 |= I2C_CR1_ENARP;
000002  8801              LDRH     r1,[r0,#0]
000004  f0410110          ORR      r1,r1,#0x10
000008  8001              STRH     r1,[r0,#0]
;;;727      }
;;;728      else
;;;729      {
;;;730        /* Disable the selected I2C ARP */
;;;731        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
;;;732      }
;;;733    }
00000a  4770              BX       lr
                  |L1.12|
00000c  8801              LDRH     r1,[r0,#0]            ;731
00000e  f0210110          BIC      r1,r1,#0x10           ;731
000012  8001              STRH     r1,[r0,#0]            ;731
000014  4770              BX       lr
;;;734    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;477      */
;;;478    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable the acknowledgement */
;;;486        I2Cx->CR1 |= I2C_CR1_ACK;
000002  8801              LDRH     r1,[r0,#0]
000004  f4416180          ORR      r1,r1,#0x400
000008  8001              STRH     r1,[r0,#0]
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable the acknowledgement */
;;;491        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
;;;492      }
;;;493    }
00000a  4770              BX       lr
                  |L2.12|
00000c  8801              LDRH     r1,[r0,#0]            ;491
00000e  f4216180          BIC      r1,r1,#0x400          ;491
000012  8001              STRH     r1,[r0,#0]            ;491
000014  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_AnalogFilterCmd||, CODE, READONLY, ALIGN=1

                  I2C_AnalogFilterCmd PROC
;;;341      */
;;;342    void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;346      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;347      if (NewState != DISABLE)
;;;348      {
;;;349        /* Enable the analog filter */
;;;350        I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
000002  8c81              LDRH     r1,[r0,#0x24]
000004  f0210110          BIC      r1,r1,#0x10
000008  8481              STRH     r1,[r0,#0x24]
;;;351      }
;;;352      else
;;;353      {
;;;354        /* Disable the analog filter */
;;;355        I2Cx->FLTR |= I2C_FLTR_ANOFF;
;;;356      }
;;;357    }
00000a  4770              BX       lr
                  |L3.12|
00000c  8c81              LDRH     r1,[r0,#0x24]         ;355
00000e  f0410110          ORR      r1,r1,#0x10           ;355
000012  8481              STRH     r1,[r0,#0x24]         ;355
000014  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;854      */
;;;855    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860      if (NewState != DISABLE)
;;;861      {
;;;862        /* Enable the selected I2C PEC calculation */
;;;863        I2Cx->CR1 |= I2C_CR1_ENPEC;
000002  8801              LDRH     r1,[r0,#0]
000004  f0410120          ORR      r1,r1,#0x20
000008  8001              STRH     r1,[r0,#0]
;;;864      }
;;;865      else
;;;866      {
;;;867        /* Disable the selected I2C PEC calculation */
;;;868        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
;;;869      }
;;;870    }
00000a  4770              BX       lr
                  |L4.12|
00000c  8801              LDRH     r1,[r0,#0]            ;868
00000e  f0210120          BIC      r1,r1,#0x20           ;868
000012  8001              STRH     r1,[r0,#0]            ;868
000014  4770              BX       lr
;;;871    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1157     */
;;;1158   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  4603              MOV      r3,r0
;;;1159   {
;;;1160     uint32_t lastevent = 0;
;;;1161     uint32_t flag1 = 0, flag2 = 0;
;;;1162     ErrorStatus status = ERROR;
000002  2000              MOVS     r0,#0
;;;1163   
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1166     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1167   
;;;1168     /* Read the I2Cx status register */
;;;1169     flag1 = I2Cx->SR1;
000004  8a9a              LDRH     r2,[r3,#0x14]
;;;1170     flag2 = I2Cx->SR2;
000006  8b1b              LDRH     r3,[r3,#0x18]
;;;1171     flag2 = flag2 << 16;
000008  041b              LSLS     r3,r3,#16
;;;1172   
;;;1173     /* Get the last event value from I2C status register */
;;;1174     lastevent = (flag1 | flag2) & FLAG_MASK;
00000a  431a              ORRS     r2,r2,r3
00000c  f022427f          BIC      r2,r2,#0xff000000
;;;1175   
;;;1176     /* Check whether the last event contains the I2C_EVENT */
;;;1177     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000010  4391              BICS     r1,r1,r2
000012  d100              BNE      |L5.22|
;;;1178     {
;;;1179       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1180       status = SUCCESS;
000014  2001              MOVS     r0,#1
                  |L5.22|
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       /* ERROR: last event is different from I2C_EVENT */
;;;1185       status = ERROR;
;;;1186     }
;;;1187     /* Return status */
;;;1188     return status;
;;;1189   }
000016  4770              BX       lr
;;;1190   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1337     */
;;;1338   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1339   {
;;;1340     uint32_t flagpos = 0;
;;;1341     /* Check the parameters */
;;;1342     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1343     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1344     /* Get the I2C flag position */
;;;1345     flagpos = I2C_FLAG & FLAG_MASK;
;;;1346     /* Clear the selected I2C flag */
;;;1347     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1348   }
000004  4770              BX       lr
;;;1349   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1431     */
;;;1432   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1433   {
;;;1434     uint32_t flagpos = 0;
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1437     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1438   
;;;1439     /* Get the I2C flag position */
;;;1440     flagpos = I2C_IT & FLAG_MASK;
;;;1441   
;;;1442     /* Clear the selected I2C flag */
;;;1443     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1444   }
000004  4770              BX       lr
;;;1445   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;312      */
;;;313    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      if (NewState != DISABLE)
;;;319      {
;;;320        /* Enable the selected I2C peripheral */
;;;321        I2Cx->CR1 |= I2C_CR1_PE;
000002  8801              LDRH     r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  8001              STRH     r1,[r0,#0]
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the selected I2C peripheral */
;;;326        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
;;;327      }
;;;328    }
00000a  4770              BX       lr
                  |L8.12|
00000c  8801              LDRH     r1,[r0,#0]            ;326
00000e  f0210101          BIC      r1,r1,#1              ;326
000012  8001              STRH     r1,[r0,#0]            ;326
000014  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;909      */
;;;910    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L9.12|
;;;911    {
;;;912      /* Check the parameters */
;;;913      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;914      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;915      if (NewState != DISABLE)
;;;916      {
;;;917        /* Enable the selected I2C DMA requests */
;;;918        I2Cx->CR2 |= I2C_CR2_DMAEN;
000002  8881              LDRH     r1,[r0,#4]
000004  f4416100          ORR      r1,r1,#0x800
000008  8081              STRH     r1,[r0,#4]
;;;919      }
;;;920      else
;;;921      {
;;;922        /* Disable the selected I2C DMA requests */
;;;923        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
;;;924      }
;;;925    }
00000a  4770              BX       lr
                  |L9.12|
00000c  8881              LDRH     r1,[r0,#4]            ;923
00000e  f4216100          BIC      r1,r1,#0x800          ;923
000012  8081              STRH     r1,[r0,#4]            ;923
000014  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;933      */
;;;934    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;935    {
;;;936      /* Check the parameters */
;;;937      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939      if (NewState != DISABLE)
;;;940      {
;;;941        /* Next DMA transfer is the last transfer */
;;;942        I2Cx->CR2 |= I2C_CR2_LAST;
000002  8881              LDRH     r1,[r0,#4]
000004  f4415180          ORR      r1,r1,#0x1000
000008  8081              STRH     r1,[r0,#4]
;;;943      }
;;;944      else
;;;945      {
;;;946        /* Next DMA transfer is not the last transfer */
;;;947        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
;;;948      }
;;;949    }
00000a  4770              BX       lr
                  |L10.12|
00000c  8881              LDRH     r1,[r0,#4]            ;947
00000e  f4215180          BIC      r1,r1,#0x1000         ;947
000012  8081              STRH     r1,[r0,#4]            ;947
000014  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;136      */
;;;137    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139      /* Check the parameters */
;;;140      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;141    
;;;142      if (I2Cx == I2C1)
000002  4915              LDR      r1,|L11.88|
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L11.30|
;;;143      {
;;;144        /* Enable I2C1 reset state */
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  054c              LSLS     r4,r1,#21
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;146        /* Release I2C1 from reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.30|
;;;148      }
;;;149      else if (I2Cx == I2C2)
00001e  490f              LDR      r1,|L11.92|
000020  4288              CMP      r0,r1
000022  d10a              BNE      |L11.58|
;;;150      {
;;;151        /* Enable I2C2 reset state */
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000024  2101              MOVS     r1,#1
000026  058c              LSLS     r4,r1,#22
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;153        /* Release I2C2 from reset state */
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
00002e  4620              MOV      r0,r4
000030  e8bd4010          POP      {r4,lr}
000034  2100              MOVS     r1,#0
000036  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.58|
;;;155      }
;;;156      else 
;;;157      {
;;;158        if (I2Cx == I2C3)
00003a  4909              LDR      r1,|L11.96|
00003c  4288              CMP      r0,r1
00003e  d10a              BNE      |L11.86|
;;;159        {
;;;160          /* Enable I2C3 reset state */
;;;161          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
000040  2101              MOVS     r1,#1
000042  05cc              LSLS     r4,r1,#23
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;162          /* Release I2C3 from reset state */
;;;163          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
00004a  4620              MOV      r0,r4
00004c  e8bd4010          POP      {r4,lr}
000050  2100              MOVS     r1,#0
000052  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.86|
;;;164        }
;;;165      }
;;;166    }
000056  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L11.88|
                          DCD      0x40005400
                  |L11.92|
                          DCD      0x40005800
                  |L11.96|
                          DCD      0x40005c00

                          AREA ||i.I2C_DigitalFilterConfig||, CODE, READONLY, ALIGN=1

                  I2C_DigitalFilterConfig PROC
;;;370      */
;;;371    void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
000000  8c82              LDRH     r2,[r0,#0x24]
;;;372    {
;;;373      uint16_t tmpreg = 0;
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;377      assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
;;;378      
;;;379      /* Get the old register value */
;;;380      tmpreg = I2Cx->FLTR;
;;;381      
;;;382      /* Reset I2Cx DNF bit [3:0] */
;;;383      tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
000002  f022020f          BIC      r2,r2,#0xf
;;;384      
;;;385      /* Set I2Cx DNF coefficient */
;;;386      tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
000006  f001010f          AND      r1,r1,#0xf
00000a  4311              ORRS     r1,r1,r2
;;;387      
;;;388      /* Store the new register value */
;;;389      I2Cx->FLTR = tmpreg;
00000c  8481              STRH     r1,[r0,#0x24]
;;;390    }
00000e  4770              BX       lr
;;;391    
                          ENDP


                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;527      */
;;;528    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;529    {
;;;530      /* Check the parameters */
;;;531      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;532      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;533      if (NewState != DISABLE)
;;;534      {
;;;535        /* Enable dual addressing mode */
;;;536        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
000002  8981              LDRH     r1,[r0,#0xc]
000004  f0410101          ORR      r1,r1,#1
000008  8181              STRH     r1,[r0,#0xc]
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable dual addressing mode */
;;;541        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
;;;542      }
;;;543    }
00000a  4770              BX       lr
                  |L13.12|
00000c  8981              LDRH     r1,[r0,#0xc]          ;541
00000e  f0210101          BIC      r1,r1,#1              ;541
000012  8181              STRH     r1,[r0,#0xc]          ;541
000014  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;627      */
;;;628    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;629    {
;;;630      /* Check the parameters */
;;;631      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;632      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;633      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000004  d004              BEQ      |L14.16|
;;;634      {
;;;635        /* I2C fast mode Tlow/Thigh=2 */
;;;636        I2Cx->CCR &= I2C_DutyCycle_2;
000006  8b81              LDRH     r1,[r0,#0x1c]
000008  f4214180          BIC      r1,r1,#0x4000
00000c  8381              STRH     r1,[r0,#0x1c]
;;;637      }
;;;638      else
;;;639      {
;;;640        /* I2C fast mode Tlow/Thigh=16/9 */
;;;641        I2Cx->CCR |= I2C_DutyCycle_16_9;
;;;642      }
;;;643    }
00000e  4770              BX       lr
                  |L14.16|
000010  8b81              LDRH     r1,[r0,#0x1c]         ;641
000012  f4414180          ORR      r1,r1,#0x4000         ;641
000016  8381              STRH     r1,[r0,#0x1c]         ;641
000018  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;551      */
;;;552    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L15.12|
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;556      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;557      if (NewState != DISABLE)
;;;558      {
;;;559        /* Enable generall call */
;;;560        I2Cx->CR1 |= I2C_CR1_ENGC;
000002  8801              LDRH     r1,[r0,#0]
000004  f0410140          ORR      r1,r1,#0x40
000008  8001              STRH     r1,[r0,#0]
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Disable generall call */
;;;565        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
;;;566      }
;;;567    }
00000a  4770              BX       lr
                  |L15.12|
00000c  8801              LDRH     r1,[r0,#0]            ;565
00000e  f0210140          BIC      r1,r1,#0x40           ;565
000012  8001              STRH     r1,[r0,#0]            ;565
000014  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;398      */
;;;399    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a START condition */
;;;407        I2Cx->CR1 |= I2C_CR1_START;
000002  8801              LDRH     r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  8001              STRH     r1,[r0,#0]
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the START condition generation */
;;;412        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
;;;413      }
;;;414    }
00000a  4770              BX       lr
                  |L16.12|
00000c  8801              LDRH     r1,[r0,#0]            ;412
00000e  f4217180          BIC      r1,r1,#0x100          ;412
000012  8001              STRH     r1,[r0,#0]            ;412
000014  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;422      */
;;;423    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;427      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;428      if (NewState != DISABLE)
;;;429      {
;;;430        /* Generate a STOP condition */
;;;431        I2Cx->CR1 |= I2C_CR1_STOP;
000002  8801              LDRH     r1,[r0,#0]
000004  f4417100          ORR      r1,r1,#0x200
000008  8001              STRH     r1,[r0,#0]
;;;432      }
;;;433      else
;;;434      {
;;;435        /* Disable the STOP condition generation */
;;;436        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
;;;437      }
;;;438    }
00000a  4770              BX       lr
                  |L17.12|
00000c  8801              LDRH     r1,[r0,#0]            ;436
00000e  f4217100          BIC      r1,r1,#0x200          ;436
000012  8001              STRH     r1,[r0,#0]            ;436
000014  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1260     */
;;;1261   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  2200              MOVS     r2,#0
;;;1262   {
;;;1263     FlagStatus bitstatus = RESET;
;;;1264     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1268     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1269   
;;;1270     /* Get the I2Cx peripheral base address */
;;;1271     i2cxbase = (uint32_t)I2Cx;
;;;1272     
;;;1273     /* Read flag register index */
;;;1274     i2creg = I2C_FLAG >> 28;
000002  0f0b              LSRS     r3,r1,#28
;;;1275     
;;;1276     /* Get bit[23:0] of the flag */
;;;1277     I2C_FLAG &= FLAG_MASK;
000004  f021417f          BIC      r1,r1,#0xff000000
;;;1278     
;;;1279     if(i2creg != 0)
000008  b10b              CBZ      r3,|L18.14|
;;;1280     {
;;;1281       /* Get the I2Cx SR1 register address */
;;;1282       i2cxbase += 0x14;
00000a  3014              ADDS     r0,r0,#0x14
00000c  e001              B        |L18.18|
                  |L18.14|
;;;1283     }
;;;1284     else
;;;1285     {
;;;1286       /* Flag in I2Cx SR2 Register */
;;;1287       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
00000e  0c09              LSRS     r1,r1,#16
;;;1288       /* Get the I2Cx SR2 register address */
;;;1289       i2cxbase += 0x18;
000010  3018              ADDS     r0,r0,#0x18
                  |L18.18|
;;;1290     }
;;;1291     
;;;1292     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
000012  6800              LDR      r0,[r0,#0]
000014  4208              TST      r0,r1
000016  d000              BEQ      |L18.26|
;;;1293     {
;;;1294       /* I2C_FLAG is set */
;;;1295       bitstatus = SET;
000018  2201              MOVS     r2,#1
                  |L18.26|
;;;1296     }
;;;1297     else
;;;1298     {
;;;1299       /* I2C_FLAG is reset */
;;;1300       bitstatus = RESET;
;;;1301     }
;;;1302     
;;;1303     /* Return the I2C_FLAG status */
;;;1304     return  bitstatus;
00001a  4610              MOV      r0,r2
;;;1305   }
00001c  4770              BX       lr
;;;1306   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1371     */
;;;1372   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b510              PUSH     {r4,lr}
;;;1373   {
000002  4602              MOV      r2,r0
;;;1374     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1375     uint32_t enablestatus = 0;
;;;1376   
;;;1377     /* Check the parameters */
;;;1378     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1379     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1380   
;;;1381     /* Check if the interrupt source is enabled or not */
;;;1382     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000006  8893              LDRH     r3,[r2,#4]
000008  f00164e0          AND      r4,r1,#0x7000000
00000c  ea034314          AND      r3,r3,r4,LSR #16
;;;1383     
;;;1384     /* Get bit[23:0] of the flag */
;;;1385     I2C_IT &= FLAG_MASK;
000010  f021417f          BIC      r1,r1,#0xff000000
;;;1386   
;;;1387     /* Check the status of the specified I2C flag */
;;;1388     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
000014  8a92              LDRH     r2,[r2,#0x14]
000016  420a              TST      r2,r1
000018  d002              BEQ      |L19.32|
00001a  2b00              CMP      r3,#0
00001c  d000              BEQ      |L19.32|
;;;1389     {
;;;1390       /* I2C_IT is set */
;;;1391       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L19.32|
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* I2C_IT is reset */
;;;1396       bitstatus = RESET;
;;;1397     }
;;;1398     /* Return the I2C_IT status */
;;;1399     return  bitstatus;
;;;1400   }
000020  bd10              POP      {r4,pc}
;;;1401   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1205     */
;;;1206   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1207   {
;;;1208     uint32_t lastevent = 0;
;;;1209     uint32_t flag1 = 0, flag2 = 0;
;;;1210   
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1213   
;;;1214     /* Read the I2Cx status register */
;;;1215     flag1 = I2Cx->SR1;
;;;1216     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1217     flag2 = flag2 << 16;
000004  0400              LSLS     r0,r0,#16
;;;1218   
;;;1219     /* Get the last event value from I2C status register */
;;;1220     lastevent = (flag1 | flag2) & FLAG_MASK;
000006  4301              ORRS     r1,r1,r0
000008  f021407f          BIC      r0,r1,#0xff000000
;;;1221   
;;;1222     /* Return status */
;;;1223     return lastevent;
;;;1224   }
00000c  4770              BX       lr
;;;1225   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;876      */
;;;877    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;878    {
;;;879      /* Check the parameters */
;;;880      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;881      /* Return the selected I2C PEC value */
;;;882      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;883    }
000004  4770              BX       lr
;;;884    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1098     */
;;;1099   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L22.10|
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1103     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1104     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1105     
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the selected I2C interrupts */
;;;1109       I2Cx->CR2 |= I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  430a              ORRS     r2,r2,r1
000006  8082              STRH     r2,[r0,#4]
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected I2C interrupts */
;;;1114       I2Cx->CR2 &= (uint16_t)~I2C_IT;
;;;1115     }
;;;1116   }
000008  4770              BX       lr
                  |L22.10|
00000a  8882              LDRH     r2,[r0,#4]            ;1114
00000c  438a              BICS     r2,r2,r1              ;1114
00000e  8082              STRH     r2,[r0,#4]            ;1114
000010  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;179      */
;;;180    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;181    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;182      uint16_t tmpreg = 0, freqrange = 0;
;;;183      uint16_t result = 0x04;
;;;184      uint32_t pclk1 = 8000000;
;;;185      RCC_ClocksTypeDef  rcc_clocks;
;;;186      /* Check the parameters */
;;;187      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;188      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;189      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;190      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;191      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;192      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;193      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;194    
;;;195    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;196      /* Get the I2Cx CR2 value */
;;;197      tmpreg = I2Cx->CR2;
000006  88a0              LDRH     r0,[r4,#4]
;;;198      /* Clear frequency FREQ[5:0] bits */
;;;199      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
000008  f020063f          BIC      r6,r0,#0x3f
;;;200      /* Get pclk1 frequency value */
;;;201      RCC_GetClocksFreq(&rcc_clocks);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       RCC_GetClocksFreq
;;;202      pclk1 = rcc_clocks.PCLK1_Frequency;
000012  9802              LDR      r0,[sp,#8]
;;;203      /* Set frequency bits depending on pclk1 value */
;;;204      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4926              LDR      r1,|L23.176|
000016  fbb0f1f1          UDIV     r1,r0,r1
00001a  b289              UXTH     r1,r1
;;;205      tmpreg |= freqrange;
00001c  430e              ORRS     r6,r6,r1
;;;206      /* Write to I2Cx CR2 */
;;;207      I2Cx->CR2 = tmpreg;
00001e  80a6              STRH     r6,[r4,#4]
;;;208    
;;;209    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;210      /* Disable the selected I2C peripheral to configure TRISE */
;;;211      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000020  8822              LDRH     r2,[r4,#0]
000022  f0220201          BIC      r2,r2,#1
000026  8022              STRH     r2,[r4,#0]
;;;212      /* Reset tmpreg value */
;;;213      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;214      tmpreg = 0;
;;;215    
;;;216      /* Configure speed in standard mode */
;;;217      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000028  4b22              LDR      r3,|L23.180|
00002a  682a              LDR      r2,[r5,#0]
00002c  429a              CMP      r2,r3
00002e  d809              BHI      |L23.68|
;;;218      {
;;;219        /* Standard mode speed calculate */
;;;220        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000030  0052              LSLS     r2,r2,#1
000032  fbb0f0f2          UDIV     r0,r0,r2
000036  b280              UXTH     r0,r0
;;;221        /* Test if CCR value is under 0x4*/
;;;222        if (result < 0x04)
000038  2804              CMP      r0,#4
00003a  d200              BCS      |L23.62|
;;;223        {
;;;224          /* Set minimum allowed value */
;;;225          result = 0x04;  
00003c  2004              MOVS     r0,#4
                  |L23.62|
;;;226        }
;;;227        /* Set speed value for standard mode */
;;;228        tmpreg |= result;	  
;;;229        /* Set Maximum Rise Time for standard mode */
;;;230        I2Cx->TRISE = freqrange + 1; 
00003e  1c49              ADDS     r1,r1,#1
000040  8421              STRH     r1,[r4,#0x20]
000042  e022              B        |L23.138|
                  |L23.68|
;;;231      }
;;;232      /* Configure speed in fast mode */
;;;233      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;234         input clock) must be a multiple of 10 MHz */
;;;235      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;236      {
;;;237        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000044  88eb              LDRH     r3,[r5,#6]
000046  f5a3463f          SUB      r6,r3,#0xbf00
00004a  3eff              SUBS     r6,r6,#0xff
00004c  d105              BNE      |L23.90|
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
00004e  eb020242          ADD      r2,r2,r2,LSL #1
000052  fbb0f0f2          UDIV     r0,r0,r2
000056  b280              UXTH     r0,r0
000058  e008              B        |L23.108|
                  |L23.90|
;;;241        }
;;;242        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;243        {
;;;244          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;245          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
00005a  eb0203c2          ADD      r3,r2,r2,LSL #3
00005e  eb031202          ADD      r2,r3,r2,LSL #4
000062  fbb0f0f2          UDIV     r0,r0,r2
000066  b280              UXTH     r0,r0
;;;246          /* Set DUTY bit */
;;;247          result |= I2C_DutyCycle_16_9;
000068  f4404080          ORR      r0,r0,#0x4000
                  |L23.108|
;;;248        }
;;;249    
;;;250        /* Test if CCR value is under 0x1*/
;;;251        if ((result & I2C_CCR_CCR) == 0)
00006c  0502              LSLS     r2,r0,#20
00006e  d101              BNE      |L23.116|
;;;252        {
;;;253          /* Set minimum allowed value */
;;;254          result |= (uint16_t)0x0001;  
000070  f0400001          ORR      r0,r0,#1
                  |L23.116|
;;;255        }
;;;256        /* Set speed value and set F/S bit for fast mode */
;;;257        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
000074  f4404000          ORR      r0,r0,#0x8000
;;;258        /* Set Maximum Rise Time for fast mode */
;;;259        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
000078  f44f7296          MOV      r2,#0x12c
00007c  4351              MULS     r1,r2,r1
00007e  f44f727a          MOV      r2,#0x3e8
000082  fbb1f1f2          UDIV     r1,r1,r2
000086  1c49              ADDS     r1,r1,#1
000088  8421              STRH     r1,[r4,#0x20]
                  |L23.138|
;;;260      }
;;;261    
;;;262      /* Write to I2Cx CCR */
;;;263      I2Cx->CCR = tmpreg;
00008a  83a0              STRH     r0,[r4,#0x1c]
;;;264      /* Enable the selected I2C peripheral */
;;;265      I2Cx->CR1 |= I2C_CR1_PE;
00008c  8820              LDRH     r0,[r4,#0]
00008e  f0400001          ORR      r0,r0,#1
000092  8020              STRH     r0,[r4,#0]
;;;266    
;;;267    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;268      /* Get the I2Cx CR1 value */
;;;269      tmpreg = I2Cx->CR1;
000094  8820              LDRH     r0,[r4,#0]
;;;270      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;271      tmpreg &= CR1_CLEAR_MASK;
000096  f64f31f5          MOV      r1,#0xfbf5
00009a  4008              ANDS     r0,r0,r1
;;;272      /* Configure I2Cx: mode and acknowledgement */
;;;273      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;274      /* Set ACK bit according to I2C_Ack value */
;;;275      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
00009c  88a9              LDRH     r1,[r5,#4]
00009e  896a              LDRH     r2,[r5,#0xa]
0000a0  4311              ORRS     r1,r1,r2
0000a2  4301              ORRS     r1,r1,r0
;;;276      /* Write to I2Cx CR1 */
;;;277      I2Cx->CR1 = tmpreg;
0000a4  8021              STRH     r1,[r4,#0]
;;;278    
;;;279    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;280      /* Set I2Cx Own Address1 and acknowledged address */
;;;281      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000a6  89a8              LDRH     r0,[r5,#0xc]
0000a8  8929              LDRH     r1,[r5,#8]
0000aa  4308              ORRS     r0,r0,r1
0000ac  8120              STRH     r0,[r4,#8]
;;;282    }
0000ae  bd7f              POP      {r0-r6,pc}
;;;283    
                          ENDP

                  |L23.176|
                          DCD      0x000f4240
                  |L23.180|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;665      */
;;;666    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;667    {
;;;668      /* Check the parameters */
;;;669      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;670      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;671      
;;;672      /* Check the input parameter */
;;;673      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000004  d004              BEQ      |L24.16|
;;;674      {
;;;675        /* Next byte in shift register is the last received byte */
;;;676        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Current byte in shift register is the last received byte */
;;;681        I2Cx->CR1 &= I2C_NACKPosition_Current;
000006  8801              LDRH     r1,[r0,#0]
000008  f4216100          BIC      r1,r1,#0x800
00000c  8001              STRH     r1,[r0,#0]
;;;682      }
;;;683    }
00000e  4770              BX       lr
                  |L24.16|
000010  8801              LDRH     r1,[r0,#0]            ;676
000012  f4416100          ORR      r1,r1,#0x800          ;676
000016  8001              STRH     r1,[r0,#0]            ;676
000018  4770              BX       lr
;;;684    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;500      */
;;;501    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;502    {
;;;503      uint16_t tmpreg = 0;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;507    
;;;508      /* Get the old register value */
;;;509      tmpreg = I2Cx->OAR2;
;;;510    
;;;511      /* Reset I2Cx Own address2 bit [7:1] */
;;;512      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
000002  f02202fe          BIC      r2,r2,#0xfe
;;;513    
;;;514      /* Set I2Cx Own address2 */
;;;515      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000006  f00101fe          AND      r1,r1,#0xfe
00000a  4311              ORRS     r1,r1,r2
;;;516    
;;;517      /* Store the new register value */
;;;518      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;519    }
00000e  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;830      */
;;;831    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;836      if (I2C_PECPosition == I2C_PECPosition_Next)
000004  d004              BEQ      |L26.16|
;;;837      {
;;;838        /* Next byte in shift register is PEC */
;;;839        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Current byte in shift register is PEC */
;;;844        I2Cx->CR1 &= I2C_PECPosition_Current;
000006  8801              LDRH     r1,[r0,#0]
000008  f4216100          BIC      r1,r1,#0x800
00000c  8001              STRH     r1,[r0,#0]
;;;845      }
;;;846    }
00000e  4770              BX       lr
                  |L26.16|
000010  8801              LDRH     r1,[r0,#0]            ;839
000012  f4416100          ORR      r1,r1,#0x800          ;839
000016  8001              STRH     r1,[r0,#0]            ;839
000018  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1071     */
;;;1072   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  4408              ADD      r0,r0,r1
;;;1073   {
;;;1074     __IO uint32_t tmp = 0;
;;;1075   
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1078     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1079   
;;;1080     tmp = (uint32_t) I2Cx;
;;;1081     tmp += I2C_Register;
;;;1082   
;;;1083     /* Return the selected register value */
;;;1084     return (*(__IO uint16_t *) tmp);
000002  8800              LDRH     r0,[r0,#0]
;;;1085   }
000004  4770              BX       lr
;;;1086   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;768      */
;;;769    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;773      /* Return the data in the DR register */
;;;774      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;775    }
000004  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;693      */
;;;694    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;698      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;699      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000004  d004              BEQ      |L29.16|
;;;700      {
;;;701        /* Drive the SMBusAlert pin Low */
;;;702        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;703      }
;;;704      else
;;;705      {
;;;706        /* Drive the SMBusAlert pin High  */
;;;707        I2Cx->CR1 &= I2C_SMBusAlert_High;
000006  8801              LDRH     r1,[r0,#0]
000008  f4215100          BIC      r1,r1,#0x2000
00000c  8001              STRH     r1,[r0,#0]
;;;708      }
;;;709    }
00000e  4770              BX       lr
                  |L29.16|
000010  8801              LDRH     r1,[r0,#0]            ;702
000012  f4415100          ORR      r1,r1,#0x2000         ;702
000016  8001              STRH     r1,[r0,#0]            ;702
000018  4770              BX       lr
;;;710    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;450      */
;;;451    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  b112              CBZ      r2,|L30.8|
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;455      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;456      /* Test on the direction to set/reset the read/write bit */
;;;457      if (I2C_Direction != I2C_Direction_Transmitter)
;;;458      {
;;;459        /* Set the address bit0 for read */
;;;460        Address |= I2C_OAR1_ADD0;
000002  f0410101          ORR      r1,r1,#1
000006  e001              B        |L30.12|
                  |L30.8|
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Reset the address bit0 for write */
;;;465        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          AND      r1,r1,#0xfe
                  |L30.12|
;;;466      }
;;;467      /* Send the address */
;;;468      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;469    }
00000e  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;755      */
;;;756    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;757    {
;;;758      /* Check the parameters */
;;;759      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;760      /* Write in the DR register the data to be sent */
;;;761      I2Cx->DR = Data;
;;;762    }
000002  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;577      */
;;;578    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L32.12|
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;582      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;583      if (NewState != DISABLE)
;;;584      {
;;;585        /* Peripheral under reset */
;;;586        I2Cx->CR1 |= I2C_CR1_SWRST;
000002  8801              LDRH     r1,[r0,#0]
000004  f4414100          ORR      r1,r1,#0x8000
000008  8001              STRH     r1,[r0,#0]
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Peripheral not under reset */
;;;591        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
;;;592      }
;;;593    }
00000a  4770              BX       lr
                  |L32.12|
00000c  8801              LDRH     r1,[r0,#0]            ;591
00000e  f3c1010e          UBFX     r1,r1,#0,#15          ;591
000012  8001              STRH     r1,[r0,#0]            ;591
000014  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;601      */
;;;602    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L33.12|
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607      if (NewState == DISABLE)
;;;608      {
;;;609        /* Enable the selected I2C Clock stretching */
;;;610        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Disable the selected I2C Clock stretching */
;;;615        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  8801              LDRH     r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  8001              STRH     r1,[r0,#0]
;;;616      }
;;;617    }
00000a  4770              BX       lr
                  |L33.12|
00000c  8801              LDRH     r1,[r0,#0]            ;610
00000e  f0410180          ORR      r1,r1,#0x80           ;610
000012  8001              STRH     r1,[r0,#0]            ;610
000014  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;288      */
;;;289    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;290    {
;;;291    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;292      /* initialize the I2C_ClockSpeed member */
;;;293      I2C_InitStruct->I2C_ClockSpeed = 5000;
000004  6001              STR      r1,[r0,#0]
;;;294      /* Initialize the I2C_Mode member */
;;;295      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;296      /* Initialize the I2C_DutyCycle member */
;;;297      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;298      /* Initialize the I2C_OwnAddress1 member */
;;;299      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;300      /* Initialize the I2C_Ack member */
;;;301      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;302      /* Initialize the I2C_AcknowledgedAddress member */
;;;303      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;304    }
00001a  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;799      */
;;;800    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  b121              CBZ      r1,|L35.12|
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable the selected I2C PEC transmission */
;;;808        I2Cx->CR1 |= I2C_CR1_PEC;
000002  8801              LDRH     r1,[r0,#0]
000004  f4415180          ORR      r1,r1,#0x1000
000008  8001              STRH     r1,[r0,#0]
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected I2C PEC transmission */
;;;813        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
;;;814      }
;;;815    }
00000a  4770              BX       lr
                  |L35.12|
00000c  8801              LDRH     r1,[r0,#0]            ;813
00000e  f4215180          BIC      r1,r1,#0x1000         ;813
000012  8001              STRH     r1,[r0,#0]            ;813
000014  4770              BX       lr
;;;816    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 128
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
