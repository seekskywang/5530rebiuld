; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usbh_stdreq.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usbh_stdreq.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usbh_stdreq.crf ..\USB\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c]
                          THUMB

                          AREA ||i.USBH_ClrFeature||, CODE, READONLY, ALIGN=1

                  USBH_ClrFeature PROC
;;;327    */
;;;328    USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
000000  b430              PUSH     {r4,r5}
;;;329                                USBH_HOST *phost,
;;;330                                uint8_t ep_num, 
;;;331                                uint8_t hc_num) 
;;;332    {
;;;333      
;;;334      phost->Control.setup.b.bmRequestType = USB_H2D | 
000002  2402              MOVS     r4,#2
000004  750c              STRB     r4,[r1,#0x14]
;;;335                                             USB_REQ_RECIPIENT_ENDPOINT |
;;;336                                             USB_REQ_TYPE_STANDARD;
;;;337      
;;;338      phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
000006  2401              MOVS     r4,#1
000008  754c              STRB     r4,[r1,#0x15]
;;;339      phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
00000a  2400              MOVS     r4,#0
00000c  82cc              STRH     r4,[r1,#0x16]
;;;340      phost->Control.setup.b.wIndex.w = ep_num;
00000e  830a              STRH     r2,[r1,#0x18]
;;;341      phost->Control.setup.b.wLength.w = 0;           
000010  834c              STRH     r4,[r1,#0x1a]
;;;342      
;;;343      if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
000012  0615              LSLS     r5,r2,#24
;;;344      { /* EP Type is IN */
;;;345        pdev->host.hc[hc_num].toggle_in = 0; 
000014  eb001243          ADD      r2,r0,r3,LSL #5
000018  d502              BPL      |L1.32|
00001a  f88243c4          STRB     r4,[r2,#0x3c4]
00001e  e001              B        |L1.36|
                  |L1.32|
;;;346      }
;;;347      else
;;;348      {/* EP Type is OUT */
;;;349        pdev->host.hc[hc_num].toggle_out = 0; 
000020  f88243c5          STRB     r4,[r2,#0x3c5]
                  |L1.36|
;;;350      }
;;;351      
;;;352      return USBH_CtlReq(pdev, phost, 0 , 0 );   
000024  2300              MOVS     r3,#0
000026  bc30              POP      {r4,r5}
000028  461a              MOV      r2,r3
00002a  f7ffbffe          B.W      USBH_CtlReq
;;;353    }
;;;354    
                          ENDP


                          AREA ||i.USBH_GetDescriptor||, CODE, READONLY, ALIGN=1

                  USBH_GetDescriptor PROC
;;;227    */
;;;228    USBH_Status USBH_GetDescriptor(USB_OTG_CORE_HANDLE *pdev,
000000  b430              PUSH     {r4,r5}
;;;229                                   USBH_HOST           *phost,                                
;;;230                                   uint8_t  req_type,
;;;231                                   uint16_t value_idx, 
;;;232                                   uint8_t* buff, 
;;;233                                   uint16_t length )
;;;234    { 
000002  e9dd4c02          LDRD     r4,r12,[sp,#8]
;;;235      phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
000006  f0420280          ORR      r2,r2,#0x80
00000a  750a              STRB     r2,[r1,#0x14]
;;;236      phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
00000c  2206              MOVS     r2,#6
00000e  754a              STRB     r2,[r1,#0x15]
;;;237      phost->Control.setup.b.wValue.w = value_idx;
000010  82cb              STRH     r3,[r1,#0x16]
;;;238      
;;;239      if ((value_idx & 0xff00) == USB_DESC_STRING)
000012  2203              MOVS     r2,#3
000014  ebb22f13          CMP      r2,r3,LSR #8
000018  d103              BNE      |L2.34|
;;;240      {
;;;241        phost->Control.setup.b.wIndex.w = 0x0409;
00001a  f2404209          MOV      r2,#0x409
00001e  830a              STRH     r2,[r1,#0x18]
000020  e001              B        |L2.38|
                  |L2.34|
;;;242      }
;;;243      else
;;;244      {
;;;245        phost->Control.setup.b.wIndex.w = 0;
000022  2200              MOVS     r2,#0
000024  830a              STRH     r2,[r1,#0x18]
                  |L2.38|
;;;246      }
;;;247      phost->Control.setup.b.wLength.w = length;           
000026  f8a1c01a          STRH     r12,[r1,#0x1a]
;;;248      return USBH_CtlReq(pdev, phost, buff , length );     
00002a  4622              MOV      r2,r4
00002c  bc30              POP      {r4,r5}
00002e  4663              MOV      r3,r12
000030  f7ffbffe          B.W      USBH_CtlReq
;;;249    }
;;;250    
                          ENDP


                          AREA ||i.USBH_GetNextDesc||, CODE, READONLY, ALIGN=1

                  USBH_GetNextDesc PROC
;;;575    */
;;;576    USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
000000  880a              LDRH     r2,[r1,#0]
;;;577    {
;;;578      USBH_DescHeader_t  *pnext;
;;;579     
;;;580      *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
000002  7803              LDRB     r3,[r0,#0]
000004  441a              ADD      r2,r2,r3
000006  800a              STRH     r2,[r1,#0]
;;;581      pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
000008  7801              LDRB     r1,[r0,#0]
00000a  4408              ADD      r0,r0,r1
;;;582             ((USBH_DescHeader_t *)pbuf)->bLength);
;;;583     
;;;584      return(pnext);
;;;585    }
00000c  4770              BX       lr
;;;586    
                          ENDP


                          AREA ||i.USBH_Get_CfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_Get_CfgDesc PROC
;;;152    */
;;;153    USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;154                                 USBH_HOST           *phost,                      
;;;155                                 uint16_t length)
;;;156    
;;;157    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;158      USBH_Status status;
;;;159      uint16_t index = 0;
00000a  2400              MOVS     r4,#0
;;;160      
;;;161      if((status = USBH_GetDescriptor(pdev,
00000c  f5077888          ADD      r8,r7,#0x110
000010  e9cd8500          STRD     r8,r5,[sp,#0]
000014  f44f7300          MOV      r3,#0x200
000018  2200              MOVS     r2,#0
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USBH_GetDescriptor
000022  ea5f0900          MOVS     r9,r0
000026  d113              BNE      |L4.80|
;;;162                                      phost,
;;;163                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;164                                      USB_DESC_CONFIGURATION, 
;;;165                                      pdev->host.Rx_Buffer,
;;;166                                      length)) == USBH_OK)
;;;167      {
;;;168        /*save Cfg descriptor for class parsing usage */
;;;169        for( ; index < length ; index ++)
;;;170        {
;;;171          USBH_CfgDesc[index] = pdev->host.Rx_Buffer[index];
000028  480b              LDR      r0,|L4.88|
00002a  e005              B        |L4.56|
                  |L4.44|
00002c  1939              ADDS     r1,r7,r4
00002e  f8911110          LDRB     r1,[r1,#0x110]
000032  5501              STRB     r1,[r0,r4]
000034  1c64              ADDS     r4,r4,#1              ;169
000036  b2a4              UXTH     r4,r4                 ;169
                  |L4.56|
000038  42ac              CMP      r4,r5                 ;169
00003a  d3f7              BCC      |L4.44|
;;;172        }
;;;173        
;;;174        /* Commands successfully sent and Response Received  */       
;;;175        USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
00003c  4643              MOV      r3,r8
00003e  f1060250          ADD      r2,r6,#0x50
000042  f106013e          ADD      r1,r6,#0x3e
000046  f1060034          ADD      r0,r6,#0x34
00004a  9500              STR      r5,[sp,#0]
00004c  f7fffffe          BL       USBH_ParseCfgDesc
                  |L4.80|
;;;176                           phost->device_prop.Itf_Desc,
;;;177                           phost->device_prop.Ep_Desc, 
;;;178                           pdev->host.Rx_Buffer,
;;;179                           length); 
;;;180        
;;;181      }
;;;182      return status;
000050  4648              MOV      r0,r9
;;;183    }
000052  e8bd87fc          POP      {r2-r10,pc}
;;;184    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      ||.bss||

                          AREA ||i.USBH_Get_DevDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_DevDesc PROC
;;;120    */
;;;121    USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;122                                 USBH_HOST *phost,
;;;123                                 uint8_t length)
;;;124    {
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
;;;125      
;;;126      USBH_Status status;
;;;127      
;;;128      if((status = USBH_GetDescriptor(pdev, 
000008  f5007488          ADD      r4,r0,#0x110
00000c  f44f7380          MOV      r3,#0x100
000010  2200              MOVS     r2,#0
000012  4639              MOV      r1,r7
000014  e9cd4500          STRD     r4,r5,[sp,#0]
000018  f7fffffe          BL       USBH_GetDescriptor
00001c  0006              MOVS     r6,r0
00001e  d105              BNE      |L5.44|
;;;129                                      phost,
;;;130                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;131                                      USB_DESC_DEVICE, 
;;;132                                      pdev->host.Rx_Buffer,
;;;133                                      length)) == USBH_OK)
;;;134      {
;;;135        /* Commands successfully sent and Response Received */       
;;;136        USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
000020  462a              MOV      r2,r5
000022  4621              MOV      r1,r4
000024  f1070022          ADD      r0,r7,#0x22
000028  f7fffffe          BL       USBH_ParseDevDesc
                  |L5.44|
;;;137      }
;;;138      return status;      
00002c  4630              MOV      r0,r6
;;;139    }
00002e  e8bd81fc          POP      {r2-r8,pc}
;;;140    
                          ENDP


                          AREA ||i.USBH_Get_StringDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_StringDesc PROC
;;;195    */
;;;196    USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;197                                    USBH_HOST *phost,
;;;198                                    uint8_t string_index, 
;;;199                                    uint8_t *buff, 
;;;200                                    uint16_t length)
;;;201    {
000004  461f              MOV      r7,r3
000006  9d08              LDR      r5,[sp,#0x20]
;;;202      USBH_Status status;
;;;203      
;;;204      if((status = USBH_GetDescriptor(pdev,
000008  f5007488          ADD      r4,r0,#0x110
00000c  f4427340          ORR      r3,r2,#0x300
000010  2200              MOVS     r2,#0
000012  e9cd4500          STRD     r4,r5,[sp,#0]
000016  f7fffffe          BL       USBH_GetDescriptor
00001a  0006              MOVS     r6,r0
00001c  d104              BNE      |L6.40|
;;;205                                      phost,
;;;206                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
;;;207                                      USB_DESC_STRING | string_index, 
;;;208                                      pdev->host.Rx_Buffer,
;;;209                                      length)) == USBH_OK)
;;;210      {
;;;211        /* Commands successfully sent and Response Received  */       
;;;212        USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
00001e  462a              MOV      r2,r5
000020  4639              MOV      r1,r7
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USBH_ParseStringDesc
                  |L6.40|
;;;213      }
;;;214      return status;
000028  4630              MOV      r0,r6
;;;215    }
00002a  e8bd81fc          POP      {r2-r8,pc}
;;;216    
                          ENDP


                          AREA ||i.USBH_ParseCfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_ParseCfgDesc PROC
;;;397    */
;;;398    static void  USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;399                                    USBH_InterfaceDesc_TypeDef* itf_desc,
;;;400                                    USBH_EpDesc_TypeDef   ep_desc[][USBH_MAX_NUM_ENDPOINTS], 
;;;401                                    uint8_t *buf, 
;;;402                                    uint16_t length)
;;;403    {  
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  9912              LDR      r1,[sp,#0x48]
00000a  4690              MOV      r8,r2
;;;404      USBH_InterfaceDesc_TypeDef    *pif ;
;;;405      USBH_InterfaceDesc_TypeDef    temp_pif ;  
;;;406      USBH_EpDesc_TypeDef           *pep;  
;;;407      USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
00000c  461c              MOV      r4,r3
;;;408      uint16_t                      ptr;
;;;409      int8_t                        if_ix = 0;
;;;410      int8_t                        ep_ix = 0;  
;;;411      static uint16_t               prev_ep_size = 0;
;;;412      static uint8_t                prev_itf = 0;  
;;;413      
;;;414      
;;;415      pdesc   = (USBH_DescHeader_t *)buf;
;;;416      
;;;417      /* Parse configuration descriptor */
;;;418      cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
00000e  7818              LDRB     r0,[r3,#0]
000010  7038              STRB     r0,[r7,#0]
;;;419      cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
000012  7858              LDRB     r0,[r3,#1]
000014  7078              STRB     r0,[r7,#1]
;;;420      cfg_desc->wTotalLength        = LE16 (buf + 2);
000016  7898              LDRB     r0,[r3,#2]
000018  78da              LDRB     r2,[r3,#3]
00001a  eb002002          ADD      r0,r0,r2,LSL #8
00001e  8078              STRH     r0,[r7,#2]
;;;421      cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
000020  7918              LDRB     r0,[r3,#4]
000022  7138              STRB     r0,[r7,#4]
;;;422      cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
000024  795a              LDRB     r2,[r3,#5]
000026  717a              STRB     r2,[r7,#5]
;;;423      cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
000028  799a              LDRB     r2,[r3,#6]
00002a  71ba              STRB     r2,[r7,#6]
;;;424      cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
00002c  79da              LDRB     r2,[r3,#7]
00002e  71fa              STRB     r2,[r7,#7]
;;;425      cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
000030  7a1a              LDRB     r2,[r3,#8]
000032  723a              STRB     r2,[r7,#8]
;;;426      
;;;427      
;;;428      if (length > USB_CONFIGURATION_DESC_SIZE)
000034  2909              CMP      r1,#9
000036  d95f              BLS      |L7.248|
;;;429      {
;;;430        ptr = USB_LEN_CFG_DESC;
000038  2109              MOVS     r1,#9
00003a  9101              STR      r1,[sp,#4]
;;;431        
;;;432        if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
;;;433        {
;;;434          pif = (USBH_InterfaceDesc_TypeDef *)0;
;;;435          
;;;436          while (ptr < cfg_desc->wTotalLength ) 
;;;437          {
;;;438            pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
;;;439            if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
;;;440            {
;;;441              if_ix             = *(((uint8_t *)pdesc ) + 2);
;;;442              pif               = &itf_desc[if_ix];
;;;443              
;;;444              if((*((uint8_t *)pdesc + 3)) < 3)
;;;445              {
;;;446              USBH_ParseInterfaceDesc (&temp_pif, (uint8_t *)pdesc);            
;;;447              ep_ix = 0;
;;;448              
;;;449              /* Parse Ep descriptors relative to the current interface */
;;;450              if(temp_pif.bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
;;;451              {          
;;;452                while (ep_ix < temp_pif.bNumEndpoints) 
;;;453                {
;;;454                  pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
;;;455                  if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
;;;456                  {  
;;;457                    pep               = &ep_desc[if_ix][ep_ix];
;;;458                    
;;;459                    if(prev_itf != if_ix)
00003c  f8dfb0c0          LDR      r11,|L7.256|
000040  2802              CMP      r0,#2                 ;432
000042  d94f              BLS      |L7.228|
000044  e053              B        |L7.238|
                  |L7.70|
000046  a901              ADD      r1,sp,#4              ;438
000048  4620              MOV      r0,r4                 ;438
00004a  f7fffffe          BL       USBH_GetNextDesc
00004e  4604              MOV      r4,r0                 ;438
000050  7860              LDRB     r0,[r4,#1]            ;439
000052  2804              CMP      r0,#4                 ;439
000054  d146              BNE      |L7.228|
000056  f9946002          LDRSB    r6,[r4,#2]            ;441
00005a  9806              LDR      r0,[sp,#0x18]         ;442
00005c  eb0601c6          ADD      r1,r6,r6,LSL #3       ;442
000060  eb010a00          ADD      r10,r1,r0             ;442
000064  78e0              LDRB     r0,[r4,#3]            ;444
000066  2803              CMP      r0,#3                 ;444
000068  d23c              BCS      |L7.228|
00006a  4621              MOV      r1,r4                 ;446
00006c  a802              ADD      r0,sp,#8              ;446
00006e  f7fffffe          BL       USBH_ParseInterfaceDesc
000072  2500              MOVS     r5,#0                 ;447
000074  f89d000c          LDRB     r0,[sp,#0xc]          ;450
000078  2802              CMP      r0,#2                 ;450
00007a  d833              BHI      |L7.228|
00007c  e02e              B        |L7.220|
                  |L7.126|
00007e  a901              ADD      r1,sp,#4              ;454
000080  4620              MOV      r0,r4                 ;454
000082  f7fffffe          BL       USBH_GetNextDesc
000086  4604              MOV      r4,r0                 ;454
000088  7860              LDRB     r0,[r4,#1]            ;455
00008a  2805              CMP      r0,#5                 ;455
00008c  d126              BNE      |L7.220|
00008e  eb081006          ADD      r0,r8,r6,LSL #4       ;457
000092  eb0009c5          ADD      r9,r0,r5,LSL #3       ;457
000096  f89b0000          LDRB     r0,[r11,#0]  ; prev_itf
00009a  42b0              CMP      r0,r6
00009c  d006              BEQ      |L7.172|
;;;460                    {
;;;461                      prev_itf = if_ix;
00009e  f88b6000          STRB     r6,[r11,#0]
;;;462                      USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif); 
0000a2  a902              ADD      r1,sp,#8
0000a4  4650              MOV      r0,r10
0000a6  f7fffffe          BL       USBH_ParseInterfaceDesc
0000aa  e00b              B        |L7.196|
                  |L7.172|
;;;463                    }
;;;464                    else
;;;465                    {
;;;466                      if(prev_ep_size > LE16((uint8_t *)pdesc + 4))
0000ac  7920              LDRB     r0,[r4,#4]
0000ae  7961              LDRB     r1,[r4,#5]
0000b0  eb002001          ADD      r0,r0,r1,LSL #8
0000b4  f8bb1002          LDRH     r1,[r11,#2]  ; prev_ep_size
0000b8  4288              CMP      r0,r1
0000ba  d313              BCC      |L7.228|
;;;467                      {
;;;468                        break;
;;;469                      }
;;;470                      else
;;;471                      {
;;;472                        USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif);    
0000bc  a902              ADD      r1,sp,#8
0000be  4650              MOV      r0,r10
0000c0  f7fffffe          BL       USBH_ParseInterfaceDesc
                  |L7.196|
;;;473                      }
;;;474                    }
;;;475                    USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
0000c4  4621              MOV      r1,r4
0000c6  4648              MOV      r0,r9
0000c8  f7fffffe          BL       USBH_ParseEPDesc
;;;476                    prev_ep_size = LE16((uint8_t *)pdesc + 4);
0000cc  7920              LDRB     r0,[r4,#4]
0000ce  7961              LDRB     r1,[r4,#5]
0000d0  eb002001          ADD      r0,r0,r1,LSL #8
0000d4  f8ab0002          STRH     r0,[r11,#2]
;;;477                    ep_ix++;
0000d8  1c6d              ADDS     r5,r5,#1
0000da  b26d              SXTB     r5,r5
                  |L7.220|
0000dc  f89d000c          LDRB     r0,[sp,#0xc]          ;452
0000e0  42a8              CMP      r0,r5                 ;452
0000e2  dccc              BGT      |L7.126|
                  |L7.228|
0000e4  8878              LDRH     r0,[r7,#2]            ;436
0000e6  f8bd1004          LDRH     r1,[sp,#4]            ;436
0000ea  4288              CMP      r0,r1                 ;436
0000ec  d8ab              BHI      |L7.70|
                  |L7.238|
;;;478                  }
;;;479                }
;;;480              }
;;;481             }
;;;482            }
;;;483          }
;;;484        }
;;;485        prev_ep_size = 0;
0000ee  2000              MOVS     r0,#0
0000f0  f8ab0002          STRH     r0,[r11,#2]
;;;486        prev_itf = 0; 
0000f4  f88b0000          STRB     r0,[r11,#0]
                  |L7.248|
;;;487      }  
;;;488    }
0000f8  b009              ADD      sp,sp,#0x24
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;489    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L7.256|
                          DCD      ||.data||

                          AREA ||i.USBH_ParseDevDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseDevDesc PROC
;;;362    */
;;;363    static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
000000  b510              PUSH     {r4,lr}
;;;364                                    uint8_t *buf, 
;;;365                                    uint16_t length)
;;;366    {
;;;367      dev_desc->bLength            = *(uint8_t  *) (buf +  0);
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
;;;368      dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
000006  784b              LDRB     r3,[r1,#1]
000008  7043              STRB     r3,[r0,#1]
;;;369      dev_desc->bcdUSB             = LE16 (buf +  2);
00000a  788b              LDRB     r3,[r1,#2]
00000c  78cc              LDRB     r4,[r1,#3]
00000e  eb032304          ADD      r3,r3,r4,LSL #8
000012  8043              STRH     r3,[r0,#2]
;;;370      dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
000014  790b              LDRB     r3,[r1,#4]
000016  7103              STRB     r3,[r0,#4]
;;;371      dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
000018  794b              LDRB     r3,[r1,#5]
00001a  7143              STRB     r3,[r0,#5]
;;;372      dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
00001c  798b              LDRB     r3,[r1,#6]
00001e  7183              STRB     r3,[r0,#6]
;;;373      dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
000020  79cb              LDRB     r3,[r1,#7]
000022  71c3              STRB     r3,[r0,#7]
;;;374      
;;;375      if (length > 8)
000024  2a08              CMP      r2,#8
000026  d916              BLS      |L8.86|
;;;376      { /* For 1st time after device connection, Host may issue only 8 bytes for 
;;;377        Device Descriptor Length  */
;;;378        dev_desc->idVendor           = LE16 (buf +  8);
000028  7a0a              LDRB     r2,[r1,#8]
00002a  7a4b              LDRB     r3,[r1,#9]
00002c  eb022203          ADD      r2,r2,r3,LSL #8
000030  8102              STRH     r2,[r0,#8]
;;;379        dev_desc->idProduct          = LE16 (buf + 10);
000032  7a8a              LDRB     r2,[r1,#0xa]
000034  7acb              LDRB     r3,[r1,#0xb]
000036  eb022203          ADD      r2,r2,r3,LSL #8
00003a  8142              STRH     r2,[r0,#0xa]
;;;380        dev_desc->bcdDevice          = LE16 (buf + 12);
00003c  7b0a              LDRB     r2,[r1,#0xc]
00003e  7b4b              LDRB     r3,[r1,#0xd]
000040  eb022203          ADD      r2,r2,r3,LSL #8
000044  8182              STRH     r2,[r0,#0xc]
;;;381        dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
000046  7b8a              LDRB     r2,[r1,#0xe]
000048  7382              STRB     r2,[r0,#0xe]
;;;382        dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
00004a  7bca              LDRB     r2,[r1,#0xf]
00004c  73c2              STRB     r2,[r0,#0xf]
;;;383        dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
00004e  7c0a              LDRB     r2,[r1,#0x10]
000050  7402              STRB     r2,[r0,#0x10]
;;;384        dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
000052  7c49              LDRB     r1,[r1,#0x11]
000054  7441              STRB     r1,[r0,#0x11]
                  |L8.86|
;;;385      }
;;;386    }
000056  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.USBH_ParseEPDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseEPDesc PROC
;;;518    */
;;;519    static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;520                                   uint8_t *buf)
;;;521    {
;;;522      
;;;523      ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;524      ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;525      ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;526      ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;527      ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  794b              LDRB     r3,[r1,#5]
000014  eb022203          ADD      r2,r2,r3,LSL #8
000018  8082              STRH     r2,[r0,#4]
;;;528      ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
00001a  7989              LDRB     r1,[r1,#6]
00001c  7181              STRB     r1,[r0,#6]
;;;529    }
00001e  4770              BX       lr
;;;530    
                          ENDP


                          AREA ||i.USBH_ParseInterfaceDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseInterfaceDesc PROC
;;;497    */
;;;498    static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;499                                          uint8_t *buf)
;;;500    {
;;;501      if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;502      if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;503      if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;504      if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;505      if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  7102              STRB     r2,[r0,#4]
;;;506      if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
000014  794a              LDRB     r2,[r1,#5]
000016  7142              STRB     r2,[r0,#5]
;;;507      if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
000018  798a              LDRB     r2,[r1,#6]
00001a  7182              STRB     r2,[r0,#6]
;;;508      if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
00001c  79ca              LDRB     r2,[r1,#7]
00001e  71c2              STRB     r2,[r0,#7]
;;;509      if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
000020  7a09              LDRB     r1,[r1,#8]
000022  7201              STRB     r1,[r0,#8]
;;;510    }
000024  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.USBH_ParseStringDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseStringDesc PROC
;;;538    */
;;;539    static void USBH_ParseStringDesc (uint8_t* psrc, 
000000  b510              PUSH     {r4,lr}
;;;540                                      uint8_t* pdest, 
;;;541                                      uint16_t length)
;;;542    {
;;;543      uint16_t strlength;
;;;544      uint16_t idx;
;;;545      
;;;546      /* The UNICODE string descriptor is not NULL-terminated. The string length is
;;;547      computed by substracting two from the value of the first byte of the descriptor.
;;;548      */
;;;549      
;;;550      /* Check which is lower size, the Size of string or the length of bytes read 
;;;551      from the device */
;;;552      
;;;553      if ( psrc[1] == USB_DESC_TYPE_STRING)
000002  7843              LDRB     r3,[r0,#1]
000004  2b03              CMP      r3,#3
000006  d111              BNE      |L11.44|
;;;554      { /* Make sure the Descriptor is String Type */
;;;555        
;;;556        /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
;;;557        strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
000008  7803              LDRB     r3,[r0,#0]
00000a  1e9c              SUBS     r4,r3,#2
00000c  4294              CMP      r4,r2
00000e  dc00              BGT      |L11.18|
000010  1e9a              SUBS     r2,r3,#2
                  |L11.18|
000012  b293              UXTH     r3,r2
;;;558        psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
000014  1c80              ADDS     r0,r0,#2
;;;559        
;;;560        for (idx = 0; idx < strlength; idx+=2 )
000016  2200              MOVS     r2,#0
000018  e004              B        |L11.36|
                  |L11.26|
;;;561        {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
;;;562          *pdest =  psrc[idx];
00001a  5c84              LDRB     r4,[r0,r2]
00001c  f8014b01          STRB     r4,[r1],#1
000020  1c92              ADDS     r2,r2,#2              ;560
000022  b292              UXTH     r2,r2                 ;560
                  |L11.36|
000024  429a              CMP      r2,r3                 ;560
000026  d3f8              BCC      |L11.26|
;;;563          pdest++;
;;;564        }  
;;;565        *pdest = 0; /* mark end of string */  
000028  2000              MOVS     r0,#0
00002a  7008              STRB     r0,[r1,#0]
                  |L11.44|
;;;566      }
;;;567    }
00002c  bd10              POP      {r4,pc}
;;;568    
                          ENDP


                          AREA ||i.USBH_SetAddress||, CODE, READONLY, ALIGN=1

                  USBH_SetAddress PROC
;;;257    */
;;;258    USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;259                                USBH_HOST *phost,
;;;260                                uint8_t DeviceAddress)
;;;261    {
;;;262      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
000002  2300              MOVS     r3,#0
000004  750b              STRB     r3,[r1,#0x14]
;;;263        USB_REQ_TYPE_STANDARD;
;;;264      
;;;265      phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
000006  2405              MOVS     r4,#5
000008  754c              STRB     r4,[r1,#0x15]
;;;266      
;;;267      phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;268      phost->Control.setup.b.wIndex.w = 0;
00000c  830b              STRH     r3,[r1,#0x18]
;;;269      phost->Control.setup.b.wLength.w = 0;
00000e  834b              STRH     r3,[r1,#0x1a]
;;;270      
;;;271      return USBH_CtlReq(pdev, phost, 0 , 0 );
000010  bc30              POP      {r4,r5}
000012  461a              MOV      r2,r3
000014  f7ffbffe          B.W      USBH_CtlReq
;;;272    }
;;;273    
                          ENDP


                          AREA ||i.USBH_SetCfg||, CODE, READONLY, ALIGN=1

                  USBH_SetCfg PROC
;;;280    */
;;;281    USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;282                            USBH_HOST *phost,
;;;283                            uint16_t cfg_idx)
;;;284    {
;;;285      
;;;286      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
000002  2300              MOVS     r3,#0
000004  750b              STRB     r3,[r1,#0x14]
;;;287        USB_REQ_TYPE_STANDARD;
;;;288      phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
000006  2409              MOVS     r4,#9
000008  754c              STRB     r4,[r1,#0x15]
;;;289      phost->Control.setup.b.wValue.w = cfg_idx;
00000a  82ca              STRH     r2,[r1,#0x16]
;;;290      phost->Control.setup.b.wIndex.w = 0;
00000c  830b              STRH     r3,[r1,#0x18]
;;;291      phost->Control.setup.b.wLength.w = 0;           
00000e  834b              STRH     r3,[r1,#0x1a]
;;;292      
;;;293      return USBH_CtlReq(pdev, phost, 0 , 0 );      
000010  bc30              POP      {r4,r5}
000012  461a              MOV      r2,r3
000014  f7ffbffe          B.W      USBH_CtlReq
;;;294    }
;;;295    
                          ENDP


                          AREA ||i.USBH_SetInterface||, CODE, READONLY, ALIGN=1

                  USBH_SetInterface PROC
;;;302    */
;;;303    USBH_Status USBH_SetInterface(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;304                            USBH_HOST *phost,
;;;305                            uint8_t ep_num, uint8_t altSetting)
;;;306    {
;;;307      
;;;308      
;;;309      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE | \
000002  2401              MOVS     r4,#1
000004  750c              STRB     r4,[r1,#0x14]
;;;310        USB_REQ_TYPE_STANDARD;
;;;311      
;;;312      phost->Control.setup.b.bRequest = USB_REQ_SET_INTERFACE;
000006  240b              MOVS     r4,#0xb
000008  754c              STRB     r4,[r1,#0x15]
;;;313      phost->Control.setup.b.wValue.w = altSetting;
00000a  82cb              STRH     r3,[r1,#0x16]
;;;314      phost->Control.setup.b.wIndex.w = ep_num;
00000c  830a              STRH     r2,[r1,#0x18]
;;;315      phost->Control.setup.b.wLength.w = 0;           
00000e  2200              MOVS     r2,#0
000010  834a              STRH     r2,[r1,#0x1a]
;;;316     
;;;317      return USBH_CtlReq(pdev, phost, 0 , 0 );     
000012  2300              MOVS     r3,#0
000014  bc30              POP      {r4,r5}
000016  461a              MOV      r2,r3
000018  f7ffbffe          B.W      USBH_CtlReq
;;;318    }
;;;319    /**
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USBH_CfgDesc
                          %        512

                          AREA ||.data||, DATA, ALIGN=1

                  prev_itf
000000  0000              DCB      0x00,0x00
                  prev_ep_size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_stdreq.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_usbh_stdreq_c_3531d2fa____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REVSH|
#line 128
|__asm___13_usbh_stdreq_c_3531d2fa____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
