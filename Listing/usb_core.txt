; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usb_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usb_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usb_core.crf ..\USB\STM32_USB_OTG_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;322    */
;;;323    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;326      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;327      USB_OTG_GCCFG_TypeDef    gccfg;
;;;328      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;329      
;;;330      usbcfg.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;331      gccfg.d32 = 0;
00000a  9001              STR      r0,[sp,#4]
;;;332      ahbcfg.d32 = 0;
00000c  9000              STR      r0,[sp,#0]
;;;333      
;;;334      
;;;335      
;;;336      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00000e  7a21              LDRB     r1,[r4,#8]
000010  68e0              LDR      r0,[r4,#0xc]
000012  2901              CMP      r1,#1
000014  d019              BEQ      |L1.74|
;;;337      {
;;;338        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
;;;339        gccfg.b.pwdn = 0;
;;;340        
;;;341        if (pdev->cfg.Sof_output)
;;;342        {
;;;343          gccfg.b.sofouten = 1;   
;;;344        }
;;;345        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
;;;346        
;;;347        /* Init The ULPI Interface */
;;;348        usbcfg.d32 = 0;
;;;349        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;350        
;;;351        usbcfg.b.physel            = 0; /* HS Interface */
;;;352    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;353        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;354    #else
;;;355    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;356        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;357    #endif
;;;358    #endif 
;;;359        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
;;;360        
;;;361        usbcfg.b.ulpi_fsls = 0;
;;;362        usbcfg.b.ulpi_clk_sus_m = 0;
;;;363        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;364        
;;;365        /* Reset after a PHY select  */
;;;366        USB_OTG_CoreReset(pdev);
;;;367        
;;;368        if(pdev->cfg.dma_enable == 1)
;;;369        {
;;;370          
;;;371          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
;;;372          ahbcfg.b.dmaenable = 1;
;;;373          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
;;;374          
;;;375        }    
;;;376      }
;;;377      else /* FS interface (embedded Phy) */
;;;378      {
;;;379        
;;;380        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
000016  68c1              LDR      r1,[r0,#0xc]
;;;381        usbcfg.b.physel  = 1; /* FS Interface */
000018  f0410140          ORR      r1,r1,#0x40
00001c  9102              STR      r1,[sp,#8]
;;;382        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001e  60c1              STR      r1,[r0,#0xc]
;;;383        /* Reset after a PHY select and set Host mode */
;;;384        USB_OTG_CoreReset(pdev);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       USB_OTG_CoreReset
;;;385        /* Deactivate the power down*/
;;;386        gccfg.d32 = 0;
;;;387        gccfg.b.pwdn = 1;
;;;388        
;;;389        gccfg.b.vbussensingA = 1 ;
;;;390        gccfg.b.vbussensingB = 1 ;     
;;;391    #ifndef VBUS_SENSING_ENABLED
;;;392        gccfg.b.disablevbussensing = 1; 
000026  f44f1034          MOV      r0,#0x2d0000
00002a  9001              STR      r0,[sp,#4]
;;;393    #endif    
;;;394        
;;;395        if(pdev->cfg.Sof_output)
00002c  7a60              LDRB     r0,[r4,#9]
00002e  b110              CBZ      r0,|L1.54|
;;;396        {
;;;397          gccfg.b.sofouten = 1;  
000030  f44f1074          MOV      r0,#0x3d0000
000034  9001              STR      r0,[sp,#4]
                  |L1.54|
;;;398        }
;;;399        
;;;400        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000036  68e1              LDR      r1,[r4,#0xc]
000038  9801              LDR      r0,[sp,#4]
00003a  6388              STR      r0,[r1,#0x38]
;;;401        USB_OTG_BSP_mDelay(20);
00003c  2014              MOVS     r0,#0x14
00003e  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L1.66|
;;;402      }
;;;403      /* case the HS core is working in FS mode */
;;;404      if(pdev->cfg.dma_enable == 1)
000042  78e0              LDRB     r0,[r4,#3]
000044  2801              CMP      r0,#1
000046  d024              BEQ      |L1.146|
000048  e02c              B        |L1.164|
                  |L1.74|
00004a  6b81              LDR      r1,[r0,#0x38]         ;338
00004c  f4213180          BIC      r1,r1,#0x10000        ;339
000050  9101              STR      r1,[sp,#4]            ;339
000052  7a62              LDRB     r2,[r4,#9]            ;341
000054  b112              CBZ      r2,|L1.92|
000056  f4411180          ORR      r1,r1,#0x100000       ;343
00005a  9101              STR      r1,[sp,#4]            ;343
                  |L1.92|
00005c  9901              LDR      r1,[sp,#4]            ;345
00005e  6381              STR      r1,[r0,#0x38]         ;345
000060  68e0              LDR      r0,[r4,#0xc]          ;349
000062  68c1              LDR      r1,[r0,#0xc]          ;349
000064  f0210140          BIC      r1,r1,#0x40           ;351
000068  f4411180          ORR      r1,r1,#0x100000       ;356
00006c  f4210180          BIC      r1,r1,#0x400000       ;359
000070  f4213100          BIC      r1,r1,#0x20000        ;361
000074  f4212100          BIC      r1,r1,#0x80000        ;362
000078  9102              STR      r1,[sp,#8]            ;362
00007a  60c1              STR      r1,[r0,#0xc]          ;363
00007c  4620              MOV      r0,r4                 ;366
00007e  f7fffffe          BL       USB_OTG_CoreReset
000082  78e0              LDRB     r0,[r4,#3]            ;368
000084  2801              CMP      r0,#1                 ;368
000086  d1dc              BNE      |L1.66|
000088  202a              MOVS     r0,#0x2a              ;372
00008a  9000              STR      r0,[sp,#0]            ;372
00008c  68e1              LDR      r1,[r4,#0xc]          ;373
00008e  6088              STR      r0,[r1,#8]            ;373
000090  e7d7              B        |L1.66|
                  |L1.146|
;;;405      {
;;;406        
;;;407        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
000092  68e0              LDR      r0,[r4,#0xc]
000094  6881              LDR      r1,[r0,#8]
;;;408        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000096  f021011e          BIC      r1,r1,#0x1e
00009a  310a              ADDS     r1,r1,#0xa
;;;409        ahbcfg.b.dmaenable = 1;
00009c  f0410120          ORR      r1,r1,#0x20
0000a0  9100              STR      r1,[sp,#0]
;;;410        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
0000a2  6081              STR      r1,[r0,#8]
                  |L1.164|
;;;411        
;;;412      }
;;;413      /* initialize OTG features */
;;;414    #ifdef  USE_OTG_MODE
;;;415      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;416      usbcfg.b.hnpcap = 1;
;;;417      usbcfg.b.srpcap = 1;
;;;418      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;419      USB_OTG_EnableCommonInt(pdev);
;;;420    #endif
;;;421      return status;
0000a4  4628              MOV      r0,r5
;;;422    }
0000a6  bd3e              POP      {r1-r5,pc}
;;;423    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitHost PROC
;;;611    */
;;;612    USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
000000  b5fe              PUSH     {r1-r7,lr}
;;;613    {
000002  4604              MOV      r4,r0
;;;614      USB_OTG_STS                     status = USB_OTG_OK;
000004  2600              MOVS     r6,#0
;;;615      USB_OTG_FSIZ_TypeDef            nptxfifosize;
;;;616      USB_OTG_FSIZ_TypeDef            ptxfifosize;  
;;;617      USB_OTG_HCFG_TypeDef            hcfg;
;;;618      
;;;619    #ifdef USE_OTG_MODE
;;;620      USB_OTG_OTGCTL_TypeDef          gotgctl;
;;;621    #endif
;;;622      
;;;623      uint32_t                        i = 0;
000006  2500              MOVS     r5,#0
;;;624      
;;;625      nptxfifosize.d32 = 0;  
000008  2700              MOVS     r7,#0
00000a  9702              STR      r7,[sp,#8]
;;;626      ptxfifosize.d32 = 0;
00000c  9701              STR      r7,[sp,#4]
;;;627    #ifdef USE_OTG_MODE
;;;628      gotgctl.d32 = 0;
;;;629    #endif
;;;630      hcfg.d32 = 0;
00000e  9700              STR      r7,[sp,#0]
;;;631      
;;;632      
;;;633      /* configure charge pump IO */
;;;634      USB_OTG_BSP_ConfigVBUS(pdev);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;635      
;;;636      /* Restart the Phy Clock */
;;;637      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000016  f8d4010c          LDR      r0,[r4,#0x10c]
00001a  6007              STR      r7,[r0,#0]
;;;638      
;;;639      /* Initialize Host Configuration Register */
;;;640      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00001c  7a20              LDRB     r0,[r4,#8]
00001e  2801              CMP      r0,#1
000020  d010              BEQ      |L2.68|
;;;641      {
;;;642        USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
;;;643      }
;;;644      else
;;;645      {
;;;646        USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
                  |L2.42|
;;;647      }
;;;648      USB_OTG_ResetPort(pdev);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USB_OTG_ResetPort
;;;649      
;;;650      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000030  6960              LDR      r0,[r4,#0x14]
000032  6801              LDR      r1,[r0,#0]
;;;651      hcfg.b.fslssupp = 0;
000034  f0210104          BIC      r1,r1,#4
000038  9100              STR      r1,[sp,#0]
;;;652      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
00003a  6001              STR      r1,[r0,#0]
;;;653      
;;;654      /* Configure data FIFO sizes */
;;;655      /* Rx FIFO */
;;;656    #ifdef USB_OTG_FS_CORE
;;;657      if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
00003c  7ae0              LDRB     r0,[r4,#0xb]
00003e  2801              CMP      r0,#1
000040  d005              BEQ      |L2.78|
000042  e018              B        |L2.118|
                  |L2.68|
000044  2100              MOVS     r1,#0                 ;642
000046  4620              MOV      r0,r4                 ;642
000048  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
00004c  e7ed              B        |L2.42|
                  |L2.78|
;;;658      {
;;;659        /* set Rx FIFO size */
;;;660        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
00004e  68e1              LDR      r1,[r4,#0xc]
000050  2080              MOVS     r0,#0x80
000052  6248              STR      r0,[r1,#0x24]
;;;661        nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
000054  f8ad0008          STRH     r0,[sp,#8]
;;;662        nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
000058  2060              MOVS     r0,#0x60
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;663        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
00005e  68e2              LDR      r2,[r4,#0xc]
000060  9902              LDR      r1,[sp,#8]
000062  6291              STR      r1,[r2,#0x28]
;;;664        
;;;665        ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
000064  21e0              MOVS     r1,#0xe0
000066  f8ad1004          STRH     r1,[sp,#4]
;;;666        ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
00006a  f8ad0006          STRH     r0,[sp,#6]
;;;667        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
00006e  68e1              LDR      r1,[r4,#0xc]
000070  9801              LDR      r0,[sp,#4]
000072  f8c10100          STR      r0,[r1,#0x100]
                  |L2.118|
;;;668      }
;;;669    #endif
;;;670    #ifdef USB_OTG_HS_CORE  
;;;671      if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
000076  7ae0              LDRB     r0,[r4,#0xb]
000078  b9a8              CBNZ     r0,|L2.166|
;;;672      {
;;;673        /* set Rx FIFO size */
;;;674        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
00007a  68e1              LDR      r1,[r4,#0xc]
00007c  f44f7000          MOV      r0,#0x200
000080  6248              STR      r0,[r1,#0x24]
;;;675        nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
000082  f8ad0008          STRH     r0,[sp,#8]
;;;676        nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
000086  1040              ASRS     r0,r0,#1
000088  f8ad000a          STRH     r0,[sp,#0xa]
;;;677        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
00008c  68e2              LDR      r2,[r4,#0xc]
00008e  9902              LDR      r1,[sp,#8]
000090  6291              STR      r1,[r2,#0x28]
;;;678        
;;;679        ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
000092  f44f7140          MOV      r1,#0x300
000096  f8ad1004          STRH     r1,[sp,#4]
;;;680        ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
00009a  f8ad0006          STRH     r0,[sp,#6]
;;;681        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
00009e  68e1              LDR      r1,[r4,#0xc]
0000a0  9801              LDR      r0,[sp,#4]
0000a2  f8c10100          STR      r0,[r1,#0x100]
                  |L2.166|
;;;682      }
;;;683    #endif  
;;;684      
;;;685    #ifdef USE_OTG_MODE
;;;686      /* Clear Host Set HNP Enable in the USB_OTG Control Register */
;;;687      gotgctl.b.hstsethnpen = 1;
;;;688      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
;;;689    #endif
;;;690      
;;;691      /* Make sure the FIFOs are flushed. */
;;;692      USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
0000a6  2110              MOVS     r1,#0x10
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;693      USB_OTG_FlushRxFifo(pdev);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;694      
;;;695      
;;;696      /* Clear all pending HC Interrupts */
;;;697      for (i = 0; i < pdev->cfg.host_channels; i++)
;;;698      {
;;;699        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
0000b4  f04f31ff          MOV      r1,#0xffffffff
0000b8  e007              B        |L2.202|
                  |L2.186|
0000ba  eb040085          ADD      r0,r4,r5,LSL #2
0000be  f8502f90          LDR      r2,[r0,#0x90]!
0000c2  6091              STR      r1,[r2,#8]
;;;700        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
0000c4  6800              LDR      r0,[r0,#0]
0000c6  60c7              STR      r7,[r0,#0xc]
0000c8  1c6d              ADDS     r5,r5,#1              ;697
                  |L2.202|
0000ca  7820              LDRB     r0,[r4,#0]            ;697
0000cc  42a8              CMP      r0,r5                 ;697
0000ce  d8f4              BHI      |L2.186|
;;;701      }
;;;702    #ifndef USE_OTG_MODE
;;;703      USB_OTG_DriveVbus(pdev, 1);
0000d0  2101              MOVS     r1,#1
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       USB_OTG_DriveVbus
;;;704    #endif
;;;705      
;;;706      USB_OTG_EnableHostInt(pdev);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       USB_OTG_EnableHostInt
;;;707      return status;
0000de  4630              MOV      r0,r6
;;;708    }
0000e0  bdfe              POP      {r1-r7,pc}
;;;709    
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;122    */
;;;123    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    {
000002  4605              MOV      r5,r0
;;;125      USB_OTG_STS status = USB_OTG_OK;
000004  2600              MOVS     r6,#0
;;;126      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;127      uint32_t count = 0;
000006  2400              MOVS     r4,#0
;;;128      
;;;129      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;130      /* Wait for AHB master IDLE state. */
;;;131      do
;;;132      {
;;;133        USB_OTG_BSP_uDelay(3);
;;;134        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;135        if (++count > 200000)
00000c  4f12              LDR      r7,|L3.88|
                  |L3.14|
00000e  2003              MOVS     r0,#3                 ;133
000010  f7fffffe          BL       USB_OTG_BSP_uDelay
000014  68e8              LDR      r0,[r5,#0xc]          ;134
000016  6900              LDR      r0,[r0,#0x10]         ;134
000018  9000              STR      r0,[sp,#0]            ;134
00001a  1c64              ADDS     r4,r4,#1
00001c  42bc              CMP      r4,r7
00001e  d901              BLS      |L3.36|
;;;136        {
;;;137          return USB_OTG_OK;
000020  2000              MOVS     r0,#0
;;;138        }
;;;139      }
;;;140      while (greset.b.ahbidle == 0);
;;;141      /* Core Soft Reset */
;;;142      count = 0;
;;;143      greset.b.csftrst = 1;
;;;144      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;145      do
;;;146      {
;;;147        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;148        if (++count > 200000)
;;;149        {
;;;150          break;
;;;151        }
;;;152      }
;;;153      while (greset.b.csftrst == 1);
;;;154      /* Wait for 3 PHY Clocks*/
;;;155      USB_OTG_BSP_uDelay(3);
;;;156      return status;
;;;157    }
000022  bdf8              POP      {r3-r7,pc}
                  |L3.36|
000024  9800              LDR      r0,[sp,#0]            ;140
000026  2800              CMP      r0,#0                 ;140
000028  daf1              BGE      |L3.14|
00002a  2000              MOVS     r0,#0                 ;142
00002c  9900              LDR      r1,[sp,#0]            ;143
00002e  f0410101          ORR      r1,r1,#1              ;143
000032  9100              STR      r1,[sp,#0]            ;143
000034  9900              LDR      r1,[sp,#0]            ;144
000036  68ea              LDR      r2,[r5,#0xc]          ;144
000038  6111              STR      r1,[r2,#0x10]         ;144
00003a  68e9              LDR      r1,[r5,#0xc]          ;134
                  |L3.60|
00003c  690a              LDR      r2,[r1,#0x10]         ;147
00003e  9200              STR      r2,[sp,#0]            ;147
000040  1c40              ADDS     r0,r0,#1              ;148
000042  42b8              CMP      r0,r7                 ;148
000044  d802              BHI      |L3.76|
000046  9a00              LDR      r2,[sp,#0]            ;153
000048  07d2              LSLS     r2,r2,#31             ;153
00004a  d1f7              BNE      |L3.60|
                  |L3.76|
00004c  2003              MOVS     r0,#3                 ;155
00004e  f7fffffe          BL       USB_OTG_BSP_uDelay
000052  4630              MOV      r0,r6                 ;156
000054  bdf8              POP      {r3-r7,pc}
;;;158    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;446    */
;;;447    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  2200              MOVS     r2,#0
;;;448    {
;;;449      USB_OTG_STS status = USB_OTG_OK;
;;;450      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;451      ahbcfg.d32 = 0;
;;;452      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;453      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000002  68c0              LDR      r0,[r0,#0xc]
000004  6881              LDR      r1,[r0,#8]
000006  f0210101          BIC      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;454      return status;
00000c  4610              MOV      r0,r2
;;;455    }
00000e  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.USB_OTG_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_OTG_DriveVbus PROC
;;;726    */
;;;727    void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  b538              PUSH     {r3-r5,lr}
;;;728    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;729      USB_OTG_HPRT0_TypeDef     hprt0;
;;;730      
;;;731      hprt0.d32 = 0;
;;;732      
;;;733      /* enable disable the external charge pump */
;;;734      USB_OTG_BSP_DriveVBUS(pdev, state);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;735      
;;;736      /* Turn on the Host port power. */
;;;737      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       USB_OTG_ReadHPRT0
000014  9000              STR      r0,[sp,#0]
;;;738      if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
000016  04c1              LSLS     r1,r0,#19
000018  d407              BMI      |L5.42|
00001a  2c01              CMP      r4,#1
00001c  d105              BNE      |L5.42|
;;;739      {
;;;740        hprt0.b.prtpwr = 1;
00001e  f4405080          ORR      r0,r0,#0x1000
000022  9000              STR      r0,[sp,#0]
;;;741        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000024  f8d510cc          LDR      r1,[r5,#0xcc]
000028  6008              STR      r0,[r1,#0]
                  |L5.42|
;;;742      }
;;;743      if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
00002a  9800              LDR      r0,[sp,#0]
00002c  04c1              LSLS     r1,r0,#19
00002e  d506              BPL      |L5.62|
000030  b92c              CBNZ     r4,|L5.62|
;;;744      {
;;;745        hprt0.b.prtpwr = 0;
000032  f4205080          BIC      r0,r0,#0x1000
000036  9000              STR      r0,[sp,#0]
;;;746        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000038  f8d510cc          LDR      r1,[r5,#0xcc]
00003c  6008              STR      r0,[r1,#0]
                  |L5.62|
;;;747      }
;;;748      
;;;749      USB_OTG_BSP_mDelay(200);
00003e  e8bd4038          POP      {r3-r5,lr}
000042  20c8              MOVS     r0,#0xc8
000044  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;750    }
;;;751    /**
                          ENDP


                          AREA ||i.USB_OTG_EnableCommonInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableCommonInt PROC
;;;94     */
;;;95     static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c2              LDR      r2,[r0,#0xc]
;;;96     {
;;;97       USB_OTG_GINTMSK_TypeDef  int_mask;
;;;98       
;;;99       int_mask.d32 = 0;
;;;100      /* Clear any pending USB_OTG Interrupts */
;;;101    #ifndef USE_OTG_MODE
;;;102      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
000002  f04f31ff          MOV      r1,#0xffffffff
000006  6051              STR      r1,[r2,#4]
;;;103    #endif
;;;104      /* Clear any pending interrupts */
;;;105      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
000008  68c2              LDR      r2,[r0,#0xc]
00000a  f06f4180          MVN      r1,#0x40000000
00000e  6151              STR      r1,[r2,#0x14]
;;;106      /* Enable the interrupts in the INTMSK */
;;;107      int_mask.b.wkupintr = 1;
;;;108      int_mask.b.usbsuspend = 1; 
000010  4901              LDR      r1,|L6.24|
;;;109      
;;;110    #ifdef USE_OTG_MODE
;;;111      int_mask.b.otgintr = 1;
;;;112      int_mask.b.sessreqintr = 1;
;;;113      int_mask.b.conidstschng = 1;
;;;114    #endif
;;;115      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
000012  68c0              LDR      r0,[r0,#0xc]
000014  6181              STR      r1,[r0,#0x18]
;;;116    }
000016  4770              BX       lr
;;;117    
                          ENDP

                  |L6.24|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;428    */
;;;429    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  2200              MOVS     r2,#0
;;;430    {
;;;431      USB_OTG_STS status = USB_OTG_OK;
;;;432      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;433      
;;;434      ahbcfg.d32 = 0;
;;;435      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;436      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000002  68c0              LDR      r0,[r0,#0xc]
000004  6881              LDR      r1,[r0,#8]
000006  f0410101          ORR      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;437      return status;
00000c  4610              MOV      r0,r2
;;;438    }
00000e  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.USB_OTG_EnableHostInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableHostInt PROC
;;;755    */
;;;756    USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;757    {
000002  4604              MOV      r4,r0
;;;758      USB_OTG_STS       status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;759      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;760      intmsk.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;761      /* Disable all interrupts. */
;;;762      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  6188              STR      r0,[r1,#0x18]
;;;763      
;;;764      /* Clear any pending interrupts. */
;;;765      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
00000e  68e1              LDR      r1,[r4,#0xc]
000010  1e40              SUBS     r0,r0,#1
000012  6148              STR      r0,[r1,#0x14]
;;;766      
;;;767      /* Enable the common interrupts */
;;;768      USB_OTG_EnableCommonInt(pdev);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USB_OTG_EnableCommonInt
;;;769      
;;;770      if (pdev->cfg.dma_enable == 0)
00001a  78e0              LDRB     r0,[r4,#3]
00001c  b908              CBNZ     r0,|L8.34|
;;;771      {  
;;;772        intmsk.b.rxstsqlvl  = 1;
00001e  2010              MOVS     r0,#0x10
000020  9000              STR      r0,[sp,#0]
                  |L8.34|
;;;773      }  
;;;774      intmsk.b.portintr   = 1;
000022  9800              LDR      r0,[sp,#0]
000024  f0407080          ORR      r0,r0,#0x1000000
;;;775      intmsk.b.hcintr     = 1;
000028  f0407000          ORR      r0,r0,#0x2000000
;;;776      intmsk.b.disconnect = 1;  
00002c  f0405000          ORR      r0,r0,#0x20000000
;;;777      intmsk.b.sofintr    = 1;  
000030  f0400008          ORR      r0,r0,#8
;;;778      intmsk.b.incomplisoout  = 1; 
000034  f4401000          ORR      r0,r0,#0x200000
;;;779      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000038  68e1              LDR      r1,[r4,#0xc]
00003a  698a              LDR      r2,[r1,#0x18]
00003c  4382              BICS     r2,r2,r0
00003e  4302              ORRS     r2,r2,r0
000040  618a              STR      r2,[r1,#0x18]
;;;780      return status;
000042  4628              MOV      r0,r5
;;;781    }
000044  bd38              POP      {r3-r5,pc}
;;;782    
                          ENDP


                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;493    */
;;;494    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b538              PUSH     {r3-r5,lr}
;;;495    {
000002  4601              MOV      r1,r0
;;;496      USB_OTG_STS status = USB_OTG_OK;
000004  2400              MOVS     r4,#0
;;;497      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;498      uint32_t count = 0;
000006  2000              MOVS     r0,#0
;;;499      
;;;500      greset.d32 = 0;
000008  2200              MOVS     r2,#0
00000a  9200              STR      r2,[sp,#0]
;;;501      greset.b.rxfflsh = 1;
00000c  9a00              LDR      r2,[sp,#0]
00000e  f0420210          ORR      r2,r2,#0x10
000012  9200              STR      r2,[sp,#0]
;;;502      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000014  9a00              LDR      r2,[sp,#0]
000016  68cb              LDR      r3,[r1,#0xc]
000018  611a              STR      r2,[r3,#0x10]
;;;503      do
;;;504      {
;;;505        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;506        if (++count > 200000)
00001a  4a07              LDR      r2,|L9.56|
00001c  68c9              LDR      r1,[r1,#0xc]          ;502
                  |L9.30|
00001e  690b              LDR      r3,[r1,#0x10]         ;505
000020  9300              STR      r3,[sp,#0]            ;505
000022  1c40              ADDS     r0,r0,#1
000024  4290              CMP      r0,r2
000026  d802              BHI      |L9.46|
;;;507        {
;;;508          break;
;;;509        }
;;;510      }
;;;511      while (greset.b.rxfflsh == 1);
000028  9b00              LDR      r3,[sp,#0]
00002a  06db              LSLS     r3,r3,#27
00002c  d4f7              BMI      |L9.30|
                  |L9.46|
;;;512      /* Wait for 3 PHY Clocks*/
;;;513      USB_OTG_BSP_uDelay(3);
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;514      return status;
000034  4620              MOV      r0,r4
;;;515    }
000036  bd38              POP      {r3-r5,pc}
;;;516    
                          ENDP

                  |L9.56|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;463    */
;;;464    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b538              PUSH     {r3-r5,lr}
;;;465    {
000002  4603              MOV      r3,r0
;;;466      USB_OTG_STS status = USB_OTG_OK;
000004  2400              MOVS     r4,#0
;;;467      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;468      
;;;469      uint32_t count = 0;
000006  2000              MOVS     r0,#0
;;;470      greset.d32 = 0;
000008  2200              MOVS     r2,#0
00000a  9200              STR      r2,[sp,#0]
;;;471      greset.b.txfflsh = 1;
00000c  9a00              LDR      r2,[sp,#0]
00000e  f0420220          ORR      r2,r2,#0x20
000012  9200              STR      r2,[sp,#0]
;;;472      greset.b.txfnum  = num;
000014  9a00              LDR      r2,[sp,#0]
000016  f361128a          BFI      r2,r1,#6,#5
00001a  9200              STR      r2,[sp,#0]
;;;473      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
00001c  9900              LDR      r1,[sp,#0]
00001e  68da              LDR      r2,[r3,#0xc]
000020  6111              STR      r1,[r2,#0x10]
;;;474      do
;;;475      {
;;;476        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;477        if (++count > 200000)
000022  4a07              LDR      r2,|L10.64|
000024  68d9              LDR      r1,[r3,#0xc]          ;473
                  |L10.38|
000026  690b              LDR      r3,[r1,#0x10]         ;476
000028  9300              STR      r3,[sp,#0]            ;476
00002a  1c40              ADDS     r0,r0,#1
00002c  4290              CMP      r0,r2
00002e  d802              BHI      |L10.54|
;;;478        {
;;;479          break;
;;;480        }
;;;481      }
;;;482      while (greset.b.txfflsh == 1);
000030  9b00              LDR      r3,[sp,#0]
000032  069b              LSLS     r3,r3,#26
000034  d4f7              BMI      |L10.38|
                  |L10.54|
;;;483      /* Wait for 3 PHY Clocks*/
;;;484      USB_OTG_BSP_uDelay(3);
000036  2003              MOVS     r0,#3
000038  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;485      return status;
00003c  4620              MOV      r0,r4
;;;486    }
00003e  bd38              POP      {r3-r5,pc}
;;;487    
                          ENDP

                  |L10.64|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;553    */
;;;554    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;555    {
;;;556      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;557    }
000008  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.USB_OTG_HC_DoPing||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_DoPing PROC
;;;1122   */
;;;1123   USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1124   {
;;;1125     USB_OTG_STS               status = USB_OTG_OK;
;;;1126     USB_OTG_HCCHAR_TypeDef    hcchar;
;;;1127     USB_OTG_HCTSIZn_TypeDef   hctsiz;  
;;;1128     
;;;1129     hctsiz.d32 = 0;
000002  2300              MOVS     r3,#0
;;;1130     hctsiz.b.dopng = 1;
000004  f04f4200          MOV      r2,#0x80000000
;;;1131     hctsiz.b.pktcnt = 1;
000008  2401              MOVS     r4,#1
00000a  f36442dc          BFI      r2,r4,#19,#10
;;;1132     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
00000e  eb000081          ADD      r0,r0,r1,LSL #2
000012  f8501f90          LDR      r1,[r0,#0x90]!
000016  610a              STR      r2,[r1,#0x10]
;;;1133     
;;;1134     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000018  6800              LDR      r0,[r0,#0]
00001a  6801              LDR      r1,[r0,#0]
;;;1135     hcchar.b.chen = 1;
00001c  f0414100          ORR      r1,r1,#0x80000000
;;;1136     hcchar.b.chdis = 0;
000020  f0214180          BIC      r1,r1,#0x40000000
;;;1137     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000024  6001              STR      r1,[r0,#0]
;;;1138     return status;  
000026  4618              MOV      r0,r3
;;;1139   }
000028  bd10              POP      {r4,pc}
;;;1140   
                          ENDP


                          AREA ||i.USB_OTG_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Halt PROC
;;;1083   */
;;;1084   USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1085   {
000002  b086              SUB      sp,sp,#0x18
;;;1086     USB_OTG_STS status = USB_OTG_OK;
000004  2300              MOVS     r3,#0
;;;1087     USB_OTG_HNPTXSTS_TypeDef            nptxsts;
;;;1088     USB_OTG_HPTXSTS_TypeDef             hptxsts;
;;;1089     USB_OTG_HCCHAR_TypeDef              hcchar;
;;;1090     
;;;1091     nptxsts.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9203              STR      r2,[sp,#0xc]
;;;1092     hptxsts.d32 = 0;
00000a  9201              STR      r2,[sp,#4]
;;;1093     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00000c  eb000181          ADD      r1,r0,r1,LSL #2
000010  f8d12090          LDR      r2,[r1,#0x90]
000014  6811              LDR      r1,[r2,#0]
;;;1094     hcchar.b.chen = 1;
000016  f0414100          ORR      r1,r1,#0x80000000
;;;1095     hcchar.b.chdis = 1;
00001a  f0414180          ORR      r1,r1,#0x40000000
00001e  9100              STR      r1,[sp,#0]
;;;1096     
;;;1097     /* Check for space in the request queue to issue the halt. */
;;;1098     if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
000020  f4112f40          TST      r1,#0xc0000
000024  d00b              BEQ      |L13.62|
000026  f3c14481          UBFX     r4,r1,#18,#2
00002a  2c02              CMP      r4,#2
00002c  d007              BEQ      |L13.62|
;;;1099     {
;;;1100       nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
;;;1101       if (nptxsts.b.nptxqspcavail == 0)
;;;1102       {
;;;1103         hcchar.b.chen = 0;
;;;1104       }
;;;1105     }
;;;1106     else
;;;1107     {
;;;1108       hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
00002e  6940              LDR      r0,[r0,#0x14]
000030  6900              LDR      r0,[r0,#0x10]
000032  9001              STR      r0,[sp,#4]
;;;1109       if (hptxsts.b.ptxqspcavail == 0)
000034  9801              LDR      r0,[sp,#4]
000036  f4100f7f          TST      r0,#0xff0000
00003a  d00b              BEQ      |L13.84|
00003c  e00d              B        |L13.90|
                  |L13.62|
00003e  68c0              LDR      r0,[r0,#0xc]          ;1100
000040  6ac0              LDR      r0,[r0,#0x2c]         ;1100
000042  9003              STR      r0,[sp,#0xc]          ;1100
000044  9803              LDR      r0,[sp,#0xc]          ;1101
000046  f4100f7f          TST      r0,#0xff0000          ;1101
00004a  d106              BNE      |L13.90|
00004c  f0214000          BIC      r0,r1,#0x80000000     ;1103
000050  9000              STR      r0,[sp,#0]            ;1103
000052  e002              B        |L13.90|
                  |L13.84|
;;;1110       {
;;;1111         hcchar.b.chen = 0;
000054  f0214000          BIC      r0,r1,#0x80000000
000058  9000              STR      r0,[sp,#0]
                  |L13.90|
;;;1112       }
;;;1113     }
;;;1114     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
00005a  9800              LDR      r0,[sp,#0]
00005c  6010              STR      r0,[r2,#0]
;;;1115     return status;
;;;1116   }
00005e  b006              ADD      sp,sp,#0x18
000060  4618              MOV      r0,r3                 ;1115
000062  bd10              POP      {r4,pc}
;;;1117   
                          ENDP


                          AREA ||i.USB_OTG_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Init PROC
;;;856    */
;;;857    USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b57f              PUSH     {r0-r6,lr}
;;;858    {
;;;859      USB_OTG_STS status = USB_OTG_OK;
000002  2500              MOVS     r5,#0
;;;860      uint32_t intr_enable = 0;
;;;861      USB_OTG_HCINTMSK_TypeDef  hcintmsk;
;;;862      USB_OTG_GINTMSK_TypeDef    gintmsk;
;;;863      USB_OTG_HCCHAR_TypeDef     hcchar;
;;;864      USB_OTG_HCINTn_TypeDef     hcint;
;;;865      
;;;866      
;;;867      gintmsk.d32 = 0;
000004  46ac              MOV      r12,r5
000006  f8cdc008          STR      r12,[sp,#8]
;;;868      hcintmsk.d32 = 0;
00000a  f8cdc00c          STR      r12,[sp,#0xc]
;;;869      hcchar.d32 = 0;
00000e  f8cdc004          STR      r12,[sp,#4]
;;;870      
;;;871      /* Clear old interrupt conditions for this host channel. */
;;;872      hcint.d32 = 0xFFFFFFFF;
000012  1e6a              SUBS     r2,r5,#1
000014  9200              STR      r2,[sp,#0]
;;;873      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
000016  eb000481          ADD      r4,r0,r1,LSL #2
00001a  f8d43090          LDR      r3,[r4,#0x90]
00001e  609a              STR      r2,[r3,#8]
;;;874      
;;;875      /* Enable channel interrupts required for this transfer. */
;;;876      hcintmsk.d32 = 0;
;;;877      
;;;878      if (pdev->cfg.dma_enable == 1)
000020  78c2              LDRB     r2,[r0,#3]
000022  2a01              CMP      r2,#1
000024  d101              BNE      |L14.42|
;;;879      {
;;;880        hcintmsk.b.ahberr = 1;
000026  2204              MOVS     r2,#4
000028  9203              STR      r2,[sp,#0xc]
                  |L14.42|
;;;881      }
;;;882      
;;;883      switch (pdev->host.hc[hc_num].ep_type) 
00002a  eb001241          ADD      r2,r0,r1,LSL #5
00002e  f89233b1          LDRB     r3,[r2,#0x3b1]
000032  b133              CBZ      r3,|L14.66|
000034  2b01              CMP      r3,#1
000036  d036              BEQ      |L14.166|
000038  2b02              CMP      r3,#2
00003a  d002              BEQ      |L14.66|
00003c  2b03              CMP      r3,#3
00003e  d142              BNE      |L14.198|
000040  e01c              B        |L14.124|
                  |L14.66|
;;;884      {
;;;885      case EP_TYPE_CTRL:
;;;886      case EP_TYPE_BULK:
;;;887        hcintmsk.b.xfercompl = 1;
000042  9b03              LDR      r3,[sp,#0xc]
000044  f0430301          ORR      r3,r3,#1
;;;888        hcintmsk.b.stall = 1;
000048  f0430308          ORR      r3,r3,#8
;;;889        hcintmsk.b.xacterr = 1;
00004c  f0430380          ORR      r3,r3,#0x80
;;;890        hcintmsk.b.datatglerr = 1;
000050  f4436380          ORR      r3,r3,#0x400
;;;891        hcintmsk.b.nak = 1;  
000054  f0430310          ORR      r3,r3,#0x10
000058  9303              STR      r3,[sp,#0xc]
;;;892        if (pdev->host.hc[hc_num].ep_is_in) 
00005a  f89263ae          LDRB     r6,[r2,#0x3ae]
00005e  b11e              CBZ      r6,|L14.104|
;;;893        {
;;;894          hcintmsk.b.bblerr = 1;
000060  f4437380          ORR      r3,r3,#0x100
000064  9303              STR      r3,[sp,#0xc]
000066  e02e              B        |L14.198|
                  |L14.104|
;;;895        } 
;;;896        else 
;;;897        {
;;;898          hcintmsk.b.nyet = 1;
000068  f0430340          ORR      r3,r3,#0x40
00006c  9303              STR      r3,[sp,#0xc]
;;;899          if (pdev->host.hc[hc_num].do_ping) 
00006e  f89263b0          LDRB     r6,[r2,#0x3b0]
000072  b346              CBZ      r6,|L14.198|
;;;900          {
;;;901            hcintmsk.b.ack = 1;
000074  f0430320          ORR      r3,r3,#0x20
000078  9303              STR      r3,[sp,#0xc]
00007a  e024              B        |L14.198|
                  |L14.124|
;;;902          }
;;;903        }
;;;904        break;
;;;905      case EP_TYPE_INTR:
;;;906        hcintmsk.b.xfercompl = 1;
00007c  9b03              LDR      r3,[sp,#0xc]
00007e  f0430301          ORR      r3,r3,#1
;;;907        hcintmsk.b.nak = 1;
000082  f0430310          ORR      r3,r3,#0x10
;;;908        hcintmsk.b.stall = 1;
000086  f0430308          ORR      r3,r3,#8
;;;909        hcintmsk.b.xacterr = 1;
00008a  f0430380          ORR      r3,r3,#0x80
;;;910        hcintmsk.b.datatglerr = 1;
00008e  f4436380          ORR      r3,r3,#0x400
;;;911        hcintmsk.b.frmovrun = 1;
000092  f4437300          ORR      r3,r3,#0x200
000096  9303              STR      r3,[sp,#0xc]
;;;912        
;;;913        if (pdev->host.hc[hc_num].ep_is_in) 
000098  f89263ae          LDRB     r6,[r2,#0x3ae]
00009c  b19e              CBZ      r6,|L14.198|
;;;914        {
;;;915          hcintmsk.b.bblerr = 1;
00009e  f4437380          ORR      r3,r3,#0x100
0000a2  9303              STR      r3,[sp,#0xc]
0000a4  e00f              B        |L14.198|
                  |L14.166|
;;;916        }
;;;917        
;;;918        break;
;;;919      case EP_TYPE_ISOC:
;;;920        hcintmsk.b.xfercompl = 1;
0000a6  9b03              LDR      r3,[sp,#0xc]
0000a8  f0430301          ORR      r3,r3,#1
;;;921        hcintmsk.b.frmovrun = 1;
0000ac  f4437300          ORR      r3,r3,#0x200
;;;922        hcintmsk.b.ack = 1;
0000b0  f0430320          ORR      r3,r3,#0x20
0000b4  9303              STR      r3,[sp,#0xc]
;;;923        
;;;924        if (pdev->host.hc[hc_num].ep_is_in) 
0000b6  f89263ae          LDRB     r6,[r2,#0x3ae]
0000ba  b126              CBZ      r6,|L14.198|
;;;925        {
;;;926          hcintmsk.b.xacterr = 1;
0000bc  f0430380          ORR      r3,r3,#0x80
;;;927          hcintmsk.b.bblerr = 1;
0000c0  f4437380          ORR      r3,r3,#0x100
0000c4  9303              STR      r3,[sp,#0xc]
                  |L14.198|
;;;928        }
;;;929        break;
;;;930      }
;;;931      
;;;932      
;;;933      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
0000c6  f8d46090          LDR      r6,[r4,#0x90]
0000ca  9b03              LDR      r3,[sp,#0xc]
0000cc  60f3              STR      r3,[r6,#0xc]
;;;934      
;;;935      
;;;936      /* Enable the top level host channel interrupt. */
;;;937      intr_enable = (1 << hc_num);
0000ce  2301              MOVS     r3,#1
0000d0  408b              LSLS     r3,r3,r1
;;;938      USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
0000d2  6941              LDR      r1,[r0,#0x14]
0000d4  698e              LDR      r6,[r1,#0x18]
0000d6  431e              ORRS     r6,r6,r3
0000d8  618e              STR      r6,[r1,#0x18]
;;;939      
;;;940      /* Make sure host channel interrupts are enabled. */
;;;941      gintmsk.b.hcintr = 1;
0000da  f04f7100          MOV      r1,#0x2000000
0000de  9102              STR      r1,[sp,#8]
;;;942      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
0000e0  68c0              LDR      r0,[r0,#0xc]
0000e2  6981              LDR      r1,[r0,#0x18]
0000e4  f0417100          ORR      r1,r1,#0x2000000
0000e8  6181              STR      r1,[r0,#0x18]
;;;943      
;;;944      /* Program the HCCHAR register */
;;;945      hcchar.d32 = 0;
;;;946      hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
0000ea  f89203ac          LDRB     r0,[r2,#0x3ac]
0000ee  f3605c9c          BFI      r12,r0,#22,#7
;;;947      hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
0000f2  f89203ad          LDRB     r0,[r2,#0x3ad]
0000f6  f3602cce          BFI      r12,r0,#11,#4
;;;948      hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
0000fa  f89203ae          LDRB     r0,[r2,#0x3ae]
0000fe  f3603ccf          BFI      r12,r0,#15,#1
000102  f8cdc004          STR      r12,[sp,#4]
;;;949      hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
000106  f89203af          LDRB     r0,[r2,#0x3af]
00010a  2802              CMP      r0,#2
00010c  d00d              BEQ      |L14.298|
00010e  f42c3000          BIC      r0,r12,#0x20000
                  |L14.274|
;;;950      hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
000112  f89213b1          LDRB     r1,[r2,#0x3b1]
000116  f3614093          BFI      r0,r1,#18,#2
;;;951      hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
00011a  f8b223b2          LDRH     r2,[r2,#0x3b2]
00011e  f362000a          BFI      r0,r2,#0,#11
000122  9001              STR      r0,[sp,#4]
;;;952      if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
000124  2903              CMP      r1,#3
000126  d003              BEQ      |L14.304|
000128  e005              B        |L14.310|
                  |L14.298|
00012a  f44c3000          ORR      r0,r12,#0x20000       ;949
00012e  e7f0              B        |L14.274|
                  |L14.304|
;;;953      {
;;;954        hcchar.b.oddfrm  = 1;
000130  f0405000          ORR      r0,r0,#0x20000000
000134  9001              STR      r0,[sp,#4]
                  |L14.310|
;;;955      }
;;;956      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000136  f8d41090          LDR      r1,[r4,#0x90]
00013a  9801              LDR      r0,[sp,#4]
00013c  6008              STR      r0,[r1,#0]
;;;957      return status;
;;;958    }
00013e  b004              ADD      sp,sp,#0x10
000140  4628              MOV      r0,r5                 ;957
000142  bd70              POP      {r4-r6,pc}
;;;959    
                          ENDP


                          AREA ||i.USB_OTG_HC_StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_StartXfer PROC
;;;966    */
;;;967    USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;968    {
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;969      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;970      USB_OTG_HCCHAR_TypeDef   hcchar;
;;;971      USB_OTG_HCTSIZn_TypeDef  hctsiz;
;;;972      USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
;;;973      USB_OTG_HPTXSTS_TypeDef  hptxsts; 
;;;974      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;975      uint16_t                 len_words = 0;   
;;;976      
;;;977      uint16_t num_packets;
;;;978      uint16_t max_hc_pkt_count;
;;;979      
;;;980      max_hc_pkt_count = 256;
000008  f44f7c80          MOV      r12,#0x100
;;;981      hctsiz.d32 = 0;
00000c  2200              MOVS     r2,#0
00000e  9206              STR      r2,[sp,#0x18]
;;;982      hcchar.d32 = 0;
000010  9207              STR      r2,[sp,#0x1c]
;;;983      intmsk.d32 = 0;
000012  9200              STR      r2,[sp,#0]
;;;984      
;;;985      /* Compute the expected number of packets associated to the transfer */
;;;986      if (pdev->host.hc[hc_num].xfer_len > 0)
000014  eb051441          ADD      r4,r5,r1,LSL #5
000018  f8d473bc          LDR      r7,[r4,#0x3bc]
00001c  b16f              CBZ      r7,|L15.58|
;;;987      {
;;;988        num_packets = (pdev->host.hc[hc_num].xfer_len + \
00001e  f8b433b2          LDRH     r3,[r4,#0x3b2]
000022  18f8              ADDS     r0,r7,r3
000024  1e40              SUBS     r0,r0,#1
000026  fbb0f0f3          UDIV     r0,r0,r3
00002a  b280              UXTH     r0,r0
;;;989          pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
;;;990        
;;;991        if (num_packets > max_hc_pkt_count)
00002c  4560              CMP      r0,r12
00002e  d905              BLS      |L15.60|
;;;992        {
;;;993          num_packets = max_hc_pkt_count;
000030  4660              MOV      r0,r12
;;;994          pdev->host.hc[hc_num].xfer_len = num_packets * \
000032  021b              LSLS     r3,r3,#8
000034  f8c433bc          STR      r3,[r4,#0x3bc]
000038  e000              B        |L15.60|
                  |L15.58|
;;;995            pdev->host.hc[hc_num].max_packet;
;;;996        }
;;;997      }
;;;998      else
;;;999      {
;;;1000       num_packets = 1;
00003a  2001              MOVS     r0,#1
                  |L15.60|
;;;1001     }
;;;1002     if (pdev->host.hc[hc_num].ep_is_in)
00003c  f89433ae          LDRB     r3,[r4,#0x3ae]
000040  b123              CBZ      r3,|L15.76|
;;;1003     {
;;;1004       pdev->host.hc[hc_num].xfer_len = num_packets * \
000042  f8b433b2          LDRH     r3,[r4,#0x3b2]
000046  4343              MULS     r3,r0,r3
000048  f8c433bc          STR      r3,[r4,#0x3bc]
                  |L15.76|
;;;1005         pdev->host.hc[hc_num].max_packet;
;;;1006     }
;;;1007     /* Initialize the HCTSIZn register */
;;;1008     hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
00004c  f8d433bc          LDR      r3,[r4,#0x3bc]
000050  f3630212          BFI      r2,r3,#0,#19
;;;1009     hctsiz.b.pktcnt = num_packets;
000054  f36042dc          BFI      r2,r0,#19,#10
;;;1010     hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
000058  f89403b4          LDRB     r0,[r4,#0x3b4]
00005c  f360725e          BFI      r2,r0,#29,#2
000060  9206              STR      r2,[sp,#0x18]
;;;1011     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000062  eb050381          ADD      r3,r5,r1,LSL #2
000066  f8d30090          LDR      r0,[r3,#0x90]
00006a  6102              STR      r2,[r0,#0x10]
;;;1012     
;;;1013     if (pdev->cfg.dma_enable == 1)
00006c  78e8              LDRB     r0,[r5,#3]
00006e  2801              CMP      r0,#1
000070  d104              BNE      |L15.124|
;;;1014     {
;;;1015       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
000072  f8d32090          LDR      r2,[r3,#0x90]
000076  f8d403b8          LDR      r0,[r4,#0x3b8]
00007a  6150              STR      r0,[r2,#0x14]
                  |L15.124|
;;;1016     }
;;;1017     
;;;1018     
;;;1019     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00007c  f8530f90          LDR      r0,[r3,#0x90]!
000080  6802              LDR      r2,[r0,#0]
;;;1020     hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       USB_OTG_IsEvenFrame
000088  f360725d          BFI      r2,r0,#29,#1
;;;1021     
;;;1022     /* Set host channel enable */
;;;1023     hcchar.b.chen = 1;
00008c  f0424000          ORR      r0,r2,#0x80000000
;;;1024     hcchar.b.chdis = 0;
000090  f0204080          BIC      r0,r0,#0x40000000
000094  9007              STR      r0,[sp,#0x1c]
;;;1025     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000096  681a              LDR      r2,[r3,#0]
000098  6010              STR      r0,[r2,#0]
;;;1026     
;;;1027     if (pdev->cfg.dma_enable == 0) /* Slave mode */
00009a  78e8              LDRB     r0,[r5,#3]
00009c  bbe0              CBNZ     r0,|L15.280|
;;;1028     {  
;;;1029       if((pdev->host.hc[hc_num].ep_is_in == 0) && 
00009e  f89403ae          LDRB     r0,[r4,#0x3ae]
0000a2  bbc8              CBNZ     r0,|L15.280|
;;;1030          (pdev->host.hc[hc_num].xfer_len > 0))
0000a4  f8d433bc          LDR      r3,[r4,#0x3bc]
0000a8  b3b3              CBZ      r3,|L15.280|
;;;1031       {
;;;1032         switch(pdev->host.hc[hc_num].ep_type) 
0000aa  f89403b1          LDRB     r0,[r4,#0x3b1]
0000ae  b130              CBZ      r0,|L15.190|
0000b0  2801              CMP      r0,#1
0000b2  d015              BEQ      |L15.224|
0000b4  2802              CMP      r0,#2
0000b6  d002              BEQ      |L15.190|
0000b8  2803              CMP      r0,#3
0000ba  d123              BNE      |L15.260|
0000bc  e010              B        |L15.224|
                  |L15.190|
;;;1033         {
;;;1034           /* Non periodic transfer */
;;;1035         case EP_TYPE_CTRL:
;;;1036         case EP_TYPE_BULK:
;;;1037           
;;;1038           hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
0000be  68e8              LDR      r0,[r5,#0xc]
0000c0  6ac2              LDR      r2,[r0,#0x2c]
0000c2  9203              STR      r2,[sp,#0xc]
;;;1039           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000c4  1cdb              ADDS     r3,r3,#3
0000c6  f3c3028f          UBFX     r2,r3,#2,#16
;;;1040           
;;;1041           /* check if there is enough space in FIFO space */
;;;1042           if(len_words > hnptxsts.b.nptxfspcavail)
0000ca  9b03              LDR      r3,[sp,#0xc]
0000cc  b29b              UXTH     r3,r3
0000ce  4293              CMP      r3,r2
0000d0  d218              BCS      |L15.260|
;;;1043           {
;;;1044             /* need to process data in nptxfempty interrupt */
;;;1045             intmsk.b.nptxfempty = 1;
0000d2  2220              MOVS     r2,#0x20
0000d4  9200              STR      r2,[sp,#0]
;;;1046             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000d6  6982              LDR      r2,[r0,#0x18]
0000d8  f0420220          ORR      r2,r2,#0x20
0000dc  6182              STR      r2,[r0,#0x18]
0000de  e011              B        |L15.260|
                  |L15.224|
;;;1047           }
;;;1048           
;;;1049           break;
;;;1050           /* Periodic transfer */
;;;1051         case EP_TYPE_INTR:
;;;1052         case EP_TYPE_ISOC:
;;;1053           hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
0000e0  6968              LDR      r0,[r5,#0x14]
0000e2  6900              LDR      r0,[r0,#0x10]
0000e4  9001              STR      r0,[sp,#4]
;;;1054           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000e6  1cdb              ADDS     r3,r3,#3
0000e8  f3c3008f          UBFX     r0,r3,#2,#16
;;;1055           /* check if there is enough space in FIFO space */
;;;1056           if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
0000ec  9a01              LDR      r2,[sp,#4]
0000ee  b292              UXTH     r2,r2
0000f0  4282              CMP      r2,r0
0000f2  d207              BCS      |L15.260|
;;;1057           {
;;;1058             /* need to process data in ptxfempty interrupt */
;;;1059             intmsk.b.ptxfempty = 1;
0000f4  f04f6080          MOV      r0,#0x4000000
0000f8  9000              STR      r0,[sp,#0]
;;;1060             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000fa  68e8              LDR      r0,[r5,#0xc]
0000fc  6982              LDR      r2,[r0,#0x18]
0000fe  f0426280          ORR      r2,r2,#0x4000000
000102  6182              STR      r2,[r0,#0x18]
                  |L15.260|
;;;1061           }
;;;1062           break;
;;;1063           
;;;1064         default:
;;;1065           break;
;;;1066         }
;;;1067         
;;;1068         /* Write packet into the Tx FIFO. */
;;;1069         USB_OTG_WritePacket(pdev, 
000104  f8d403bc          LDR      r0,[r4,#0x3bc]
000108  460a              MOV      r2,r1
00010a  b283              UXTH     r3,r0
00010c  f8d403b8          LDR      r0,[r4,#0x3b8]
000110  4601              MOV      r1,r0
000112  4628              MOV      r0,r5
000114  f7fffffe          BL       USB_OTG_WritePacket
                  |L15.280|
;;;1070                             pdev->host.hc[hc_num].xfer_buff , 
;;;1071                             hc_num, pdev->host.hc[hc_num].xfer_len);
;;;1072       }
;;;1073     }
;;;1074     return status;
;;;1075   }
000118  b008              ADD      sp,sp,#0x20
00011a  4630              MOV      r0,r6                 ;1074
00011c  bdf0              POP      {r4-r7,pc}
;;;1076   
                          ENDP


                          AREA ||i.USB_OTG_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitFSLSPClkSel PROC
;;;789    */
;;;790    void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
000000  6940              LDR      r0,[r0,#0x14]
;;;791    {
;;;792      USB_OTG_HCFG_TypeDef   hcfg;
;;;793      
;;;794      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000002  6802              LDR      r2,[r0,#0]
;;;795      hcfg.b.fslspclksel = freq;
000004  f3610201          BFI      r2,r1,#0,#2
;;;796      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000008  6002              STR      r2,[r0,#0]
;;;797    }
00000a  4770              BX       lr
;;;798    
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;564    */
;;;565    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;566    {
;;;567      return (USB_OTG_GetMode(pdev) != HOST_MODE);
000002  f7fffffe          BL       USB_OTG_GetMode
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L17.14|
00000a  2001              MOVS     r0,#1
;;;568    }
00000c  bd00              POP      {pc}
                  |L17.14|
00000e  2000              MOVS     r0,#0                 ;567
000010  bd00              POP      {pc}
;;;569    
                          ENDP


                          AREA ||i.USB_OTG_IsEvenFrame||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsEvenFrame PROC
;;;715    */
;;;716    uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  6940              LDR      r0,[r0,#0x14]
;;;717    {
;;;718      return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
000002  6880              LDR      r0,[r0,#8]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;719    }
00000a  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;575    */
;;;576    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;577    {
;;;578      return (USB_OTG_GetMode(pdev) == HOST_MODE);
000002  f7fffffe          BL       USB_OTG_GetMode
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L19.12|
00000a  2000              MOVS     r0,#0
                  |L19.12|
;;;579    }
00000c  bd00              POP      {pc}
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;586    */
;;;587    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;588    {
;;;589      uint32_t v = 0;
;;;590      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000002  6941              LDR      r1,[r0,#0x14]
;;;591      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000004  6980              LDR      r0,[r0,#0x18]
000006  4008              ANDS     r0,r0,r1
;;;592      return v;
;;;593    }
000008  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_ReadHPRT0||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHPRT0 PROC
;;;804    */
;;;805    uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
000000  f8d000cc          LDR      r0,[r0,#0xcc]
;;;806    {
;;;807      USB_OTG_HPRT0_TypeDef  hprt0;
;;;808      
;;;809      hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  6800              LDR      r0,[r0,#0]
;;;810      hprt0.b.prtena = 0;
000006  f0200004          BIC      r0,r0,#4
;;;811      hprt0.b.prtconndet = 0;
00000a  f0200002          BIC      r0,r0,#2
;;;812      hprt0.b.prtenchng = 0;
00000e  f0200008          BIC      r0,r0,#8
;;;813      hprt0.b.prtovrcurrchng = 0;
000012  f0200020          BIC      r0,r0,#0x20
;;;814      return hprt0.d32;
;;;815    }
000016  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.USB_OTG_ReadHostAllChannels_intr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHostAllChannels_intr PROC
;;;822    */
;;;823    uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
000000  6940              LDR      r0,[r0,#0x14]
;;;824    {
;;;825      return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
000002  6940              LDR      r0,[r0,#0x14]
;;;826    }
000004  4770              BX       lr
;;;827    
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;600    */
;;;601    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;602    {
;;;603      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  6840              LDR      r0,[r0,#4]
;;;604    }
000004  4770              BX       lr
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;196    */
;;;197    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;198                             uint8_t *dest, 
;;;199                             uint16_t len)
;;;200    {
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
;;;201      uint32_t i=0;
000006  2100              MOVS     r1,#0
;;;202      uint32_t count32b = (len + 3) / 4;
000008  1cd2              ADDS     r2,r2,#3
00000a  0893              LSRS     r3,r2,#2
;;;203      
;;;204      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
00000c  f8d420d0          LDR      r2,[r4,#0xd0]
;;;205      
;;;206      for ( i = 0; i < count32b; i++, dest += 4 )
000010  e003              B        |L24.26|
                  |L24.18|
;;;207      {
;;;208        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000012  6814              LDR      r4,[r2,#0]
000014  6004              STR      r4,[r0,#0]
000016  1c49              ADDS     r1,r1,#1              ;206
000018  1d00              ADDS     r0,r0,#4              ;206
                  |L24.26|
00001a  4299              CMP      r1,r3                 ;206
00001c  d3f9              BCC      |L24.18|
;;;209        
;;;210      }
;;;211      return ((void *)dest);
;;;212    }
00001e  bd10              POP      {r4,pc}
;;;213    
                          ENDP


                          AREA ||i.USB_OTG_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_OTG_ResetPort PROC
;;;835    */
;;;836    uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;837    {
000002  4605              MOV      r5,r0
;;;838      USB_OTG_HPRT0_TypeDef  hprt0;
;;;839      
;;;840      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;841      hprt0.b.prtrst = 1;
00000a  f4407480          ORR      r4,r0,#0x100
;;;842      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00000e  f8550fcc          LDR      r0,[r5,#0xcc]!
000012  6004              STR      r4,[r0,#0]
;;;843      USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
000014  200a              MOVS     r0,#0xa
000016  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;844      hprt0.b.prtrst = 0;
00001a  f4247080          BIC      r0,r4,#0x100
;;;845      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00001e  6829              LDR      r1,[r5,#0]
000020  6008              STR      r0,[r1,#0]
;;;846      USB_OTG_BSP_mDelay (20);   
000022  2014              MOVS     r0,#0x14
000024  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;847      return 1;
000028  2001              MOVS     r0,#1
;;;848    }
00002a  bd70              POP      {r4-r6,pc}
;;;849    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;220    */
;;;221    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;222                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;223    {
;;;224      uint32_t i , baseAddress = 0;
000002  2200              MOVS     r2,#0
;;;225      USB_OTG_STS status = USB_OTG_OK;
000004  4694              MOV      r12,r2
;;;226      
;;;227      pdev->cfg.dma_enable       = 0;
000006  2400              MOVS     r4,#0
000008  70c4              STRB     r4,[r0,#3]
;;;228      
;;;229      /* at startup the core is in FS mode */
;;;230      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
00000a  2301              MOVS     r3,#1
00000c  7083              STRB     r3,[r0,#2]
;;;231      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
00000e  2540              MOVS     r5,#0x40
000010  8085              STRH     r5,[r0,#4]
;;;232      
;;;233      /* initialize device cfg following its address */
;;;234      if (coreID == USB_OTG_FS_CORE_ID)
;;;235      {
;;;236        baseAddress                = USB_OTG_FS_BASE_ADDR;
;;;237        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
;;;238        pdev->cfg.host_channels    = 8 ;
;;;239        pdev->cfg.dev_endpoints    = 4 ;
;;;240        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
;;;241        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
000012  2502              MOVS     r5,#2
000014  2901              CMP      r1,#1                 ;234
000016  d001              BEQ      |L26.28|
;;;242        
;;;243    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;244        pdev->cfg.Sof_output       = 1;    
;;;245    #endif 
;;;246        
;;;247    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;248        pdev->cfg.low_power        = 1;    
;;;249    #endif     
;;;250      }
;;;251      else if (coreID == USB_OTG_HS_CORE_ID)
000018  b159              CBZ      r1,|L26.50|
00001a  e015              B        |L26.72|
                  |L26.28|
00001c  f04f42a0          MOV      r2,#0x50000000        ;236
000020  72c3              STRB     r3,[r0,#0xb]          ;237
000022  2108              MOVS     r1,#8                 ;238
000024  7001              STRB     r1,[r0,#0]            ;238
000026  2104              MOVS     r1,#4                 ;239
000028  7041              STRB     r1,[r0,#1]            ;239
00002a  1591              ASRS     r1,r2,#22             ;240
00002c  80c1              STRH     r1,[r0,#6]            ;240
00002e  7205              STRB     r5,[r0,#8]            ;241
000030  e00a              B        |L26.72|
                  |L26.50|
;;;252      {
;;;253        baseAddress                = USB_OTG_HS_BASE_ADDR;
000032  4a23              LDR      r2,|L26.192|
;;;254        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000034  72c4              STRB     r4,[r0,#0xb]
;;;255        pdev->cfg.host_channels    = 12 ;
000036  210c              MOVS     r1,#0xc
000038  7001              STRB     r1,[r0,#0]
;;;256        pdev->cfg.dev_endpoints    = 6 ;
00003a  2106              MOVS     r1,#6
00003c  7041              STRB     r1,[r0,#1]
;;;257        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
00003e  f44f61a0          MOV      r1,#0x500
000042  80c1              STRH     r1,[r0,#6]
;;;258        
;;;259    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;260        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;261    #else    
;;;262    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;263        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
000044  7205              STRB     r5,[r0,#8]
;;;264    #endif  
;;;265    #endif      
;;;266        
;;;267    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;268        pdev->cfg.dma_enable       = 1;    
000046  70c3              STRB     r3,[r0,#3]
                  |L26.72|
;;;269    #endif
;;;270        
;;;271    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;272        pdev->cfg.Sof_output       = 1;    
;;;273    #endif 
;;;274        
;;;275    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;276        pdev->cfg.low_power        = 1;    
;;;277    #endif 
;;;278        
;;;279      }
;;;280      
;;;281      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
000048  60c2              STR      r2,[r0,#0xc]
;;;282        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;283      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
00004a  f5026100          ADD      r1,r2,#0x800
00004e  6101              STR      r1,[r0,#0x10]
;;;284        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;285      
;;;286      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000050  2100              MOVS     r1,#0
000052  e00a              B        |L26.106|
                  |L26.84|
;;;287      {
;;;288        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
000054  eb021341          ADD      r3,r2,r1,LSL #5
000058  eb000481          ADD      r4,r0,r1,LSL #2
00005c  f5036510          ADD      r5,r3,#0x900
000060  61a5              STR      r5,[r4,#0x18]
;;;289          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;290            (i * USB_OTG_EP_REG_OFFSET));
;;;291        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
000062  f5036330          ADD      r3,r3,#0xb00
000066  6563              STR      r3,[r4,#0x54]
000068  1c49              ADDS     r1,r1,#1              ;286
                  |L26.106|
00006a  7843              LDRB     r3,[r0,#1]            ;286
00006c  428b              CMP      r3,r1                 ;286
00006e  d8f1              BHI      |L26.84|
;;;292          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;293            (i * USB_OTG_EP_REG_OFFSET));
;;;294      }
;;;295      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
000070  f5026180          ADD      r1,r2,#0x400
000074  6141              STR      r1,[r0,#0x14]
;;;296        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;297      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
000076  3140              ADDS     r1,r1,#0x40
000078  f8c010cc          STR      r1,[r0,#0xcc]
;;;298      
;;;299      for (i = 0; i < pdev->cfg.host_channels; i++)
00007c  2100              MOVS     r1,#0
00007e  e008              B        |L26.146|
                  |L26.128|
;;;300      {
;;;301        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
000080  eb021341          ADD      r3,r2,r1,LSL #5
000084  eb000481          ADD      r4,r0,r1,LSL #2
000088  f50363a0          ADD      r3,r3,#0x500
00008c  f8c43090          STR      r3,[r4,#0x90]
000090  1c49              ADDS     r1,r1,#1              ;299
                  |L26.146|
000092  7803              LDRB     r3,[r0,#0]            ;299
000094  428b              CMP      r3,r1                 ;299
000096  d8f3              BHI      |L26.128|
;;;302          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;303            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;304      }
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
000098  2100              MOVS     r1,#0
00009a  e008              B        |L26.174|
                  |L26.156|
;;;306      {
;;;307        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
00009c  eb023301          ADD      r3,r2,r1,LSL #12
0000a0  eb000481          ADD      r4,r0,r1,LSL #2
0000a4  f5035380          ADD      r3,r3,#0x1000
0000a8  f8c430d0          STR      r3,[r4,#0xd0]
0000ac  1c49              ADDS     r1,r1,#1              ;305
                  |L26.174|
0000ae  7803              LDRB     r3,[r0,#0]            ;305
0000b0  428b              CMP      r3,r1                 ;305
0000b2  d8f3              BHI      |L26.156|
;;;308          (i * USB_OTG_DATA_FIFO_SIZE));
;;;309      }
;;;310      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000b4  f5026260          ADD      r2,r2,#0xe00
0000b8  f8c0210c          STR      r2,[r0,#0x10c]
;;;311      
;;;312      return status;
0000bc  4660              MOV      r0,r12
;;;313    }
0000be  bd30              POP      {r4,r5,pc}
;;;314    
                          ENDP

                  |L26.192|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;523    */
;;;524    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b538              PUSH     {r3-r5,lr}
;;;525    {
;;;526      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;527      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;528      
;;;529      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000004  68c2              LDR      r2,[r0,#0xc]
000006  68d0              LDR      r0,[r2,#0xc]
;;;530      
;;;531      usbcfg.b.force_host = 0;
000008  f0205000          BIC      r0,r0,#0x20000000
;;;532      usbcfg.b.force_dev = 0;
00000c  f0204080          BIC      r0,r0,#0x40000000
000010  9000              STR      r0,[sp,#0]
;;;533      
;;;534      if ( mode == HOST_MODE)
000012  2901              CMP      r1,#1
000014  d001              BEQ      |L27.26|
;;;535      {
;;;536        usbcfg.b.force_host = 1;
;;;537      }
;;;538      else if ( mode == DEVICE_MODE)
000016  b121              CBZ      r1,|L27.34|
000018  e006              B        |L27.40|
                  |L27.26|
00001a  f0405000          ORR      r0,r0,#0x20000000     ;536
00001e  9000              STR      r0,[sp,#0]            ;536
000020  e002              B        |L27.40|
                  |L27.34|
;;;539      {
;;;540        usbcfg.b.force_dev = 1;
000022  f0404080          ORR      r0,r0,#0x40000000
000026  9000              STR      r0,[sp,#0]
                  |L27.40|
;;;541      }
;;;542      
;;;543      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
000028  9800              LDR      r0,[sp,#0]
00002a  60d0              STR      r0,[r2,#0xc]
;;;544      USB_OTG_BSP_mDelay(50);
00002c  2032              MOVS     r0,#0x32
00002e  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;545      return status;
000032  4620              MOV      r0,r4
;;;546    }
000034  bd38              POP      {r3-r5,pc}
;;;547    
                          ENDP


                          AREA ||i.USB_OTG_StopHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopHost PROC
;;;1145   */
;;;1146   void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;1147   {
000002  4604              MOV      r4,r0
;;;1148     USB_OTG_HCCHAR_TypeDef  hcchar;
;;;1149     uint32_t                i;
;;;1150     
;;;1151     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
000004  2000              MOVS     r0,#0
000006  6961              LDR      r1,[r4,#0x14]
000008  6188              STR      r0,[r1,#0x18]
;;;1152     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
00000a  6961              LDR      r1,[r4,#0x14]
00000c  1e40              SUBS     r0,r0,#1
00000e  6148              STR      r0,[r1,#0x14]
;;;1153     /* Flush out any leftover queued requests. */
;;;1154     
;;;1155     for (i = 0; i < pdev->cfg.host_channels; i++)
000010  2000              MOVS     r0,#0
000012  e00d              B        |L28.48|
                  |L28.20|
;;;1156     {
;;;1157       hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
000014  eb040180          ADD      r1,r4,r0,LSL #2
000018  f8d12090          LDR      r2,[r1,#0x90]
00001c  6811              LDR      r1,[r2,#0]
;;;1158       hcchar.b.chen = 0;
00001e  f0214100          BIC      r1,r1,#0x80000000
;;;1159       hcchar.b.chdis = 1;
000022  f0414180          ORR      r1,r1,#0x40000000
;;;1160       hcchar.b.epdir = 0;
000026  f4214100          BIC      r1,r1,#0x8000
00002a  9100              STR      r1,[sp,#0]
;;;1161       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
00002c  6011              STR      r1,[r2,#0]
00002e  1c40              ADDS     r0,r0,#1              ;1155
                  |L28.48|
000030  7821              LDRB     r1,[r4,#0]            ;1155
000032  4281              CMP      r1,r0                 ;1155
000034  d8ee              BHI      |L28.20|
;;;1162     }
;;;1163     
;;;1164     /* Flush the FIFO */
;;;1165     USB_OTG_FlushRxFifo(pdev);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1166     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
00003c  4620              MOV      r0,r4
00003e  e8bd4038          POP      {r3-r5,lr}
000042  2110              MOVS     r1,#0x10
000044  f7ffbffe          B.W      USB_OTG_FlushTxFifo
;;;1167   }
;;;1168   #endif
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
000002  4605              MOV      r5,r0
;;;173      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;174      if (pdev->cfg.dma_enable == 0)
000006  78ec              LDRB     r4,[r5,#3]
000008  2c00              CMP      r4,#0
00000a  d10c              BNE      |L29.38|
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
00000c  1cdb              ADDS     r3,r3,#3
00000e  089b              LSRS     r3,r3,#2
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
000010  eb050282          ADD      r2,r5,r2,LSL #2
000014  f8d220d0          LDR      r2,[r2,#0xd0]
;;;181        for (i = 0; i < count32b; i++, src+=4)
000018  e003              B        |L29.34|
                  |L29.26|
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
00001a  680d              LDR      r5,[r1,#0]
00001c  6015              STR      r5,[r2,#0]
00001e  1c64              ADDS     r4,r4,#1              ;181
000020  1d09              ADDS     r1,r1,#4              ;181
                  |L29.34|
000022  429c              CMP      r4,r3                 ;181
000024  d3f9              BCC      |L29.26|
                  |L29.38|
;;;184        }
;;;185      }
;;;186      return status;
;;;187    }
000026  bd30              POP      {r4,r5,pc}
;;;188    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_OTG_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 128
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
