; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_usart.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_usart.crf ..\Libraries\FWlib\src\stm32f4xx_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1343     */
;;;1344   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  058a              LSLS     r2,r1,#22
;;;1345   {
;;;1346     /* Check the parameters */
;;;1347     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1348     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1349   
;;;1350     /* The CTS flag is not available for UART4 and UART5 */
;;;1351     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
;;;1352     {
;;;1353       assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1354     } 
;;;1355          
;;;1356     USARTx->SR = (uint16_t)~USART_FLAG;
000002  43c9              MVNS     r1,r1
000004  8001              STRH     r1,[r0,#0]
;;;1357   }
000006  4770              BX       lr
;;;1358   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1451     */
;;;1452   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  f640126a          MOV      r2,#0x96a
;;;1453   {
;;;1454     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1457     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1458   
;;;1459     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1460     if (USART_IT == USART_IT_CTS)
;;;1461     {
;;;1462       assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1463     } 
;;;1464       
;;;1465     bitpos = USART_IT >> 0x08;
000004  0a0a              LSRS     r2,r1,#8
;;;1466     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
;;;1467     USARTx->SR = (uint16_t)~itmask;
00000a  43c9              MVNS     r1,r1
00000c  8001              STRH     r1,[r0,#0]
;;;1468   }
00000e  4770              BX       lr
;;;1469   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;378      */
;;;379    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381      uint32_t tmpreg = 0x00;
;;;382      /* Check the parameters */
;;;383      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;384      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;385      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;386      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;387      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;388      
;;;389    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;390      tmpreg = USARTx->CR2;
000002  8a02              LDRH     r2,[r0,#0x10]
;;;391      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;392      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
000004  f4226370          BIC      r3,r2,#0xf00
;;;393      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;394      /* Set CLKEN bit according to USART_Clock value */
;;;395      /* Set CPOL bit according to USART_CPOL value */
;;;396      /* Set CPHA bit according to USART_CPHA value */
;;;397      /* Set LBCL bit according to USART_LastBit value */
;;;398      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000008  880a              LDRH     r2,[r1,#0]
00000a  884c              LDRH     r4,[r1,#2]
00000c  4322              ORRS     r2,r2,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  88c9              LDRH     r1,[r1,#6]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;399                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;400      /* Write to USART CR2 */
;;;401      USARTx->CR2 = (uint16_t)tmpreg;
000018  8202              STRH     r2,[r0,#0x10]
;;;402    }
00001a  bd10              POP      {r4,pc}
;;;403    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;409      */
;;;410    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;411    {
;;;412      /* USART_ClockInitStruct members default value */
;;;413      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;414      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;415      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;416      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;417    }
00000a  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;426      */
;;;427    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;428    {
;;;429      /* Check the parameters */
;;;430      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;431      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;432      
;;;433      if (NewState != DISABLE)
;;;434      {
;;;435        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;436        USARTx->CR1 |= USART_CR1_UE;
000002  8981              LDRH     r1,[r0,#0xc]
000004  f4415100          ORR      r1,r1,#0x2000
000008  8181              STRH     r1,[r0,#0xc]
;;;437      }
;;;438      else
;;;439      {
;;;440        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;441        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
;;;442      }
;;;443    }
00000a  4770              BX       lr
                  |L5.12|
00000c  8981              LDRH     r1,[r0,#0xc]          ;441
00000e  f4215100          BIC      r1,r1,#0x2000         ;441
000012  8181              STRH     r1,[r0,#0xc]          ;441
000014  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;1098     */
;;;1099   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  b11a              CBZ      r2,|L6.10|
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1103     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1104     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1105   
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1109          DMAR bits in the USART CR3 register */
;;;1110       USARTx->CR3 |= USART_DMAReq;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  430a              ORRS     r2,r2,r1
000006  8282              STRH     r2,[r0,#0x14]
;;;1111     }
;;;1112     else
;;;1113     {
;;;1114       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1115          DMAR bits in the USART CR3 register */
;;;1116       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
;;;1117     }
;;;1118   }
000008  4770              BX       lr
                  |L6.10|
00000a  8a82              LDRH     r2,[r0,#0x14]         ;1116
00000c  438a              BICS     r2,r2,r1              ;1116
00000e  8282              STRH     r2,[r0,#0x14]         ;1116
000010  4770              BX       lr
;;;1119   
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;186      */
;;;187    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189      /* Check the parameters */
;;;190      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;191    
;;;192      if (USARTx == USART1)
000002  4937              LDR      r1,|L7.224|
000004  4288              CMP      r0,r1
000006  d109              BNE      |L7.28|
;;;193      {
;;;194        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2010              MOVS     r0,#0x10
00000c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000010  2100              MOVS     r1,#0
000012  e8bd4010          POP      {r4,lr}
000016  2010              MOVS     r0,#0x10
000018  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.28|
;;;196      }
;;;197      else if (USARTx == USART2)
00001c  4931              LDR      r1,|L7.228|
00001e  4288              CMP      r0,r1
000020  d10a              BNE      |L7.56|
;;;198      {
;;;199        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000022  2101              MOVS     r1,#1
000024  044c              LSLS     r4,r1,#17
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002c  4620              MOV      r0,r4
00002e  e8bd4010          POP      {r4,lr}
000032  2100              MOVS     r1,#0
000034  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.56|
;;;201      }
;;;202      else if (USARTx == USART3)
000038  492b              LDR      r1,|L7.232|
00003a  4288              CMP      r0,r1
00003c  d10a              BNE      |L7.84|
;;;203      {
;;;204        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00003e  2101              MOVS     r1,#1
000040  048c              LSLS     r4,r1,#18
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000048  4620              MOV      r0,r4
00004a  e8bd4010          POP      {r4,lr}
00004e  2100              MOVS     r1,#0
000050  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.84|
;;;206      }    
;;;207      else if (USARTx == UART4)
000054  4925              LDR      r1,|L7.236|
000056  4288              CMP      r0,r1
000058  d10a              BNE      |L7.112|
;;;208      {
;;;209        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00005a  2101              MOVS     r1,#1
00005c  04cc              LSLS     r4,r1,#19
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;210        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000064  4620              MOV      r0,r4
000066  e8bd4010          POP      {r4,lr}
00006a  2100              MOVS     r1,#0
00006c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.112|
;;;211      }
;;;212      else if (USARTx == UART5)
000070  491f              LDR      r1,|L7.240|
000072  4288              CMP      r0,r1
000074  d10a              BNE      |L7.140|
;;;213      {
;;;214        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000076  2101              MOVS     r1,#1
000078  050c              LSLS     r4,r1,#20
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;215        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000080  4620              MOV      r0,r4
000082  e8bd4010          POP      {r4,lr}
000086  2100              MOVS     r1,#0
000088  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.140|
;;;216      }  
;;;217      else if (USARTx == USART6)
00008c  4919              LDR      r1,|L7.244|
00008e  4288              CMP      r0,r1
000090  d109              BNE      |L7.166|
;;;218      {
;;;219        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
000092  2101              MOVS     r1,#1
000094  2020              MOVS     r0,#0x20
000096  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;220        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
00009a  2100              MOVS     r1,#0
00009c  e8bd4010          POP      {r4,lr}
0000a0  2020              MOVS     r0,#0x20
0000a2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.166|
;;;221      }
;;;222      else if (USARTx == UART7)
0000a6  4914              LDR      r1,|L7.248|
0000a8  4288              CMP      r0,r1
0000aa  d10a              BNE      |L7.194|
;;;223      {
;;;224        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
0000ac  2101              MOVS     r1,#1
0000ae  078c              LSLS     r4,r1,#30
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;225        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
0000b6  4620              MOV      r0,r4
0000b8  e8bd4010          POP      {r4,lr}
0000bc  2100              MOVS     r1,#0
0000be  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.194|
;;;226      }     
;;;227      else
;;;228      {
;;;229        if (USARTx == UART8)
0000c2  490e              LDR      r1,|L7.252|
0000c4  4288              CMP      r0,r1
0000c6  d10a              BNE      |L7.222|
;;;230        { 
;;;231          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
0000c8  0544              LSLS     r4,r0,#21
0000ca  2101              MOVS     r1,#1
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;232          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
0000d2  4620              MOV      r0,r4
0000d4  e8bd4010          POP      {r4,lr}
0000d8  2100              MOVS     r1,#0
0000da  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.222|
;;;233        }
;;;234      }
;;;235    }
0000de  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L7.224|
                          DCD      0x40011000
                  |L7.228|
                          DCD      0x40004400
                  |L7.232|
                          DCD      0x40004800
                  |L7.236|
                          DCD      0x40004c00
                  |L7.240|
                          DCD      0x40005000
                  |L7.244|
                          DCD      0x40011400
                  |L7.248|
                          DCD      0x40007800
                  |L7.252|
                          DCD      0x40007c00

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1294     */
;;;1295   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1296   {
;;;1297     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1298     /* Check the parameters */
;;;1299     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1300     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1301   
;;;1302     /* The CTS flag is not available for UART4 and UART5 */
;;;1303     if (USART_FLAG == USART_FLAG_CTS)
;;;1304     {
;;;1305       assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1306     } 
;;;1307       
;;;1308     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  8812              LDRH     r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;1309     {
;;;1310       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       bitstatus = RESET;
;;;1315     }
;;;1316     return bitstatus;
;;;1317   }
00000c  4770              BX       lr
;;;1318   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1377     */
;;;1378   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1379   {
;;;1380     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;1381     ITStatus bitstatus = RESET;
000002  2400              MOVS     r4,#0
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1384     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1385   
;;;1386     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1387     if (USART_IT == USART_IT_CTS)
000004  f640126a          MOV      r2,#0x96a
;;;1388     {
;;;1389       assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1390     } 
;;;1391       
;;;1392     /* Get the USART register index */
;;;1393     usartreg = (((uint8_t)USART_IT) >> 0x05);
000008  f3c11342          UBFX     r3,r1,#5,#3
;;;1394     /* Get the interrupt position */
;;;1395     itmask = USART_IT & IT_MASK;
00000c  f0010c1f          AND      r12,r1,#0x1f
;;;1396     itmask = (uint32_t)0x01 << itmask;
000010  2501              MOVS     r5,#1
000012  fa05f20c          LSL      r2,r5,r12
;;;1397     
;;;1398     if (usartreg == 0x01) /* The IT  is in CR1 register */
000016  2b01              CMP      r3,#1
000018  d00c              BEQ      |L9.52|
;;;1399     {
;;;1400       itmask &= USARTx->CR1;
;;;1401     }
;;;1402     else if (usartreg == 0x02) /* The IT  is in CR2 register */
00001a  2b02              CMP      r3,#2
00001c  d00d              BEQ      |L9.58|
;;;1403     {
;;;1404       itmask &= USARTx->CR2;
;;;1405     }
;;;1406     else /* The IT  is in CR3 register */
;;;1407     {
;;;1408       itmask &= USARTx->CR3;
00001e  8a83              LDRH     r3,[r0,#0x14]
000020  4013              ANDS     r3,r3,r2
                  |L9.34|
;;;1409     }
;;;1410     
;;;1411     bitpos = USART_IT >> 0x08;
000022  0a09              LSRS     r1,r1,#8
;;;1412     bitpos = (uint32_t)0x01 << bitpos;
000024  408d              LSLS     r5,r5,r1
;;;1413     bitpos &= USARTx->SR;
000026  8800              LDRH     r0,[r0,#0]
000028  4028              ANDS     r0,r0,r5
;;;1414     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002a  b10b              CBZ      r3,|L9.48|
00002c  b100              CBZ      r0,|L9.48|
;;;1415     {
;;;1416       bitstatus = SET;
00002e  2401              MOVS     r4,#1
                  |L9.48|
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       bitstatus = RESET;
;;;1421     }
;;;1422     
;;;1423     return bitstatus;  
000030  4620              MOV      r0,r4
;;;1424   }
000032  bd30              POP      {r4,r5,pc}
                  |L9.52|
000034  8983              LDRH     r3,[r0,#0xc]          ;1400
000036  4013              ANDS     r3,r3,r2              ;1400
000038  e7f3              B        |L9.34|
                  |L9.58|
00003a  8a03              LDRH     r3,[r0,#0x10]         ;1404
00003c  4013              ANDS     r3,r3,r2              ;1404
00003e  e7f0              B        |L9.34|
;;;1425   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;835      */
;;;836    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L10.12|
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;840      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;841      
;;;842      if (NewState != DISABLE)
;;;843      {
;;;844        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;845        USARTx->CR3 |= USART_CR3_HDSEL;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  f0410108          ORR      r1,r1,#8
000008  8281              STRH     r1,[r0,#0x14]
;;;846      }
;;;847      else
;;;848      {
;;;849        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;850        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
;;;851      }
;;;852    }
00000a  4770              BX       lr
                  |L10.12|
00000c  8a81              LDRH     r1,[r0,#0x14]         ;850
00000e  f0210108          BIC      r1,r1,#8              ;850
000012  8281              STRH     r1,[r0,#0x14]         ;850
000014  4770              BX       lr
;;;853    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;1230     */
;;;1231   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  f640136a          MOV      r3,#0x96a
;;;1232   {
;;;1233     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;1234     uint32_t usartxbase = 0x00;
;;;1235     /* Check the parameters */
;;;1236     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1237     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1239   
;;;1240     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1241     if (USART_IT == USART_IT_CTS)
;;;1242     {
;;;1243       assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1244     } 
;;;1245       
;;;1246     usartxbase = (uint32_t)USARTx;
;;;1247   
;;;1248     /* Get the USART register index */
;;;1249     usartreg = (((uint8_t)USART_IT) >> 0x05);
000004  f3c11342          UBFX     r3,r1,#5,#3
;;;1250   
;;;1251     /* Get the interrupt position */
;;;1252     itpos = USART_IT & IT_MASK;
000008  f0010c1f          AND      r12,r1,#0x1f
;;;1253     itmask = (((uint32_t)0x01) << itpos);
00000c  2101              MOVS     r1,#1
00000e  fa01f10c          LSL      r1,r1,r12
;;;1254       
;;;1255     if (usartreg == 0x01) /* The IT is in CR1 register */
000012  2b01              CMP      r3,#1
000014  d007              BEQ      |L11.38|
;;;1256     {
;;;1257       usartxbase += 0x0C;
;;;1258     }
;;;1259     else if (usartreg == 0x02) /* The IT is in CR2 register */
000016  2b02              CMP      r3,#2
000018  d007              BEQ      |L11.42|
;;;1260     {
;;;1261       usartxbase += 0x10;
;;;1262     }
;;;1263     else /* The IT is in CR3 register */
;;;1264     {
;;;1265       usartxbase += 0x14; 
00001a  3014              ADDS     r0,r0,#0x14
                  |L11.28|
;;;1266     }
;;;1267     if (NewState != DISABLE)
00001c  b13a              CBZ      r2,|L11.46|
;;;1268     {
;;;1269       *(__IO uint32_t*)usartxbase  |= itmask;
00001e  6802              LDR      r2,[r0,#0]
000020  430a              ORRS     r2,r2,r1
000022  6002              STR      r2,[r0,#0]
;;;1270     }
;;;1271     else
;;;1272     {
;;;1273       *(__IO uint32_t*)usartxbase &= ~itmask;
;;;1274     }
;;;1275   }
000024  4770              BX       lr
                  |L11.38|
000026  300c              ADDS     r0,r0,#0xc            ;1257
000028  e7f8              B        |L11.28|
                  |L11.42|
00002a  3010              ADDS     r0,r0,#0x10           ;1261
00002c  e7f6              B        |L11.28|
                  |L11.46|
00002e  6802              LDR      r2,[r0,#0]            ;1273
000030  438a              BICS     r2,r2,r1              ;1273
000032  6002              STR      r2,[r0,#0]            ;1273
000034  4770              BX       lr
;;;1276   
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;245      */
;;;246    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;247    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;248      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;249      uint32_t integerdivider = 0x00;
;;;250      uint32_t fractionaldivider = 0x00;
;;;251      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;252    
;;;253      /* Check the parameters */
;;;254      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;255      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;256      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;257      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;258      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;259      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;260      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;261    
;;;262      /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;263      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
000006  89a8              LDRH     r0,[r5,#0xc]
;;;264      {
;;;265        assert_param(IS_USART_1236_PERIPH(USARTx));
;;;266      }
;;;267    
;;;268    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;269      tmpreg = USARTx->CR2;
000008  8a20              LDRH     r0,[r4,#0x10]
;;;270    
;;;271      /* Clear STOP[13:12] bits */
;;;272      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
00000a  f4205140          BIC      r1,r0,#0x3000
;;;273    
;;;274      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
;;;275          Set STOP[13:12] bits according to USART_StopBits value */
;;;276      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00000e  88e8              LDRH     r0,[r5,#6]
000010  4308              ORRS     r0,r0,r1
;;;277      
;;;278      /* Write to USART CR2 */
;;;279      USARTx->CR2 = (uint16_t)tmpreg;
000012  8220              STRH     r0,[r4,#0x10]
;;;280    
;;;281    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;282      tmpreg = USARTx->CR1;
000014  89a0              LDRH     r0,[r4,#0xc]
;;;283    
;;;284      /* Clear M, PCE, PS, TE and RE bits */
;;;285      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
000016  f241610c          MOV      r1,#0x160c
00001a  4388              BICS     r0,r0,r1
;;;286    
;;;287      /* Configure the USART Word Length, Parity and mode: 
;;;288         Set the M bits according to USART_WordLength value 
;;;289         Set PCE and PS bits according to USART_Parity value
;;;290         Set TE and RE bits according to USART_Mode value */
;;;291      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001c  88a9              LDRH     r1,[r5,#4]
00001e  892a              LDRH     r2,[r5,#8]
000020  4311              ORRS     r1,r1,r2
000022  896a              LDRH     r2,[r5,#0xa]
000024  4302              ORRS     r2,r2,r0
000026  4311              ORRS     r1,r1,r2
;;;292                USART_InitStruct->USART_Mode;
;;;293    
;;;294      /* Write to USART CR1 */
;;;295      USARTx->CR1 = (uint16_t)tmpreg;
000028  81a1              STRH     r1,[r4,#0xc]
;;;296    
;;;297    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;298      tmpreg = USARTx->CR3;
00002a  8aa0              LDRH     r0,[r4,#0x14]
;;;299    
;;;300      /* Clear CTSE and RTSE bits */
;;;301      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
00002c  f4207140          BIC      r1,r0,#0x300
;;;302    
;;;303      /* Configure the USART HFC : 
;;;304          Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;305      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000030  89a8              LDRH     r0,[r5,#0xc]
000032  4308              ORRS     r0,r0,r1
;;;306    
;;;307      /* Write to USART CR3 */
;;;308      USARTx->CR3 = (uint16_t)tmpreg;
000034  82a0              STRH     r0,[r4,#0x14]
;;;309    
;;;310    /*---------------------------- USART BRR Configuration -----------------------*/
;;;311      /* Configure the USART Baud Rate */
;;;312      RCC_GetClocksFreq(&RCC_ClocksStatus);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       RCC_GetClocksFreq
;;;313    
;;;314      if ((USARTx == USART1) || (USARTx == USART6))
00003c  481e              LDR      r0,|L12.184|
00003e  4284              CMP      r4,r0
000040  d002              BEQ      |L12.72|
000042  481e              LDR      r0,|L12.188|
000044  4284              CMP      r4,r0
000046  d101              BNE      |L12.76|
                  |L12.72|
;;;315      {
;;;316        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000048  9803              LDR      r0,[sp,#0xc]
00004a  e000              B        |L12.78|
                  |L12.76|
;;;317      }
;;;318      else
;;;319      {
;;;320        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00004c  9802              LDR      r0,[sp,#8]
                  |L12.78|
;;;321      }
;;;322      
;;;323      /* Determine the integer part */
;;;324      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00004e  89a1              LDRH     r1,[r4,#0xc]
000050  0409              LSLS     r1,r1,#16
000052  d508              BPL      |L12.102|
;;;325      {
;;;326        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;327        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
000054  eb0001c0          ADD      r1,r0,r0,LSL #3
000058  eb011000          ADD      r0,r1,r0,LSL #4
00005c  6829              LDR      r1,[r5,#0]
00005e  0049              LSLS     r1,r1,#1
000060  fbb0f0f1          UDIV     r0,r0,r1
000064  e007              B        |L12.118|
                  |L12.102|
;;;328      }
;;;329      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;330      {
;;;331        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;332        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000066  eb0001c0          ADD      r1,r0,r0,LSL #3
00006a  eb011000          ADD      r0,r1,r0,LSL #4
00006e  6829              LDR      r1,[r5,#0]
000070  0089              LSLS     r1,r1,#2
000072  fbb0f0f1          UDIV     r0,r0,r1
                  |L12.118|
;;;333      }
;;;334      tmpreg = (integerdivider / 100) << 4;
000076  2264              MOVS     r2,#0x64
000078  fbb0f1f2          UDIV     r1,r0,r2
00007c  0109              LSLS     r1,r1,#4
;;;335    
;;;336      /* Determine the fractional part */
;;;337      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00007e  090b              LSRS     r3,r1,#4
000080  f06f0518          MVN      r5,#0x18
000084  436b              MULS     r3,r5,r3
000086  eb000083          ADD      r0,r0,r3,LSL #2
;;;338    
;;;339      /* Implement the fractional part in the register */
;;;340      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00008a  89a3              LDRH     r3,[r4,#0xc]
00008c  041d              LSLS     r5,r3,#16
;;;341      {
;;;342        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
00008e  f04f0332          MOV      r3,#0x32
000092  d507              BPL      |L12.164|
000094  eb0300c0          ADD      r0,r3,r0,LSL #3
000098  fbb0f0f2          UDIV     r0,r0,r2
00009c  f0000007          AND      r0,r0,#7
0000a0  4308              ORRS     r0,r0,r1
0000a2  e006              B        |L12.178|
                  |L12.164|
;;;343      }
;;;344      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;345      {
;;;346        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
0000a4  eb031000          ADD      r0,r3,r0,LSL #4
0000a8  fbb0f0f2          UDIV     r0,r0,r2
0000ac  f000000f          AND      r0,r0,#0xf
0000b0  4308              ORRS     r0,r0,r1
                  |L12.178|
;;;347      }
;;;348      
;;;349      /* Write to USART BRR register */
;;;350      USARTx->BRR = (uint16_t)tmpreg;
0000b2  8120              STRH     r0,[r4,#8]
;;;351    }
0000b4  bd7f              POP      {r0-r6,pc}
;;;352    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L12.184|
                          DCD      0x40011000
                  |L12.188|
                          DCD      0x40011400

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;1052     */
;;;1053   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;1054   {
;;;1055     /* Check the parameters */
;;;1056     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1057     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1058       
;;;1059     if (NewState != DISABLE)
;;;1060     {
;;;1061       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1062       USARTx->CR3 |= USART_CR3_IREN;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  f0410102          ORR      r1,r1,#2
000008  8281              STRH     r1,[r0,#0x14]
;;;1063     }
;;;1064     else
;;;1065     {
;;;1066       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1067       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
;;;1068     }
;;;1069   }
00000a  4770              BX       lr
                  |L13.12|
00000c  8a81              LDRH     r1,[r0,#0x14]         ;1067
00000e  f0210102          BIC      r1,r1,#2              ;1067
000012  8281              STRH     r1,[r0,#0x14]         ;1067
000014  4770              BX       lr
;;;1070   
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;1034     */
;;;1035   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;1036   {
;;;1037     /* Check the parameters */
;;;1038     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1039     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1040       
;;;1041     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;1042     USARTx->CR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  8282              STRH     r2,[r0,#0x14]
;;;1043   }
00000e  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;740      */
;;;741    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;742    {
;;;743      /* Check the parameters */
;;;744      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;745      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;746      
;;;747      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;748      USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;749    }
00000e  4770              BX       lr
;;;750    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;758      */
;;;759    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L16.12|
;;;760    {
;;;761      /* Check the parameters */
;;;762      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;763      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;764      
;;;765      if (NewState != DISABLE)
;;;766      {
;;;767        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;768        USARTx->CR2 |= USART_CR2_LINEN;
000002  8a01              LDRH     r1,[r0,#0x10]
000004  f4414180          ORR      r1,r1,#0x4000
000008  8201              STRH     r1,[r0,#0x10]
;;;769      }
;;;770      else
;;;771      {
;;;772        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;773        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
;;;774      }
;;;775    }
00000a  4770              BX       lr
                  |L16.12|
00000c  8a01              LDRH     r1,[r0,#0x10]         ;773
00000e  f4214180          BIC      r1,r1,#0x4000         ;773
000012  8201              STRH     r1,[r0,#0x10]         ;773
000014  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;499      */
;;;500    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505      
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;509        USARTx->CR3 |= USART_CR3_ONEBIT;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  f4416100          ORR      r1,r1,#0x800
000008  8281              STRH     r1,[r0,#0x14]
;;;510      }
;;;511      else
;;;512      {
;;;513        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;514        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
;;;515      }
;;;516    }
00000a  4770              BX       lr
                  |L17.12|
00000c  8a81              LDRH     r1,[r0,#0x14]         ;514
00000e  f4216100          BIC      r1,r1,#0x800          ;514
000012  8281              STRH     r1,[r0,#0x14]         ;514
000014  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;473      */
;;;474    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;475    {
;;;476      /* Check the parameters */
;;;477      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;483        USARTx->CR1 |= USART_CR1_OVER8;
000002  8981              LDRH     r1,[r0,#0xc]
000004  f4414100          ORR      r1,r1,#0x8000
000008  8181              STRH     r1,[r0,#0xc]
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;488        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
;;;489      }
;;;490    }  
00000a  4770              BX       lr
                  |L18.12|
00000c  8981              LDRH     r1,[r0,#0xc]          ;488
00000e  f3c1010e          UBFX     r1,r1,#0,#15          ;488
000012  8181              STRH     r1,[r0,#0xc]          ;488
000014  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;572      */
;;;573    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;574    {
;;;575      /* Check the parameters */
;;;576      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;577      
;;;578      /* Receive Data */
;;;579      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;580    }
000006  4770              BX       lr
;;;581    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;644      */
;;;645    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L20.12|
;;;646    {
;;;647      /* Check the parameters */
;;;648      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;649      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;650      
;;;651      if (NewState != DISABLE)
;;;652      {
;;;653        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;654        USARTx->CR1 |= USART_CR1_RWU;
000002  8981              LDRH     r1,[r0,#0xc]
000004  f0410102          ORR      r1,r1,#2
000008  8181              STRH     r1,[r0,#0xc]
;;;655      }
;;;656      else
;;;657      {
;;;658        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;659        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
;;;660      }
;;;661    }
00000a  4770              BX       lr
                  |L20.12|
00000c  8981              LDRH     r1,[r0,#0xc]          ;659
00000e  f0210102          BIC      r1,r1,#2              ;659
000012  8181              STRH     r1,[r0,#0xc]          ;659
000014  4770              BX       lr
;;;662    /**
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;782      */
;;;783    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;787      
;;;788      /* Send break characters */
;;;789      USARTx->CR1 |= USART_CR1_SBK;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;790    }
000008  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;556      */
;;;557    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;558    {
;;;559      /* Check the parameters */
;;;560      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;561      assert_param(IS_USART_DATA(Data)); 
;;;562        
;;;563      /* Transmit Data */
;;;564      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;565    }
000006  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;624      */
;;;625    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;626    {
;;;627      /* Check the parameters */
;;;628      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;629      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;630        
;;;631      /* Clear the USART address */
;;;632      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;633      /* Set the USART address node */
;;;634      USARTx->CR2 |= USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;635    }
00000e  4770              BX       lr
;;;636    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;919      */
;;;920    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;921    {    
;;;922      /* Check the parameters */
;;;923      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;924      
;;;925      /* Clear the USART Guard time */
;;;926      USARTx->GTPR &= USART_GTPR_PSC;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;927      /* Set the USART guard time */
;;;928      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;929    }
00000e  4770              BX       lr
;;;930    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;452      */
;;;453    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;454    { 
;;;455      /* Check the parameters */
;;;456      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;457      
;;;458      /* Clear the USART prescaler */
;;;459      USARTx->GTPR &= USART_GTPR_GT;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;460      /* Set the USART prescaler */
;;;461      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;462    }
00000e  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;938      */
;;;939    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L26.12|
;;;940    {
;;;941      /* Check the parameters */
;;;942      assert_param(IS_USART_1236_PERIPH(USARTx));
;;;943      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;944      if (NewState != DISABLE)
;;;945      {
;;;946        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;947        USARTx->CR3 |= USART_CR3_SCEN;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  f0410120          ORR      r1,r1,#0x20
000008  8281              STRH     r1,[r0,#0x14]
;;;948      }
;;;949      else
;;;950      {
;;;951        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;952        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
;;;953      }
;;;954    }
00000a  4770              BX       lr
                  |L26.12|
00000c  8a81              LDRH     r1,[r0,#0x14]         ;952
00000e  f0210120          BIC      r1,r1,#0x20           ;952
000012  8281              STRH     r1,[r0,#0x14]         ;952
000014  4770              BX       lr
;;;955    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;963      */
;;;964    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L27.12|
;;;965    {
;;;966      /* Check the parameters */
;;;967      assert_param(IS_USART_1236_PERIPH(USARTx)); 
;;;968      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;969      if (NewState != DISABLE)
;;;970      {
;;;971        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;972        USARTx->CR3 |= USART_CR3_NACK;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  f0410110          ORR      r1,r1,#0x10
000008  8281              STRH     r1,[r0,#0x14]
;;;973      }
;;;974      else
;;;975      {
;;;976        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;977        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
;;;978      }
;;;979    }
00000a  4770              BX       lr
                  |L27.12|
00000c  8a81              LDRH     r1,[r0,#0x14]         ;977
00000e  f0210110          BIC      r1,r1,#0x10           ;977
000012  8281              STRH     r1,[r0,#0x14]         ;977
000014  4770              BX       lr
;;;980    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;358      */
;;;359    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;360    {
;;;361      /* USART_InitStruct members default value */
;;;362      USART_InitStruct->USART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;363      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;364      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;365      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;366      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;367      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;368    }
000014  4770              BX       lr
;;;369    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;671      */
;;;672    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;676      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;677      
;;;678      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;679      USARTx->CR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  8182              STRH     r2,[r0,#0xc]
;;;680    }
00000e  4770              BX       lr
;;;681    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_usart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f4xx_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
