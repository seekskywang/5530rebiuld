; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\iic_24c01.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\iic_24c01.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\iic_24c01.crf ..\drive\IIC_24C01.c]
                          THUMB

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;208    */
;;;209    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  4c0c              LDR      r4,|L1.52|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;212    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;213    	I2C_SCL_1();	/* CPU产生1个时钟 */
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetBits
;;;214    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;215    	I2C_SCL_0();
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GPIO_ResetBits
;;;216    	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;217    	I2C_SDA_1();	/* CPU释放SDA总线 */
000028  4620              MOV      r0,r4
00002a  e8bd4010          POP      {r4,lr}
00002e  2108              MOVS     r1,#8
000030  f7ffbffe          B.W      GPIO_SetBits
;;;218    }
;;;219    
                          ENDP

                  |L1.52|
                          DCD      0x40020c00

                          AREA ||i.i2c_CfgGpio||, CODE, READONLY, ALIGN=2

                  i2c_CfgGpio PROC
;;;245    */
;;;246    void i2c_CfgGpio(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;247    {
;;;248    	GPIO_InitTypeDef GPIO_InitStructure;//调用GPIO结构体
;;;249    
;;;250    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);//开启GPIOF时钟
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;251    
;;;252    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6;//定义端口PF
00000a  2048              MOVS     r0,#0x48
00000c  9000              STR      r0,[sp,#0]
;;;253    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00000e  2001              MOVS     r0,#1
000010  f88d0004          STRB     r0,[sp,#4]
;;;254    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//设置为输出模式
000014  f88d0006          STRB     r0,[sp,#6]
;;;255    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;//设置输出频率
000018  2002              MOVS     r0,#2
00001a  f88d0005          STRB     r0,[sp,#5]
;;;256    	GPIO_Init(GPIOD, &GPIO_InitStructure);//将设置输入函数
00001e  4669              MOV      r1,sp
000020  4802              LDR      r0,|L2.44|
000022  f7fffffe          BL       GPIO_Init
;;;257    
;;;258    	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;259    	i2c_Stop();
000026  f7fffffe          BL       i2c_Stop
;;;260    }
00002a  bd1c              POP      {r2-r4,pc}
;;;261    
                          ENDP

                  |L2.44|
                          DCD      0x40020c00

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;269    */
;;;270    vu8 i2c_CheckDevice(vu8 _Address)
000000  b510              PUSH     {r4,lr}
;;;271    {
000002  4604              MOV      r4,r0
;;;272    	vu8 ucAck;
;;;273    
;;;274    	i2c_CfgGpio();		/* 配置GPIO */
000004  f7fffffe          BL       i2c_CfgGpio
;;;275    
;;;276    	
;;;277    	i2c_Start();		/* 发送启动信号 */
000008  f7fffffe          BL       i2c_Start
;;;278    
;;;279    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;280    	i2c_SendByte(_Address | I2C_WR);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       i2c_SendByte
;;;281    	ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
000012  f7fffffe          BL       i2c_WaitAck
000016  4604              MOV      r4,r0
;;;282    
;;;283    	i2c_Stop();			/* 发送停止信号 */
000018  f7fffffe          BL       i2c_Stop
;;;284    
;;;285    	return ucAck;
00001c  4620              MOV      r0,r4
;;;286    }
00001e  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;52     */
;;;53     static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
;;;54     {
;;;55     	vu8 i;
;;;56     
;;;57     	/*　
;;;58     	 	下面的时间是通过安富莱AX-Pro逻辑分析仪测试得到的。
;;;59     		CPU主频72MHz时，在内部Flash运行, MDK工程不优化
;;;60     		循环次数为10时，SCL频率 = 205KHz 
;;;61     		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
;;;62     	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
;;;63             
;;;64         IAR工程编译效率高，不能设置为7
;;;65     	*/
;;;66     	for (i = 0; i < 100; i++);
000002  e001              B        |L4.8|
                  |L4.4|
000004  1c40              ADDS     r0,r0,#1
000006  b2c0              UXTB     r0,r0
                  |L4.8|
000008  2864              CMP      r0,#0x64
00000a  d3fb              BCC      |L4.4|
;;;67     }
00000c  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;227    */
;;;228    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  4c0a              LDR      r4,|L5.44|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;231    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;232    	I2C_SCL_1();	/* CPU产生1个时钟 */
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetBits
;;;233    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;234    	I2C_SCL_0();
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GPIO_ResetBits
;;;235    	i2c_Delay();	
000024  e8bd4010          POP      {r4,lr}
000028  f7ffbffe          B.W      i2c_Delay
;;;236    }
;;;237    
                          ENDP

                  |L5.44|
                          DCD      0x40020c00

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;149    */
;;;150    vu8 i2c_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
;;;152    	vu8 i;
;;;153    	vu8 value;
;;;154    
;;;155    	/* 读到第1个bit为数据的bit7 */
;;;156    	value = 0;
000002  2400              MOVS     r4,#0
;;;157    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
;;;158    	{
;;;159    		value <<= 1;
;;;160    		I2C_SCL_1();
000006  4e0e              LDR      r6,|L6.64|
000008  e016              B        |L6.56|
                  |L6.10|
00000a  0660              LSLS     r0,r4,#25             ;159
00000c  0e04              LSRS     r4,r0,#24             ;159
00000e  2140              MOVS     r1,#0x40
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       GPIO_SetBits
;;;161    		i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;162    		if (I2C_SDA_READ())
00001a  2108              MOVS     r1,#8
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
000022  b108              CBZ      r0,|L6.40|
;;;163    		{
;;;164    			value++;
000024  1c64              ADDS     r4,r4,#1
000026  b2e4              UXTB     r4,r4
                  |L6.40|
;;;165    		}
;;;166    		I2C_SCL_0();
000028  2140              MOVS     r1,#0x40
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       GPIO_ResetBits
;;;167    		i2c_Delay();
000030  f7fffffe          BL       i2c_Delay
000034  1c6d              ADDS     r5,r5,#1              ;157
000036  b2ed              UXTB     r5,r5                 ;157
                  |L6.56|
000038  2d08              CMP      r5,#8                 ;157
00003a  d3e6              BCC      |L6.10|
;;;168    	}
;;;169    	return value;
00003c  4620              MOV      r0,r4
;;;170    }
00003e  bd70              POP      {r4-r6,pc}
;;;171    
                          ENDP

                  |L6.64|
                          DCD      0x40020c00

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;113    */
;;;114    void i2c_SendByte(vu8 _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;115    {
000002  4605              MOV      r5,r0
;;;116    	vu8 i;
;;;117    
;;;118    	/* 先发送字节的高位bit7 */
;;;119    	for (i = 0; i < 8; i++)
000004  2400              MOVS     r4,#0
;;;120    	{		
;;;121    		if (_ucByte & 0x80)
;;;122    		{
;;;123    			I2C_SDA_1();
000006  4e14              LDR      r6,|L7.88|
000008  e022              B        |L7.80|
                  |L7.10|
00000a  0628              LSLS     r0,r5,#24             ;121
00000c  d504              BPL      |L7.24|
00000e  2108              MOVS     r1,#8
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       GPIO_SetBits
000016  e003              B        |L7.32|
                  |L7.24|
;;;124    		}
;;;125    		else
;;;126    		{
;;;127    			I2C_SDA_0();
000018  2108              MOVS     r1,#8
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       GPIO_ResetBits
                  |L7.32|
;;;128    		}
;;;129    		i2c_Delay();
000020  f7fffffe          BL       i2c_Delay
;;;130    		I2C_SCL_1();
000024  2140              MOVS     r1,#0x40
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       GPIO_SetBits
;;;131    		i2c_Delay();	
00002c  f7fffffe          BL       i2c_Delay
;;;132    		I2C_SCL_0();
000030  2140              MOVS     r1,#0x40
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       GPIO_ResetBits
;;;133    		if (i == 7)
000038  2c07              CMP      r4,#7
00003a  d103              BNE      |L7.68|
;;;134    		{
;;;135    			 I2C_SDA_1(); // 释放总线
00003c  2108              MOVS     r1,#8
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_SetBits
                  |L7.68|
;;;136    		}
;;;137    		_ucByte <<= 1;	/* 左移一个bit */
000044  0668              LSLS     r0,r5,#25
000046  0e05              LSRS     r5,r0,#24
;;;138    		i2c_Delay();
000048  f7fffffe          BL       i2c_Delay
00004c  1c64              ADDS     r4,r4,#1              ;119
00004e  b2e4              UXTB     r4,r4                 ;119
                  |L7.80|
000050  2c08              CMP      r4,#8                 ;119
000052  d3da              BCC      |L7.10|
;;;139    	}
;;;140    }
000054  bd70              POP      {r4-r6,pc}
;;;141    
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      0x40020c00

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;76     */
;;;77     void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;80     	I2C_SDA_1();
000002  4c0c              LDR      r4,|L8.52|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;81     	I2C_SCL_1();
00000c  2140              MOVS     r1,#0x40
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       GPIO_SetBits
;;;82     	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;83     	I2C_SDA_0();
000018  2108              MOVS     r1,#8
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_ResetBits
;;;84     	i2c_Delay();
000020  f7fffffe          BL       i2c_Delay
;;;85     	I2C_SCL_0();
000024  2140              MOVS     r1,#0x40
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_ResetBits
;;;86     	i2c_Delay();
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      i2c_Delay
;;;87     }
;;;88     
                          ENDP

                  |L8.52|
                          DCD      0x40020c00

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;96     */
;;;97     void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99     	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;100    	I2C_SDA_0();
000002  4c08              LDR      r4,|L9.36|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;101    	I2C_SCL_1();
00000c  2140              MOVS     r1,#0x40
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       GPIO_SetBits
;;;102    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;103    	I2C_SDA_1();
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  2108              MOVS     r1,#8
000020  f7ffbffe          B.W      GPIO_SetBits
;;;104    }
;;;105    
                          ENDP

                  |L9.36|
                          DCD      0x40020c00

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;179    */
;;;180    vu8 i2c_WaitAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182    	vu8 re;
;;;183    
;;;184    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  4d0e              LDR      r5,|L10.60|
000004  2108              MOVS     r1,#8
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       GPIO_SetBits
;;;185    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;186    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
000010  2140              MOVS     r1,#0x40
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       GPIO_SetBits
;;;187    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;188    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
00001c  2108              MOVS     r1,#8
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  b108              CBZ      r0,|L10.42|
;;;189    	{
;;;190    		re = 1;
000026  2401              MOVS     r4,#1
000028  e000              B        |L10.44|
                  |L10.42|
;;;191    	}
;;;192    	else
;;;193    	{
;;;194    		re = 0;
00002a  2400              MOVS     r4,#0
                  |L10.44|
;;;195    	}
;;;196    	I2C_SCL_0();
00002c  2140              MOVS     r1,#0x40
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       GPIO_ResetBits
;;;197    	i2c_Delay();
000034  f7fffffe          BL       i2c_Delay
;;;198    	return re;
000038  4620              MOV      r0,r4
;;;199    }
00003a  bd70              POP      {r4-r6,pc}
;;;200    
                          ENDP

                  |L10.60|
                          DCD      0x40020c00

;*** Start embedded assembler ***

#line 1 "..\\drive\\IIC_24C01.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_IIC_24C01_c_0e3d169d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REVSH|
#line 128
|__asm___11_IIC_24C01_c_0e3d169d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
