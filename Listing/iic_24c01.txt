; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\iic_24c01.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\iic_24c01.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\iic_24c01.crf --no_multibyte_chars ..\drive\IIC_24C01.c]
                          THUMB

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;208    */
;;;209    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  4c0c              LDR      r4,|L1.52|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;212    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;213    	I2C_SCL_1();	/* CPU产生1个时钟 */
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetBits
;;;214    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;215    	I2C_SCL_0();
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GPIO_ResetBits
;;;216    	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;217    	I2C_SDA_1();	/* CPU释放SDA总线 */
000028  4620              MOV      r0,r4
00002a  e8bd4010          POP      {r4,lr}
00002e  2108              MOVS     r1,#8
000030  f7ffbffe          B.W      GPIO_SetBits
;;;218    }
;;;219    
                          ENDP

                  |L1.52|
                          DCD      0x40020c00

                          AREA ||i.i2c_CfgGpio||, CODE, READONLY, ALIGN=2

                  i2c_CfgGpio PROC
;;;245    */
;;;246    void i2c_CfgGpio(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;247    {
;;;248    	GPIO_InitTypeDef GPIO_InitStructure;//调用GPIO结构体
;;;249    
;;;250    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);//开启GPIOF时钟
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;251    
;;;252    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_6;//定义端口PF
00000a  2048              MOVS     r0,#0x48
00000c  9000              STR      r0,[sp,#0]
;;;253    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00000e  2001              MOVS     r0,#1
000010  f88d0004          STRB     r0,[sp,#4]
;;;254    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//设置为输出模式
000014  f88d0006          STRB     r0,[sp,#6]
;;;255    	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;//设置输出频率
000018  2002              MOVS     r0,#2
00001a  f88d0005          STRB     r0,[sp,#5]
;;;256    	GPIO_Init(GPIOD, &GPIO_InitStructure);//将设置输入函数
00001e  4669              MOV      r1,sp
000020  4802              LDR      r0,|L2.44|
000022  f7fffffe          BL       GPIO_Init
;;;257    
;;;258    	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;259    	i2c_Stop();
000026  f7fffffe          BL       i2c_Stop
;;;260    }
00002a  bd1c              POP      {r2-r4,pc}
;;;261    
                          ENDP

                  |L2.44|
                          DCD      0x40020c00

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;269    */
;;;270    vu8 i2c_CheckDevice(vu8 _Address)
000000  b501              PUSH     {r0,lr}
;;;271    {
000002  b082              SUB      sp,sp,#8
;;;272    	vu8 ucAck;
;;;273    
;;;274    	i2c_CfgGpio();		/* 配置GPIO */
000004  f7fffffe          BL       i2c_CfgGpio
;;;275    
;;;276    	
;;;277    	i2c_Start();		/* 发送启动信号 */
000008  f7fffffe          BL       i2c_Start
;;;278    
;;;279    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;280    	i2c_SendByte(_Address | I2C_WR);
00000c  f89d0008          LDRB     r0,[sp,#8]
000010  f7fffffe          BL       i2c_SendByte
;;;281    	ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
000014  f7fffffe          BL       i2c_WaitAck
000018  9001              STR      r0,[sp,#4]
;;;282    
;;;283    	i2c_Stop();			/* 发送停止信号 */
00001a  f7fffffe          BL       i2c_Stop
;;;284    
;;;285    	return ucAck;
00001e  f89d0004          LDRB     r0,[sp,#4]
;;;286    }
000022  bd0e              POP      {r1-r3,pc}
                          ENDP


                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;52     */
;;;53     static void i2c_Delay(void)
000000  b508              PUSH     {r3,lr}
;;;54     {
;;;55     	vu8 i;
;;;56     
;;;57     	/*　
;;;58     	 	下面的时间是通过安富莱AX-Pro逻辑分析仪测试得到的。
;;;59     		CPU主频72MHz时，在内部Flash运行, MDK工程不优化
;;;60     		循环次数为10时，SCL频率 = 205KHz 
;;;61     		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
;;;62     	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
;;;63             
;;;64         IAR工程编译效率高，不能设置为7
;;;65     	*/
;;;66     	for (i = 0; i < 100; i++);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  e003              B        |L4.16|
                  |L4.8|
000008  f89d0000          LDRB     r0,[sp,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  9000              STR      r0,[sp,#0]
                  |L4.16|
000010  f89d0000          LDRB     r0,[sp,#0]
000014  2864              CMP      r0,#0x64
000016  d3f7              BCC      |L4.8|
;;;67     }
000018  bd08              POP      {r3,pc}
;;;68     
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;227    */
;;;228    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  4c0a              LDR      r4,|L5.44|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;231    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;232    	I2C_SCL_1();	/* CPU产生1个时钟 */
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetBits
;;;233    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;234    	I2C_SCL_0();
00001c  2140              MOVS     r1,#0x40
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GPIO_ResetBits
;;;235    	i2c_Delay();	
000024  e8bd4010          POP      {r4,lr}
000028  f7ffbffe          B.W      i2c_Delay
;;;236    }
;;;237    
                          ENDP

                  |L5.44|
                          DCD      0x40020c00

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;149    */
;;;150    vu8 i2c_ReadByte(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;151    {
;;;152    	vu8 i;
;;;153    	vu8 value;
;;;154    
;;;155    	/* 读到第1个bit为数据的bit7 */
;;;156    	value = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;157    	for (i = 0; i < 8; i++)
000006  9001              STR      r0,[sp,#4]
;;;158    	{
;;;159    		value <<= 1;
;;;160    		I2C_SCL_1();
000008  4c12              LDR      r4,|L6.84|
00000a  e01c              B        |L6.70|
                  |L6.12|
00000c  f89d0000          LDRB     r0,[sp,#0]            ;159
000010  0040              LSLS     r0,r0,#1              ;159
000012  9000              STR      r0,[sp,#0]            ;159
000014  2140              MOVS     r1,#0x40
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GPIO_SetBits
;;;161    		i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
;;;162    		if (I2C_SDA_READ())
000020  2108              MOVS     r1,#8
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GPIO_ReadInputDataBit
000028  b118              CBZ      r0,|L6.50|
;;;163    		{
;;;164    			value++;
00002a  f89d0000          LDRB     r0,[sp,#0]
00002e  1c40              ADDS     r0,r0,#1
000030  9000              STR      r0,[sp,#0]
                  |L6.50|
;;;165    		}
;;;166    		I2C_SCL_0();
000032  2140              MOVS     r1,#0x40
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       GPIO_ResetBits
;;;167    		i2c_Delay();
00003a  f7fffffe          BL       i2c_Delay
00003e  f89d0004          LDRB     r0,[sp,#4]            ;157
000042  1c40              ADDS     r0,r0,#1              ;157
000044  9001              STR      r0,[sp,#4]            ;157
                  |L6.70|
000046  f89d0004          LDRB     r0,[sp,#4]            ;157
00004a  2808              CMP      r0,#8                 ;157
00004c  d3de              BCC      |L6.12|
;;;168    	}
;;;169    	return value;
00004e  f89d0000          LDRB     r0,[sp,#0]
;;;170    }
000052  bd1c              POP      {r2-r4,pc}
;;;171    
                          ENDP

                  |L6.84|
                          DCD      0x40020c00

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;113    */
;;;114    void i2c_SendByte(vu8 _ucByte)
000000  b511              PUSH     {r0,r4,lr}
;;;115    {
000002  b081              SUB      sp,sp,#4
;;;116    	vu8 i;
;;;117    
;;;118    	/* 先发送字节的高位bit7 */
;;;119    	for (i = 0; i < 8; i++)
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;120    	{		
;;;121    		if (_ucByte & 0x80)
;;;122    		{
;;;123    			I2C_SDA_1();
000008  4c18              LDR      r4,|L7.108|
00000a  e02a              B        |L7.98|
                  |L7.12|
00000c  f89d1004          LDRB     r1,[sp,#4]            ;121
000010  0608              LSLS     r0,r1,#24             ;121
000012  d504              BPL      |L7.30|
000014  2108              MOVS     r1,#8
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GPIO_SetBits
00001c  e003              B        |L7.38|
                  |L7.30|
;;;124    		}
;;;125    		else
;;;126    		{
;;;127    			I2C_SDA_0();
00001e  2108              MOVS     r1,#8
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       GPIO_ResetBits
                  |L7.38|
;;;128    		}
;;;129    		i2c_Delay();
000026  f7fffffe          BL       i2c_Delay
;;;130    		I2C_SCL_1();
00002a  2140              MOVS     r1,#0x40
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       GPIO_SetBits
;;;131    		i2c_Delay();	
000032  f7fffffe          BL       i2c_Delay
;;;132    		I2C_SCL_0();
000036  2140              MOVS     r1,#0x40
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       GPIO_ResetBits
;;;133    		if (i == 7)
00003e  f89d1000          LDRB     r1,[sp,#0]
000042  2907              CMP      r1,#7
000044  d103              BNE      |L7.78|
;;;134    		{
;;;135    			 I2C_SDA_1(); // 释放总线
000046  2108              MOVS     r1,#8
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       GPIO_SetBits
                  |L7.78|
;;;136    		}
;;;137    		_ucByte <<= 1;	/* 左移一个bit */
00004e  f89d0004          LDRB     r0,[sp,#4]
000052  0041              LSLS     r1,r0,#1
000054  9101              STR      r1,[sp,#4]
;;;138    		i2c_Delay();
000056  f7fffffe          BL       i2c_Delay
00005a  f89d1000          LDRB     r1,[sp,#0]            ;119
00005e  1c49              ADDS     r1,r1,#1              ;119
000060  9100              STR      r1,[sp,#0]            ;119
                  |L7.98|
000062  f89d0000          LDRB     r0,[sp,#0]            ;119
000066  2808              CMP      r0,#8                 ;119
000068  d3d0              BCC      |L7.12|
;;;139    	}
;;;140    }
00006a  bd1c              POP      {r2-r4,pc}
;;;141    
                          ENDP

                  |L7.108|
                          DCD      0x40020c00

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;76     */
;;;77     void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;80     	I2C_SDA_1();
000002  4c0c              LDR      r4,|L8.52|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;81     	I2C_SCL_1();
00000c  2140              MOVS     r1,#0x40
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       GPIO_SetBits
;;;82     	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;83     	I2C_SDA_0();
000018  2108              MOVS     r1,#8
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       GPIO_ResetBits
;;;84     	i2c_Delay();
000020  f7fffffe          BL       i2c_Delay
;;;85     	I2C_SCL_0();
000024  2140              MOVS     r1,#0x40
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_ResetBits
;;;86     	i2c_Delay();
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      i2c_Delay
;;;87     }
;;;88     
                          ENDP

                  |L8.52|
                          DCD      0x40020c00

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;96     */
;;;97     void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99     	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;100    	I2C_SDA_0();
000002  4c08              LDR      r4,|L9.36|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;101    	I2C_SCL_1();
00000c  2140              MOVS     r1,#0x40
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       GPIO_SetBits
;;;102    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;103    	I2C_SDA_1();
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  2108              MOVS     r1,#8
000020  f7ffbffe          B.W      GPIO_SetBits
;;;104    }
;;;105    
                          ENDP

                  |L9.36|
                          DCD      0x40020c00

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;179    */
;;;180    vu8 i2c_WaitAck(void)
000000  b538              PUSH     {r3-r5,lr}
;;;181    {
;;;182    	vu8 re;
;;;183    
;;;184    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  4c10              LDR      r4,|L10.68|
000004  2108              MOVS     r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;185    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;186    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetBits
;;;187    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;188    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
00001c  2108              MOVS     r1,#8
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  b110              CBZ      r0,|L10.44|
;;;189    	{
;;;190    		re = 1;
000026  2001              MOVS     r0,#1
000028  9000              STR      r0,[sp,#0]
00002a  e001              B        |L10.48|
                  |L10.44|
;;;191    	}
;;;192    	else
;;;193    	{
;;;194    		re = 0;
00002c  2000              MOVS     r0,#0
00002e  9000              STR      r0,[sp,#0]
                  |L10.48|
;;;195    	}
;;;196    	I2C_SCL_0();
000030  2140              MOVS     r1,#0x40
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       GPIO_ResetBits
;;;197    	i2c_Delay();
000038  f7fffffe          BL       i2c_Delay
;;;198    	return re;
00003c  f89d0000          LDRB     r0,[sp,#0]
;;;199    }
000040  bd38              POP      {r3-r5,pc}
;;;200    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x40020c00

;*** Start embedded assembler ***

#line 1 "..\\drive\\IIC_24C01.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_IIC_24C01_c_0e3d169d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_IIC_24C01_c_0e3d169d____REVSH|
#line 144
|__asm___11_IIC_24C01_c_0e3d169d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
