; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\at24c01.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\at24c01.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\at24c01.crf ..\drive\AT24C01.c]
                          THUMB

                          AREA ||i.EEPROM_READ_Byte||, CODE, READONLY, ALIGN=2

                  EEPROM_READ_Byte PROC
;;;287    */
;;;288    vu8 EEPROM_READ_Byte(vu8 ReadAddr)
000000  b510              PUSH     {r4,lr}
;;;289    {
000002  4604              MOV      r4,r0
;;;290    	vu16 i;
;;;291    	static vu8 date;
;;;292    	/* 采用串行EEPROM随即读取指令序列，连续读取一个字节 */
;;;293    	
;;;294    	/* 第1步：发起I2C总线启动信号 */
;;;295    	i2c_Start();
000004  f7fffffe          BL       i2c_Start
;;;296    	
;;;297    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;298    	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000008  20a0              MOVS     r0,#0xa0
00000a  f7fffffe          BL       i2c_SendByte
;;;299    	
;;;300    	/* 第3步：发送ACK */
;;;301    	if (i2c_WaitAck() != 0)
00000e  f7fffffe          BL       i2c_WaitAck
000012  b968              CBNZ     r0,|L1.48|
;;;302    	{
;;;303    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;304    	}
;;;305    
;;;306    	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;307    	i2c_SendByte(ReadAddr);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       i2c_SendByte
;;;308    	
;;;309    	/* 第5步：发送ACK */
;;;310    	if (i2c_WaitAck() != 0)
00001a  f7fffffe          BL       i2c_WaitAck
00001e  b938              CBNZ     r0,|L1.48|
;;;311    	{
;;;312    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;313    	}
;;;314    	
;;;315    	/* 第6步：重新启动I2C总线。前面的代码的目的向EEPROM传送地址，下面开始读取数据 */
;;;316    	i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;317    	
;;;318    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;319    	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
000024  20a1              MOVS     r0,#0xa1
000026  f7fffffe          BL       i2c_SendByte
;;;320    	
;;;321    	/* 第8步：发送ACK */
;;;322    	if (i2c_WaitAck() != 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b118              CBZ      r0,|L1.56|
                  |L1.48|
;;;323    	{
;;;324    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;325    	}	
;;;326    	
;;;327    	/* 第9步：循环读取数据 */
;;;328    
;;;329    	 date= i2c_ReadByte();	/* 读1个字节 */
;;;330    	
;;;331    	/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;332    	i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
;;;333    	/* 发送I2C总线停止信号 */
;;;334    	i2c_Stop();
;;;335    	return date;	/* 执行成功 返回读取数据*/
;;;336    	
;;;337    	cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;338    	/* 发送I2C总线停止信号 */
;;;339    	i2c_Stop();
000030  f7fffffe          BL       i2c_Stop
;;;340    	return 0;
000034  2000              MOVS     r0,#0
;;;341    }
000036  bd10              POP      {r4,pc}
                  |L1.56|
000038  f7fffffe          BL       i2c_ReadByte
00003c  4c03              LDR      r4,|L1.76|
00003e  7020              STRB     r0,[r4,#0]            ;329
000040  f7fffffe          BL       i2c_NAck
000044  f7fffffe          BL       i2c_Stop
000048  7820              LDRB     r0,[r4,#0]            ;335  ; date
00004a  bd10              POP      {r4,pc}
;;;342    
                          ENDP

                  |L1.76|
                          DCD      ||.data||

                          AREA ||i.EEPROM_WriteByte||, CODE, READONLY, ALIGN=1

                  EEPROM_WriteByte PROC
;;;215    */
;;;216    void EEPROM_WriteByte(vu16 Addr,vu8 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;218    	vu16 i,m;
;;;219    	vu16 usAddr;
;;;220    	/* 
;;;221    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;222    		对于24xx02，page size = 8
;;;223    		简单的处理方法为：按字节写操作模式，没写1个字节，都发送地址
;;;224    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;225    	*/
;;;226    		usAddr = Addr;	
;;;227    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;228    			/*　第０步：发停止信号，启动内部写操作　*/
;;;229    			i2c_Stop();
000006  f7fffffe          BL       i2c_Stop
;;;230    			
;;;231    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms 			
;;;232    				CLK频率为200KHz时，查询次数为30次左右
;;;233    			*/
;;;234    			for (m = 0; m < 100; m++)
00000a  2400              MOVS     r4,#0
00000c  e009              B        |L2.34|
                  |L2.14|
;;;235    			{				
;;;236    				/* 第1步：发起I2C总线启动信号 */
;;;237    				i2c_Start();
00000e  f7fffffe          BL       i2c_Start
;;;238    				
;;;239    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;240    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000012  20a0              MOVS     r0,#0xa0
000014  f7fffffe          BL       i2c_SendByte
;;;241    				
;;;242    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;243    				if (i2c_WaitAck() == 0)
000018  f7fffffe          BL       i2c_WaitAck
00001c  b118              CBZ      r0,|L2.38|
00001e  1c64              ADDS     r4,r4,#1              ;234
000020  b2a4              UXTH     r4,r4                 ;234
                  |L2.34|
000022  2c64              CMP      r4,#0x64              ;234
000024  d3f3              BCC      |L2.14|
                  |L2.38|
;;;244    				{
;;;245    					break;
;;;246    				}
;;;247    			}
;;;248    			if (m  == 1000)
000026  f5b47f7a          CMP      r4,#0x3e8
00002a  d00d              BEQ      |L2.72|
;;;249    			{
;;;250    				goto cmd_fail;	/* EEPROM器件写超时 */
;;;251    			}
;;;252    		
;;;253    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;254    			i2c_SendByte((vu8)usAddr);
00002c  b2e8              UXTB     r0,r5
00002e  f7fffffe          BL       i2c_SendByte
;;;255    			
;;;256    			/* 第5步：发送ACK */
;;;257    			if (i2c_WaitAck() != 0)
000032  f7fffffe          BL       i2c_WaitAck
000036  b938              CBNZ     r0,|L2.72|
;;;258    			{
;;;259    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;260    			}
;;;261    		/* 第6步：开始写入数据 */
;;;262    		i2c_SendByte(Data);
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       i2c_SendByte
;;;263    	
;;;264    		/* 第7步：发送ACK */
;;;265    		if (i2c_WaitAck() != 0)
00003e  f7fffffe          BL       i2c_WaitAck
000042  b908              CBNZ     r0,|L2.72|
;;;266    		{
;;;267    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;268    		}
;;;269    		/* 命令执行成功，发送I2C总线停止信号 */
;;;270    		i2c_Stop();
000044  f7fffffe          BL       i2c_Stop
                  |L2.72|
;;;271    		
;;;272    
;;;273    		cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;274    		/* 发送I2C总线停止信号 */
;;;275    		i2c_Stop();
000048  e8bd4070          POP      {r4-r6,lr}
00004c  f7ffbffe          B.W      i2c_Stop
;;;276    		          
;;;277    }
;;;278    /*
                          ENDP


                          AREA ||i.ReadBytes||, CODE, READONLY, ALIGN=1

                  ReadBytes PROC
;;;42     */
;;;43     vu8 ReadBytes(vu8 *_pReadBuf, vu16 _usAddress, vu16 _usSize)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;45     	vu16 i;
;;;46     	
;;;47     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;48     	
;;;49     	/* 第1步：发起I2C总线启动信号 */
;;;50     	i2c_Start();
000008  f7fffffe          BL       i2c_Start
;;;51     	
;;;52     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;53     	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000c  20a0              MOVS     r0,#0xa0
00000e  f7fffffe          BL       i2c_SendByte
;;;54     	
;;;55     	/* 第3步：发送ACK */
;;;56     	if (i2c_WaitAck() != 0)
000012  f7fffffe          BL       i2c_WaitAck
000016  b968              CBNZ     r0,|L3.52|
;;;57     	{
;;;58     		goto cmd_fail;	/* EEPROM器件无应答 */
;;;59     	}
;;;60     
;;;61     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;62     	i2c_SendByte((vu8)_usAddress);
000018  b2e0              UXTB     r0,r4
00001a  f7fffffe          BL       i2c_SendByte
;;;63     	
;;;64     	/* 第5步：发送ACK */
;;;65     	if (i2c_WaitAck() != 0)
00001e  f7fffffe          BL       i2c_WaitAck
000022  b938              CBNZ     r0,|L3.52|
;;;66     	{
;;;67     		goto cmd_fail;	/* EEPROM器件无应答 */
;;;68     	}
;;;69     	
;;;70     	/* 第6步：重新启动I2C总线。前面的代码的目的向EEPROM传送地址，下面开始读取数据 */
;;;71     	i2c_Start();
000024  f7fffffe          BL       i2c_Start
;;;72     	
;;;73     	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;74     	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
000028  20a1              MOVS     r0,#0xa1
00002a  f7fffffe          BL       i2c_SendByte
;;;75     	
;;;76     	/* 第8步：发送ACK */
;;;77     	if (i2c_WaitAck() != 0)
00002e  f7fffffe          BL       i2c_WaitAck
000032  b118              CBZ      r0,|L3.60|
                  |L3.52|
;;;78     	{
;;;79     		goto cmd_fail;	/* EEPROM器件无应答 */
;;;80     	}	
;;;81     	
;;;82     	/* 第9步：循环读取数据 */
;;;83     	for (i = 0; i < _usSize; i++)
;;;84     	{
;;;85     		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
;;;86     		
;;;87     		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;88     		if (i != _usSize - 1)
;;;89     		{
;;;90     			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
;;;91     		}
;;;92     		else
;;;93     		{
;;;94     			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
;;;95     		}
;;;96     	}
;;;97     	/* 发送I2C总线停止信号 */
;;;98     	i2c_Stop();
;;;99     	return 1;	/* 执行成功 */
;;;100    
;;;101    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;102    	/* 发送I2C总线停止信号 */
;;;103    	i2c_Stop();
000034  f7fffffe          BL       i2c_Stop
;;;104    	return 0;
000038  2000              MOVS     r0,#0
;;;105    }
00003a  bd70              POP      {r4-r6,pc}
                  |L3.60|
00003c  2400              MOVS     r4,#0                 ;83
00003e  e00c              B        |L3.90|
                  |L3.64|
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]            ;85
000046  1e68              SUBS     r0,r5,#1              ;88
000048  4284              CMP      r4,r0                 ;88
00004a  d002              BEQ      |L3.82|
00004c  f7fffffe          BL       i2c_Ack
000050  e001              B        |L3.86|
                  |L3.82|
000052  f7fffffe          BL       i2c_NAck
                  |L3.86|
000056  1c64              ADDS     r4,r4,#1              ;83
000058  b2a4              UXTH     r4,r4                 ;83
                  |L3.90|
00005a  42ac              CMP      r4,r5                 ;83
00005c  d3f0              BCC      |L3.64|
00005e  f7fffffe          BL       i2c_Stop
000062  2001              MOVS     r0,#1                 ;99
000064  bd70              POP      {r4-r6,pc}
;;;106    
                          ENDP


                          AREA ||i.WriteBytes||, CODE, READONLY, ALIGN=1

                  WriteBytes PROC
;;;116    */
;;;117    vu8 WriteBytes(vu8 *_pWriteBuf, vu16 _usAddress, vu16 _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;118    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;119    	vu16 i,m;
;;;120    	vu16 usAddr;
;;;121    	
;;;122    	/* 
;;;123    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;124    		对于24xx02，page size = 8
;;;125    		简单的处理方法为：按字节写操作模式，没写1个字节，都发送地址
;;;126    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;127    	*/
;;;128    
;;;129    	usAddr = _usAddress;	
;;;130    	for (i = 0; i < _usSize; i++)
00000a  2500              MOVS     r5,#0
00000c  e02a              B        |L4.100|
                  |L4.14|
;;;131    	{
;;;132    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;133    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
00000e  b10d              CBZ      r5,|L4.20|
000010  0770              LSLS     r0,r6,#29
000012  d118              BNE      |L4.70|
                  |L4.20|
;;;134    		{
;;;135    			/*　第０步：发停止信号，启动内部写操作　*/
;;;136    			i2c_Stop();
000014  f7fffffe          BL       i2c_Stop
;;;137    			
;;;138    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms 			
;;;139    				CLK频率为200KHz时，查询次数为30次左右
;;;140    			*/
;;;141    			for (m = 0; m < 100; m++)
000018  2400              MOVS     r4,#0
00001a  e009              B        |L4.48|
                  |L4.28|
;;;142    			{				
;;;143    				/* 第1步：发起I2C总线启动信号 */
;;;144    				i2c_Start();
00001c  f7fffffe          BL       i2c_Start
;;;145    				
;;;146    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;147    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000020  20a0              MOVS     r0,#0xa0
000022  f7fffffe          BL       i2c_SendByte
;;;148    				
;;;149    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;150    				if (i2c_WaitAck() == 0)
000026  f7fffffe          BL       i2c_WaitAck
00002a  b118              CBZ      r0,|L4.52|
00002c  1c64              ADDS     r4,r4,#1              ;141
00002e  b2a4              UXTH     r4,r4                 ;141
                  |L4.48|
000030  2c64              CMP      r4,#0x64              ;141
000032  d3f3              BCC      |L4.28|
                  |L4.52|
;;;151    				{
;;;152    					break;
;;;153    				}
;;;154    			}
;;;155    			if (m  == 1000)
000034  f5b47f7a          CMP      r4,#0x3e8
000038  d00b              BEQ      |L4.82|
;;;156    			{
;;;157    				goto cmd_fail;	/* EEPROM器件写超时 */
;;;158    			}
;;;159    		
;;;160    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;161    			i2c_SendByte((vu8)usAddr);
00003a  b2f0              UXTB     r0,r6
00003c  f7fffffe          BL       i2c_SendByte
;;;162    			
;;;163    			/* 第5步：发送ACK */
;;;164    			if (i2c_WaitAck() != 0)
000040  f7fffffe          BL       i2c_WaitAck
000044  b928              CBNZ     r0,|L4.82|
                  |L4.70|
;;;165    			{
;;;166    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;167    			}
;;;168    		}
;;;169    	
;;;170    		/* 第6步：开始写入数据 */
;;;171    		i2c_SendByte(_pWriteBuf[i]);
000046  5d78              LDRB     r0,[r7,r5]
000048  f7fffffe          BL       i2c_SendByte
;;;172    	
;;;173    		/* 第7步：发送ACK */
;;;174    		if (i2c_WaitAck() != 0)
00004c  f7fffffe          BL       i2c_WaitAck
000050  b120              CBZ      r0,|L4.92|
                  |L4.82|
;;;175    		{
;;;176    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;177    		}
;;;178    
;;;179    		usAddr++;	/* 地址增1 */		
;;;180    	}
;;;181    	
;;;182    	/* 命令执行成功，发送I2C总线停止信号 */
;;;183    	i2c_Stop();
;;;184    	return 1;
;;;185    
;;;186    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;187    	/* 发送I2C总线停止信号 */
;;;188    	i2c_Stop();
000052  f7fffffe          BL       i2c_Stop
;;;189    	return 0; 
000056  2000              MOVS     r0,#0
                  |L4.88|
;;;190    }
000058  e8bd81f0          POP      {r4-r8,pc}
                  |L4.92|
00005c  1c76              ADDS     r6,r6,#1              ;179
00005e  b2b6              UXTH     r6,r6                 ;179
000060  1c6d              ADDS     r5,r5,#1              ;130
000062  b2ad              UXTH     r5,r5                 ;130
                  |L4.100|
000064  4545              CMP      r5,r8                 ;130
000066  d3d2              BCC      |L4.14|
000068  f7fffffe          BL       i2c_Stop
00006c  2001              MOVS     r0,#1                 ;184
00006e  e7f3              B        |L4.88|
;;;191    
                          ENDP


                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;18     */
;;;19     vu8 ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;20     {
;;;21     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b118              CBZ      r0,|L5.18|
;;;22     	{
;;;23     		return 1;
;;;24     	}
;;;25     	else
;;;26     	{
;;;27     		/* 失败后，切记发送I2C总线停止信号 */
;;;28     		i2c_Stop();		
00000a  f7fffffe          BL       i2c_Stop
;;;29     		return 0;
00000e  2000              MOVS     r0,#0
;;;30     	}
;;;31     }
000010  bd10              POP      {r4,pc}
                  |L5.18|
000012  2001              MOVS     r0,#1                 ;23
000014  bd10              POP      {r4,pc}
;;;32     
                          ENDP


                          AREA ||i.ee_Erase||, CODE, READONLY, ALIGN=1

                  ee_Erase PROC
;;;191    
;;;192    void ee_Erase(void)
000000  b0c0              SUB      sp,sp,#0x100
;;;193    {
;;;194    	vu16 i;
;;;195    	vu8 buf[EE_SIZE];
;;;196    	
;;;197    	/* 填充缓冲区 */
;;;198    	for (i = 0; i < EE_SIZE; i++)
000002  2000              MOVS     r0,#0
000004  466a              MOV      r2,sp                 ;195
;;;199    	{
;;;200    		buf[i] = 0xFF;
000006  21ff              MOVS     r1,#0xff
000008  e002              B        |L6.16|
                  |L6.10|
00000a  5411              STRB     r1,[r2,r0]
00000c  1c40              ADDS     r0,r0,#1              ;198
00000e  b280              UXTH     r0,r0                 ;198
                  |L6.16|
000010  28ff              CMP      r0,#0xff              ;198
000012  d9fa              BLS      |L6.10|
;;;201    	}
;;;202    	
;;;203    	/* 写EEPROM, 起始地址 = 0，数据长度为 256 */
;;;204    }
000014  b040              ADD      sp,sp,#0x100
000016  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  date
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\AT24C01.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_AT24C01_c_4eb00f1b____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_AT24C01_c_4eb00f1b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_AT24C01_c_4eb00f1b____REVSH|
#line 128
|__asm___9_AT24C01_c_4eb00f1b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
