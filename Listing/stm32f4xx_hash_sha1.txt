; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_hash_sha1.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_hash_sha1.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_hash_sha1.crf ..\Libraries\FWlib\src\stm32f4xx_hash_sha1.c]
                          THUMB

                          AREA ||i.HASH_SHA1||, CODE, READONLY, ALIGN=1

                  HASH_SHA1 PROC
;;;92       */
;;;93     ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;94     {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4617              MOV      r7,r2
;;;95       HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;96       HASH_MsgDigest SHA1_MessageDigest;
;;;97       __IO uint16_t nbvalidbitsdata = 0;
;;;98       uint32_t i = 0;
00000c  2500              MOVS     r5,#0
;;;99       __IO uint32_t counter = 0;
00000e  2600              MOVS     r6,#0
;;;100      uint32_t busystatus = 0;
;;;101      ErrorStatus status = SUCCESS;
000010  f04f0901          MOV      r9,#1
;;;102      uint32_t inputaddr  = (uint32_t)Input;
;;;103      uint32_t outputaddr = (uint32_t)Output;
;;;104    
;;;105      /* Number of valid bits in last word of the Input data */
;;;106      nbvalidbitsdata = 8 * (Ilen % 4);
000014  ea4f7088          LSL      r0,r8,#30
000018  ea4f6ad0          LSR      r10,r0,#27
;;;107    
;;;108      /* HASH peripheral initialization */
;;;109      HASH_DeInit();
00001c  f7fffffe          BL       HASH_DeInit
;;;110    
;;;111      /* HASH Configuration */
;;;112      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
000020  2000              MOVS     r0,#0
000022  9008              STR      r0,[sp,#0x20]
;;;113      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
000024  9009              STR      r0,[sp,#0x24]
;;;114      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000026  2020              MOVS     r0,#0x20
000028  900a              STR      r0,[sp,#0x28]
;;;115      HASH_Init(&SHA1_HASH_InitStructure);
00002a  a808              ADD      r0,sp,#0x20
00002c  f7fffffe          BL       HASH_Init
;;;116    
;;;117      /* Configure the number of valid bits in last word of the data */
;;;118      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000030  4650              MOV      r0,r10
000032  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;119    
;;;120      /* Write the Input block in the IN FIFO */
;;;121      for(i=0; i<Ilen; i+=4)
000036  e004              B        |L1.66|
                  |L1.56|
;;;122      {
;;;123        HASH_DataIn(*(uint32_t*)inputaddr);
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       HASH_DataIn
;;;124        inputaddr+=4;
00003e  1d24              ADDS     r4,r4,#4
000040  1d2d              ADDS     r5,r5,#4              ;121
                  |L1.66|
000042  4545              CMP      r5,r8                 ;121
000044  d3f8              BCC      |L1.56|
;;;125      }
;;;126    
;;;127      /* Start the HASH processor */
;;;128      HASH_StartDigest();
000046  f7fffffe          BL       HASH_StartDigest
;;;129    
;;;130      /* wait until the Busy flag is RESET */
;;;131      do
;;;132      {
;;;133        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
;;;134        counter++;
;;;135      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
00004a  f44f3480          MOV      r4,#0x10000
                  |L1.78|
00004e  2008              MOVS     r0,#8                 ;133
000050  f7fffffe          BL       HASH_GetFlagStatus
000054  1c76              ADDS     r6,r6,#1              ;134
000056  42a6              CMP      r6,r4
000058  d001              BEQ      |L1.94|
00005a  2800              CMP      r0,#0
00005c  d1f7              BNE      |L1.78|
                  |L1.94|
;;;136    
;;;137      if (busystatus != RESET)
00005e  b110              CBZ      r0,|L1.102|
;;;138      {
;;;139         status = ERROR;
000060  f04f0900          MOV      r9,#0
000064  e011              B        |L1.138|
                  |L1.102|
;;;140      }
;;;141      else
;;;142      {
;;;143        /* Read the message digest */
;;;144        HASH_GetDigest(&SHA1_MessageDigest);
000066  4668              MOV      r0,sp
000068  f7fffffe          BL       HASH_GetDigest
;;;145        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
00006c  9800              LDR      r0,[sp,#0]
00006e  ba00              REV      r0,r0
000070  6038              STR      r0,[r7,#0]
;;;146        outputaddr+=4;
;;;147        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000072  9801              LDR      r0,[sp,#4]
000074  ba00              REV      r0,r0
000076  6078              STR      r0,[r7,#4]
;;;148        outputaddr+=4;
;;;149        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
000078  9802              LDR      r0,[sp,#8]
00007a  ba00              REV      r0,r0
00007c  60b8              STR      r0,[r7,#8]
;;;150        outputaddr+=4;
;;;151        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
00007e  9803              LDR      r0,[sp,#0xc]
000080  ba00              REV      r0,r0
000082  60f8              STR      r0,[r7,#0xc]
;;;152        outputaddr+=4;
;;;153        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000084  9804              LDR      r0,[sp,#0x10]
000086  ba00              REV      r0,r0
000088  6138              STR      r0,[r7,#0x10]
                  |L1.138|
;;;154      }
;;;155      return status;
;;;156    }
00008a  b00c              ADD      sp,sp,#0x30
00008c  4648              MOV      r0,r9                 ;155
00008e  e8bd87f0          POP      {r4-r10,pc}
;;;157    
                          ENDP


                          AREA ||i.HMAC_SHA1||, CODE, READONLY, ALIGN=1

                  HMAC_SHA1 PROC
;;;168      */
;;;169    ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;170                          uint32_t Ilen, uint8_t Output[20])
;;;171    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4689              MOV      r9,r1
000008  f8ddb070          LDR      r11,[sp,#0x70]
00000c  4616              MOV      r6,r2
;;;172      HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;173      HASH_MsgDigest SHA1_MessageDigest;
;;;174      __IO uint16_t nbvalidbitsdata = 0;
;;;175      __IO uint16_t nbvalidbitskey = 0;
;;;176      uint32_t i = 0;
00000e  2700              MOVS     r7,#0
;;;177      __IO uint32_t counter = 0;
000010  46b8              MOV      r8,r7
;;;178      uint32_t busystatus = 0;
;;;179      ErrorStatus status = SUCCESS;
000012  f04f0a01          MOV      r10,#1
;;;180      uint32_t keyaddr    = (uint32_t)Key;
000016  9d0f              LDR      r5,[sp,#0x3c]
;;;181      uint32_t inputaddr  = (uint32_t)Input;
;;;182      uint32_t outputaddr = (uint32_t)Output;
;;;183    
;;;184      /* Number of valid bits in last word of the Input data */
;;;185      nbvalidbitsdata = 8 * (Ilen % 4);
000018  9812              LDR      r0,[sp,#0x48]
00001a  0780              LSLS     r0,r0,#30
00001c  0ec0              LSRS     r0,r0,#27
00001e  9002              STR      r0,[sp,#8]
;;;186    
;;;187      /* Number of valid bits in last word of the Key */
;;;188      nbvalidbitskey = 8 * (Keylen % 4);
000020  ea4f7089          LSL      r0,r9,#30
000024  0ec0              LSRS     r0,r0,#27
000026  9001              STR      r0,[sp,#4]
;;;189    
;;;190      /* HASH peripheral initialization */
;;;191      HASH_DeInit();
000028  f7fffffe          BL       HASH_DeInit
;;;192    
;;;193      /* HASH Configuration */
;;;194      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
00002c  2000              MOVS     r0,#0
00002e  900b              STR      r0,[sp,#0x2c]
;;;195      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
000030  2140              MOVS     r1,#0x40
000032  910c              STR      r1,[sp,#0x30]
;;;196      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000034  2120              MOVS     r1,#0x20
000036  910d              STR      r1,[sp,#0x34]
;;;197      if(Keylen > 64)
;;;198      {
;;;199        /* HMAC long Key */
;;;200        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
000038  02cc              LSLS     r4,r1,#11
00003a  f1b90f40          CMP      r9,#0x40              ;197
00003e  d901              BLS      |L2.68|
000040  940e              STR      r4,[sp,#0x38]
000042  e000              B        |L2.70|
                  |L2.68|
;;;201      }
;;;202      else
;;;203      {
;;;204        /* HMAC short Key */
;;;205        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000044  900e              STR      r0,[sp,#0x38]
                  |L2.70|
;;;206      }
;;;207      HASH_Init(&SHA1_HASH_InitStructure);
000046  a80b              ADD      r0,sp,#0x2c
000048  f7fffffe          BL       HASH_Init
;;;208    
;;;209      /* Configure the number of valid bits in last word of the Key */
;;;210      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;211    
;;;212      /* Write the Key */
;;;213      for(i=0; i<Keylen; i+=4)
000052  e004              B        |L2.94|
                  |L2.84|
;;;214      {
;;;215        HASH_DataIn(*(uint32_t*)keyaddr);
000054  6828              LDR      r0,[r5,#0]
000056  f7fffffe          BL       HASH_DataIn
;;;216        keyaddr+=4;
00005a  1d2d              ADDS     r5,r5,#4
00005c  1d3f              ADDS     r7,r7,#4              ;213
                  |L2.94|
00005e  454f              CMP      r7,r9                 ;213
000060  d3f8              BCC      |L2.84|
;;;217      }
;;;218    
;;;219      /* Start the HASH processor */
;;;220      HASH_StartDigest();
000062  f7fffffe          BL       HASH_StartDigest
                  |L2.102|
;;;221    
;;;222      /* wait until the Busy flag is RESET */
;;;223      do
;;;224      {
;;;225        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000066  2008              MOVS     r0,#8
000068  f7fffffe          BL       HASH_GetFlagStatus
;;;226        counter++;
00006c  f1080801          ADD      r8,r8,#1
;;;227      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000070  45a0              CMP      r8,r4
000072  d001              BEQ      |L2.120|
000074  2800              CMP      r0,#0
000076  d1f6              BNE      |L2.102|
                  |L2.120|
;;;228    
;;;229      if (busystatus != RESET)
000078  b110              CBZ      r0,|L2.128|
;;;230      {
;;;231         status = ERROR;
00007a  f04f0a00          MOV      r10,#0
00007e  e04f              B        |L2.288|
                  |L2.128|
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Configure the number of valid bits in last word of the Input data */
;;;236        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000080  9802              LDR      r0,[sp,#8]
000082  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;237    
;;;238        /* Write the Input block in the IN FIFO */
;;;239        for(i=0; i<Ilen; i+=4)
000086  2700              MOVS     r7,#0
000088  e004              B        |L2.148|
                  |L2.138|
;;;240        {
;;;241          HASH_DataIn(*(uint32_t*)inputaddr);
00008a  6830              LDR      r0,[r6,#0]
00008c  f7fffffe          BL       HASH_DataIn
;;;242          inputaddr+=4;
000090  1d36              ADDS     r6,r6,#4
000092  1d3f              ADDS     r7,r7,#4              ;239
                  |L2.148|
000094  9812              LDR      r0,[sp,#0x48]         ;239
000096  4287              CMP      r7,r0                 ;239
000098  d3f7              BCC      |L2.138|
;;;243        }
;;;244    
;;;245        /* Start the HASH processor */
;;;246        HASH_StartDigest();
00009a  f7fffffe          BL       HASH_StartDigest
;;;247    
;;;248    
;;;249        /* wait until the Busy flag is RESET */
;;;250        counter =0;
00009e  2600              MOVS     r6,#0
                  |L2.160|
;;;251        do
;;;252        {
;;;253          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000a0  2008              MOVS     r0,#8
0000a2  f7fffffe          BL       HASH_GetFlagStatus
;;;254          counter++;
0000a6  1c76              ADDS     r6,r6,#1
;;;255        }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000a8  4627              MOV      r7,r4
0000aa  42be              CMP      r6,r7
0000ac  d001              BEQ      |L2.178|
0000ae  2800              CMP      r0,#0
0000b0  d1f6              BNE      |L2.160|
                  |L2.178|
;;;256    
;;;257        if (busystatus != RESET)
0000b2  b110              CBZ      r0,|L2.186|
;;;258        {
;;;259          status = ERROR;
0000b4  f04f0a00          MOV      r10,#0
0000b8  e032              B        |L2.288|
                  |L2.186|
;;;260        }
;;;261        else
;;;262        {  
;;;263          /* Configure the number of valid bits in last word of the Key */
;;;264          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0000ba  9801              LDR      r0,[sp,#4]
0000bc  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;265    
;;;266          /* Write the Key */
;;;267          keyaddr = (uint32_t)Key;
0000c0  9c0f              LDR      r4,[sp,#0x3c]
;;;268          for(i=0; i<Keylen; i+=4)
0000c2  2500              MOVS     r5,#0
0000c4  e004              B        |L2.208|
                  |L2.198|
;;;269          {
;;;270            HASH_DataIn(*(uint32_t*)keyaddr);
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       HASH_DataIn
;;;271            keyaddr+=4;
0000cc  1d24              ADDS     r4,r4,#4
0000ce  1d2d              ADDS     r5,r5,#4              ;268
                  |L2.208|
0000d0  454d              CMP      r5,r9                 ;268
0000d2  d3f8              BCC      |L2.198|
;;;272          }
;;;273    
;;;274          /* Start the HASH processor */
;;;275          HASH_StartDigest();
0000d4  f7fffffe          BL       HASH_StartDigest
;;;276    
;;;277          /* wait until the Busy flag is RESET */
;;;278          counter =0;
0000d8  2400              MOVS     r4,#0
                  |L2.218|
;;;279          do
;;;280          {
;;;281            busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000da  2008              MOVS     r0,#8
0000dc  f7fffffe          BL       HASH_GetFlagStatus
;;;282            counter++;
0000e0  1c64              ADDS     r4,r4,#1
;;;283          }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000e2  42bc              CMP      r4,r7
0000e4  d001              BEQ      |L2.234|
0000e6  2800              CMP      r0,#0
0000e8  d1f7              BNE      |L2.218|
                  |L2.234|
;;;284    
;;;285          if (busystatus != RESET)
0000ea  b110              CBZ      r0,|L2.242|
;;;286          {
;;;287            status = ERROR;
0000ec  f04f0a00          MOV      r10,#0
0000f0  e016              B        |L2.288|
                  |L2.242|
;;;288          }
;;;289          else
;;;290          {
;;;291            /* Read the message digest */
;;;292            HASH_GetDigest(&SHA1_MessageDigest);
0000f2  a803              ADD      r0,sp,#0xc
0000f4  f7fffffe          BL       HASH_GetDigest
;;;293            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
0000f8  9803              LDR      r0,[sp,#0xc]
0000fa  ba00              REV      r0,r0
0000fc  f8cb0000          STR      r0,[r11,#0]
;;;294            outputaddr+=4;
;;;295            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000100  9804              LDR      r0,[sp,#0x10]
000102  ba00              REV      r0,r0
000104  f8cb0004          STR      r0,[r11,#4]
;;;296            outputaddr+=4;
;;;297            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
000108  9805              LDR      r0,[sp,#0x14]
00010a  ba00              REV      r0,r0
00010c  f8cb0008          STR      r0,[r11,#8]
;;;298            outputaddr+=4;
;;;299            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000110  9806              LDR      r0,[sp,#0x18]
000112  ba00              REV      r0,r0
000114  f8cb000c          STR      r0,[r11,#0xc]
;;;300            outputaddr+=4;
;;;301            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000118  9807              LDR      r0,[sp,#0x1c]
00011a  ba00              REV      r0,r0
00011c  f8cb0010          STR      r0,[r11,#0x10]
                  |L2.288|
;;;302          }
;;;303        }  
;;;304      }
;;;305      return status;  
;;;306    }
000120  b013              ADD      sp,sp,#0x4c
000122  4650              MOV      r0,r10                ;305
000124  e8bd8ff0          POP      {r4-r11,pc}
;;;307    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_hash_sha1.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH|
#line 128
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
