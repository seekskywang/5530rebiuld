; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\usbh_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\usbh_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\usbh_core.crf --no_multibyte_chars ..\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connected||, CODE, READONLY, ALIGN=1

                  USBH_Connected PROC
;;;117    */
;;;118    uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
000000  2101              MOVS     r1,#1
;;;119    {
;;;120      pdev->host.ConnSts = 1;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;121      return 0;
000006  2000              MOVS     r0,#0
;;;122    }
000008  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;192      */
;;;193    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;195      /* Software Init */
;;;196      
;;;197      phost->gState = HOST_IDLE;
000006  2100              MOVS     r1,#0
000008  7021              STRB     r1,[r4,#0]
;;;198      phost->gStateBkp = HOST_IDLE; 
00000a  7061              STRB     r1,[r4,#1]
;;;199      phost->EnumState = ENUM_IDLE;
00000c  70a1              STRB     r1,[r4,#2]
;;;200      phost->RequestState = CMD_SEND;  
00000e  2201              MOVS     r2,#1
000010  70e2              STRB     r2,[r4,#3]
;;;201      
;;;202      phost->Control.state = CTRL_SETUP;
000012  7722              STRB     r2,[r4,#0x1c]
;;;203      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000014  2040              MOVS     r0,#0x40
000016  71a0              STRB     r0,[r4,#6]
;;;204      
;;;205      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
000018  f8841020          STRB     r1,[r4,#0x20]
;;;206      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
00001c  f8842021          STRB     r2,[r4,#0x21]
;;;207      
;;;208      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000020  7921              LDRB     r1,[r4,#4]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Free_Channel
;;;209      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
000028  7961              LDRB     r1,[r4,#5]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USBH_Free_Channel
;;;210      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;211    }
000032  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP


                          AREA ||i.USBH_Disconnected||, CODE, READONLY, ALIGN=1

                  USBH_Disconnected PROC
;;;130    
;;;131    uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
000000  2100              MOVS     r1,#0
;;;132    {
;;;133      pdev->host.ConnSts = 0;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;134      return 0;  
000006  2000              MOVS     r0,#0
;;;135    }
000008  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;370      */
;;;371    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4604              MOV      r4,r0
;;;373      /* Error unrecovered or not supported device speed */
;;;374      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
;;;375           (errType == USBH_UNRECOVERED_ERROR) )
;;;376      {
;;;377        phost->usr_cb->UnrecoveredError(); 
;;;378        phost->gState = HOST_ERROR_STATE;   
000004  250a              MOVS     r5,#0xa
000006  2905              CMP      r1,#5                 ;374
000008  d00a              BEQ      |L4.32|
00000a  2904              CMP      r1,#4                 ;375
00000c  d008              BEQ      |L4.32|
;;;379      }  
;;;380      /* USB host restart requested from application layer */
;;;381      else if(errType == USBH_APPLY_DEINIT)
00000e  2906              CMP      r1,#6
000010  d10b              BNE      |L4.42|
;;;382      {
;;;383        phost->gState = HOST_ERROR_STATE;  
000012  7025              STRB     r5,[r4,#0]
;;;384        /* user callback for initalization */
;;;385        phost->usr_cb->Init();
000014  f8d40080          LDR      r0,[r4,#0x80]
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  4700              BX       r0
                  |L4.32|
000020  f8d40080          LDR      r0,[r4,#0x80]         ;377
000024  6c40              LDR      r0,[r0,#0x44]         ;377
000026  4780              BLX      r0                    ;377
000028  7025              STRB     r5,[r4,#0]            ;378
                  |L4.42|
;;;386      } 
;;;387    }
00002a  bd70              POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;586      */
;;;587    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;588    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;589      uint8_t direction;  
;;;590      static uint16_t timeout = 0;
;;;591      USBH_Status status = USBH_OK;
000008  2700              MOVS     r7,#0
;;;592      URB_STATE URB_Status = URB_IDLE;
;;;593      
;;;594      phost->Control.status = CTRL_START;
00000a  2000              MOVS     r0,#0
00000c  74a0              STRB     r0,[r4,#0x12]
;;;595    
;;;596      
;;;597      switch (phost->Control.state)
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  250b              MOVS     r5,#0xb
000012  2609              MOVS     r6,#9
000014  2101              MOVS     r1,#1
;;;598      {
;;;599      case CTRL_SETUP:
;;;600        /* send a SETUP packet */
;;;601        USBH_CtlSendSetup     (pdev, 
;;;602    	                   phost->Control.setup.d8 , 
;;;603    	                   phost->Control.hc_num_out);  
;;;604        phost->Control.state = CTRL_SETUP_WAIT;  
;;;605        break; 
;;;606        
;;;607      case CTRL_SETUP_WAIT:
;;;608        
;;;609        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
;;;610        /* case SETUP packet sent successfully */
;;;611        if(URB_Status == URB_DONE)
;;;612        { 
;;;613          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
;;;614          
;;;615          /* check if there is a data stage */
;;;616          if (phost->Control.setup.b.wLength.w != 0 )
;;;617          {        
;;;618            timeout = DATA_STAGE_TIMEOUT;
000016  f8df91e4          LDR      r9,|L5.508|
00001a  f04f0b08          MOV      r11,#8                ;597
00001e  f04f0a05          MOV      r10,#5                ;597
000022  280c              CMP      r0,#0xc               ;597
000024  d20f              BCS      |L5.70|
000026  e8dff000          TBB      [pc,r0]               ;597
00002a  e606              DCB      0xe6,0x06
00002c  0f3b445f          DCB      0x0f,0x3b,0x44,0x5f
000030  6d8790b3          DCB      0x6d,0x87,0x90,0xb3
000034  c5d9              DCB      0xc5,0xd9
000036  7962              LDRB     r2,[r4,#5]            ;601
000038  f1040114          ADD      r1,r4,#0x14           ;601
00003c  4640              MOV      r0,r8                 ;601
00003e  f7fffffe          BL       USBH_CtlSendSetup
000042  2002              MOVS     r0,#2                 ;604
000044  7720              STRB     r0,[r4,#0x1c]         ;604
                  |L5.70|
000046  e0d6              B        |L5.502|
000048  7961              LDRB     r1,[r4,#5]            ;609
00004a  4640              MOV      r0,r8                 ;609
00004c  f7fffffe          BL       HCD_GetURB_State
000050  2801              CMP      r0,#1                 ;611
000052  d002              BEQ      |L5.90|
;;;619            if (direction == USB_D2H)
;;;620            {
;;;621              /* Data Direction is IN */
;;;622              phost->Control.state = CTRL_DATA_IN;
;;;623            }
;;;624            else
;;;625            {
;;;626              /* Data Direction is OUT */
;;;627              phost->Control.state = CTRL_DATA_OUT;
;;;628            } 
;;;629          }
;;;630          /* No DATA stage */
;;;631          else
;;;632          {
;;;633            timeout = NODATA_STAGE_TIMEOUT;
;;;634            
;;;635            /* If there is No Data Transfer Stage */
;;;636            if (direction == USB_D2H)
;;;637            {
;;;638              /* Data Direction is IN */
;;;639              phost->Control.state = CTRL_STATUS_OUT;
;;;640            }
;;;641            else
;;;642            {
;;;643              /* Data Direction is OUT */
;;;644              phost->Control.state = CTRL_STATUS_IN;
;;;645            } 
;;;646          }          
;;;647          /* Set the delay timer to enable timeout for data stage completion */
;;;648          phost->Control.timer = HCD_GetCurrentFrame(pdev);
;;;649        }
;;;650        else if(URB_Status == URB_ERROR)
000054  2803              CMP      r0,#3
000056  d01f              BEQ      |L5.152|
000058  e0cd              B        |L5.502|
                  |L5.90|
00005a  7d20              LDRB     r0,[r4,#0x14]         ;613
00005c  f0000080          AND      r0,r0,#0x80           ;613
000060  8b61              LDRH     r1,[r4,#0x1a]         ;616
000062  b159              CBZ      r1,|L5.124|
000064  f2413188          MOV      r1,#0x1388            ;618
000068  f8a91000          STRH     r1,[r9,#0]            ;618
00006c  2880              CMP      r0,#0x80              ;619
00006e  d002              BEQ      |L5.118|
000070  f884a01c          STRB     r10,[r4,#0x1c]        ;627
000074  e009              B        |L5.138|
                  |L5.118|
000076  2003              MOVS     r0,#3                 ;622
000078  7720              STRB     r0,[r4,#0x1c]         ;622
00007a  e006              B        |L5.138|
                  |L5.124|
00007c  2132              MOVS     r1,#0x32              ;633
00007e  f8a91000          STRH     r1,[r9,#0]            ;633
000082  2880              CMP      r0,#0x80              ;636
000084  d006              BEQ      |L5.148|
000086  2007              MOVS     r0,#7                 ;644
000088  7720              STRB     r0,[r4,#0x1c]         ;644
                  |L5.138|
00008a  4640              MOV      r0,r8                 ;648
00008c  f7fffffe          BL       HCD_GetCurrentFrame
000090  8220              STRH     r0,[r4,#0x10]         ;648
000092  e0b0              B        |L5.502|
                  |L5.148|
000094  7726              STRB     r6,[r4,#0x1c]         ;639
000096  e7f8              B        |L5.138|
                  |L5.152|
;;;651        {
;;;652          phost->Control.state = CTRL_ERROR;     
000098  7725              STRB     r5,[r4,#0x1c]
;;;653          phost->Control.status = CTRL_XACTERR;
00009a  f884a012          STRB     r10,[r4,#0x12]
00009e  e0aa              B        |L5.502|
;;;654        }    
;;;655        break;
;;;656        
;;;657      case CTRL_DATA_IN:  
;;;658        /* Issue an IN token */ 
;;;659        USBH_CtlReceiveData(pdev,
0000a0  7923              LDRB     r3,[r4,#4]
0000a2  89a2              LDRH     r2,[r4,#0xc]
0000a4  4640              MOV      r0,r8
0000a6  68a1              LDR      r1,[r4,#8]
0000a8  f7fffffe          BL       USBH_CtlReceiveData
;;;660                            phost->Control.buff, 
;;;661                            phost->Control.length,
;;;662                            phost->Control.hc_num_in);
;;;663     
;;;664        phost->Control.state = CTRL_DATA_IN_WAIT;
0000ac  2004              MOVS     r0,#4
0000ae  7720              STRB     r0,[r4,#0x1c]
;;;665        break;    
0000b0  e0a1              B        |L5.502|
;;;666        
;;;667      case CTRL_DATA_IN_WAIT:
;;;668        
;;;669        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
0000b2  7921              LDRB     r1,[r4,#4]
0000b4  4640              MOV      r0,r8
0000b6  f7fffffe          BL       HCD_GetURB_State
;;;670        
;;;671        /* check is DATA packet transfered successfully */
;;;672        if  (URB_Status == URB_DONE)
0000ba  2801              CMP      r0,#1
0000bc  d100              BNE      |L5.192|
;;;673        { 
;;;674          phost->Control.state = CTRL_STATUS_OUT;
0000be  7726              STRB     r6,[r4,#0x1c]
                  |L5.192|
;;;675        }
;;;676       
;;;677        /* manage error cases*/
;;;678        if  (URB_Status == URB_STALL) 
0000c0  2804              CMP      r0,#4
0000c2  d00c              BEQ      |L5.222|
;;;679        { 
;;;680          /* In stall case, return to previous machine state*/
;;;681          phost->gState =   phost->gStateBkp;
;;;682        }   
;;;683        else if (URB_Status == URB_ERROR)
0000c4  2803              CMP      r0,#3
0000c6  d00d              BEQ      |L5.228|
;;;684        {
;;;685          /* Device error */
;;;686          phost->Control.state = CTRL_ERROR;    
;;;687        }
;;;688        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000c8  4640              MOV      r0,r8
0000ca  f7fffffe          BL       HCD_GetCurrentFrame
0000ce  8a21              LDRH     r1,[r4,#0x10]
0000d0  1a40              SUBS     r0,r0,r1
0000d2  f8b91000          LDRH     r1,[r9,#0]  ; timeout
0000d6  4288              CMP      r0,r1
0000d8  d900              BLS      |L5.220|
;;;689        {
;;;690          /* timeout for IN transfer */
;;;691          phost->Control.state = CTRL_ERROR; 
0000da  7725              STRB     r5,[r4,#0x1c]
                  |L5.220|
0000dc  e08b              B        |L5.502|
                  |L5.222|
0000de  7860              LDRB     r0,[r4,#1]            ;681
0000e0  7020              STRB     r0,[r4,#0]            ;681
0000e2  e088              B        |L5.502|
                  |L5.228|
0000e4  7725              STRB     r5,[r4,#0x1c]         ;686
0000e6  e086              B        |L5.502|
;;;692        }   
;;;693        break;
;;;694        
;;;695      case CTRL_DATA_OUT:
;;;696        /* Start DATA out transfer (only one DATA packet)*/
;;;697        pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
0000e8  7960              LDRB     r0,[r4,#5]
0000ea  eb081040          ADD      r0,r8,r0,LSL #5
0000ee  f88013c5          STRB     r1,[r0,#0x3c5]
;;;698            
;;;699        USBH_CtlSendData (pdev,
0000f2  7963              LDRB     r3,[r4,#5]
0000f4  89a2              LDRH     r2,[r4,#0xc]
0000f6  4640              MOV      r0,r8
0000f8  68a1              LDR      r1,[r4,#8]
0000fa  f7fffffe          BL       USBH_CtlSendData
;;;700                          phost->Control.buff, 
;;;701                          phost->Control.length , 
;;;702                          phost->Control.hc_num_out);
;;;703        
;;;704    
;;;705    
;;;706    
;;;707        
;;;708        phost->Control.state = CTRL_DATA_OUT_WAIT;
0000fe  2006              MOVS     r0,#6
000100  7720              STRB     r0,[r4,#0x1c]
;;;709        break;
000102  e078              B        |L5.502|
;;;710        
;;;711      case CTRL_DATA_OUT_WAIT:
;;;712        
;;;713        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
000104  7961              LDRB     r1,[r4,#5]
000106  4640              MOV      r0,r8
000108  f7fffffe          BL       HCD_GetURB_State
;;;714        if  (URB_Status == URB_DONE)
00010c  2801              CMP      r0,#1
00010e  d006              BEQ      |L5.286|
;;;715        { /* If the Setup Pkt is sent successful, then change the state */
;;;716          phost->Control.state = CTRL_STATUS_IN;
;;;717        }
;;;718        
;;;719        /* handle error cases */
;;;720        else if  (URB_Status == URB_STALL) 
000110  2804              CMP      r0,#4
000112  d007              BEQ      |L5.292|
;;;721        { 
;;;722          /* In stall case, return to previous machine state*/
;;;723          phost->gState =   phost->gStateBkp;
;;;724          phost->Control.state = CTRL_STALLED;  
;;;725        } 
;;;726        else if  (URB_Status == URB_NOTREADY)
000114  2802              CMP      r0,#2
000116  d00a              BEQ      |L5.302|
;;;727        { 
;;;728          /* Nack received from device */
;;;729          phost->Control.state = CTRL_DATA_OUT;
;;;730        }    
;;;731        else if (URB_Status == URB_ERROR)
000118  2803              CMP      r0,#3
00011a  d00b              BEQ      |L5.308|
00011c  e06b              B        |L5.502|
                  |L5.286|
00011e  2007              MOVS     r0,#7                 ;716
000120  7720              STRB     r0,[r4,#0x1c]         ;716
000122  e068              B        |L5.502|
                  |L5.292|
000124  7860              LDRB     r0,[r4,#1]            ;723
000126  7020              STRB     r0,[r4,#0]            ;723
000128  200c              MOVS     r0,#0xc               ;724
00012a  7720              STRB     r0,[r4,#0x1c]         ;724
00012c  e063              B        |L5.502|
                  |L5.302|
00012e  f884a01c          STRB     r10,[r4,#0x1c]        ;729
000132  e060              B        |L5.502|
                  |L5.308|
;;;732        {
;;;733          /* device error */
;;;734          phost->Control.state = CTRL_ERROR;      
000134  7725              STRB     r5,[r4,#0x1c]
000136  e05e              B        |L5.502|
;;;735        } 
;;;736        break;
;;;737        
;;;738        
;;;739      case CTRL_STATUS_IN:
;;;740        /* Send 0 bytes out packet */
;;;741        USBH_CtlReceiveData (pdev,
000138  2200              MOVS     r2,#0
00013a  7923              LDRB     r3,[r4,#4]
00013c  4611              MOV      r1,r2
00013e  4640              MOV      r0,r8
000140  f7fffffe          BL       USBH_CtlReceiveData
;;;742                             0,
;;;743                             0,
;;;744                             phost->Control.hc_num_in);
;;;745        
;;;746        phost->Control.state = CTRL_STATUS_IN_WAIT;
000144  f884b01c          STRB     r11,[r4,#0x1c]
;;;747        
;;;748        break;
000148  e055              B        |L5.502|
;;;749        
;;;750      case CTRL_STATUS_IN_WAIT:
;;;751        
;;;752        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
00014a  7921              LDRB     r1,[r4,#4]
00014c  4640              MOV      r0,r8
00014e  f7fffffe          BL       HCD_GetURB_State
000152  4606              MOV      r6,r0
;;;753        
;;;754        if  ( URB_Status == URB_DONE)
000154  2e01              CMP      r6,#1
000156  d00c              BEQ      |L5.370|
;;;755        { /* Control transfers completed, Exit the State Machine */
;;;756          phost->gState =   phost->gStateBkp;
;;;757          phost->Control.state = CTRL_COMPLETE;
;;;758        }
;;;759        
;;;760        else if (URB_Status == URB_ERROR)
000158  2e03              CMP      r6,#3
00015a  d00f              BEQ      |L5.380|
;;;761        {
;;;762          phost->Control.state = CTRL_ERROR;  
;;;763        }
;;;764        
;;;765        else if((HCD_GetCurrentFrame(pdev)\
00015c  4640              MOV      r0,r8
00015e  f7fffffe          BL       HCD_GetCurrentFrame
000162  8a21              LDRH     r1,[r4,#0x10]
000164  1a40              SUBS     r0,r0,r1
000166  f8b91000          LDRH     r1,[r9,#0]  ; timeout
00016a  4288              CMP      r0,r1
00016c  d908              BLS      |L5.384|
;;;766          - phost->Control.timer) > timeout)
;;;767        {
;;;768          phost->Control.state = CTRL_ERROR; 
00016e  7725              STRB     r5,[r4,#0x1c]
000170  e041              B        |L5.502|
                  |L5.370|
000172  7860              LDRB     r0,[r4,#1]            ;756
000174  7020              STRB     r0,[r4,#0]            ;756
000176  200d              MOVS     r0,#0xd               ;757
000178  7720              STRB     r0,[r4,#0x1c]         ;757
00017a  e03c              B        |L5.502|
                  |L5.380|
00017c  7725              STRB     r5,[r4,#0x1c]         ;762
00017e  e03a              B        |L5.502|
                  |L5.384|
;;;769        }
;;;770         else if(URB_Status == URB_STALL)
000180  2e04              CMP      r6,#4
000182  d138              BNE      |L5.502|
;;;771        {
;;;772          /* Control transfers completed, Exit the State Machine */
;;;773          phost->gState =   phost->gStateBkp;
000184  7860              LDRB     r0,[r4,#1]
000186  7020              STRB     r0,[r4,#0]
;;;774          phost->Control.status = CTRL_STALL;
000188  2004              MOVS     r0,#4
00018a  74a0              STRB     r0,[r4,#0x12]
;;;775          status = USBH_NOT_SUPPORTED;
00018c  2703              MOVS     r7,#3
00018e  e032              B        |L5.502|
;;;776        }
;;;777        break;
;;;778        
;;;779      case CTRL_STATUS_OUT:
;;;780        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
000190  7960              LDRB     r0,[r4,#5]
000192  eb081040          ADD      r0,r8,r0,LSL #5
000196  f89013c5          LDRB     r1,[r0,#0x3c5]
00019a  f0810101          EOR      r1,r1,#1
00019e  f88013c5          STRB     r1,[r0,#0x3c5]
;;;781        USBH_CtlSendData (pdev,
0001a2  2200              MOVS     r2,#0
0001a4  7963              LDRB     r3,[r4,#5]
0001a6  4611              MOV      r1,r2
0001a8  4640              MOV      r0,r8
0001aa  f7fffffe          BL       USBH_CtlSendData
;;;782                          0,
;;;783                          0,
;;;784                          phost->Control.hc_num_out);
;;;785        
;;;786        phost->Control.state = CTRL_STATUS_OUT_WAIT;
0001ae  200a              MOVS     r0,#0xa
0001b0  7720              STRB     r0,[r4,#0x1c]
;;;787        break;
0001b2  e020              B        |L5.502|
;;;788        
;;;789      case CTRL_STATUS_OUT_WAIT: 
;;;790        
;;;791        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
0001b4  7961              LDRB     r1,[r4,#5]
0001b6  4640              MOV      r0,r8
0001b8  f7fffffe          BL       HCD_GetURB_State
;;;792        if  (URB_Status == URB_DONE)
0001bc  2801              CMP      r0,#1
0001be  d004              BEQ      |L5.458|
;;;793        { 
;;;794          phost->gState =   phost->gStateBkp; 
;;;795          phost->Control.state = CTRL_COMPLETE; 
;;;796        }
;;;797        else if  (URB_Status == URB_NOTREADY)
0001c0  2802              CMP      r0,#2
0001c2  d007              BEQ      |L5.468|
;;;798        { 
;;;799          phost->Control.state = CTRL_STATUS_OUT;
;;;800        }      
;;;801        else if (URB_Status == URB_ERROR)
0001c4  2803              CMP      r0,#3
0001c6  d007              BEQ      |L5.472|
0001c8  e015              B        |L5.502|
                  |L5.458|
0001ca  7860              LDRB     r0,[r4,#1]            ;794
0001cc  7020              STRB     r0,[r4,#0]            ;794
0001ce  200d              MOVS     r0,#0xd               ;795
0001d0  7720              STRB     r0,[r4,#0x1c]         ;795
0001d2  e010              B        |L5.502|
                  |L5.468|
0001d4  7726              STRB     r6,[r4,#0x1c]         ;799
0001d6  e00e              B        |L5.502|
                  |L5.472|
;;;802        {
;;;803          phost->Control.state = CTRL_ERROR;      
0001d8  7725              STRB     r5,[r4,#0x1c]
0001da  e00c              B        |L5.502|
;;;804        }
;;;805        break;
;;;806        
;;;807      case CTRL_ERROR:
;;;808        /* 
;;;809        After a halt condition is encountered or an error is detected by the 
;;;810        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;811        PID; i.e., recovery actions via some other pipe are not required for control
;;;812        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;813        required to clear the halt or error condition if the next Setup PID is not 
;;;814        accepted.
;;;815        */
;;;816        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001dc  7ba0              LDRB     r0,[r4,#0xe]
0001de  1c40              ADDS     r0,r0,#1
0001e0  b2c0              UXTB     r0,r0
0001e2  73a0              STRB     r0,[r4,#0xe]
0001e4  2802              CMP      r0,#2
0001e6  d801              BHI      |L5.492|
;;;817        {
;;;818          /* Do the transmission again, starting from SETUP Packet */
;;;819          phost->Control.state = CTRL_SETUP; 
0001e8  7721              STRB     r1,[r4,#0x1c]
0001ea  e004              B        |L5.502|
                  |L5.492|
;;;820        }
;;;821        else
;;;822        {
;;;823          phost->Control.status = CTRL_FAIL;
0001ec  f884b012          STRB     r11,[r4,#0x12]
;;;824          phost->gState =   phost->gStateBkp;
0001f0  7860              LDRB     r0,[r4,#1]
0001f2  7020              STRB     r0,[r4,#0]
;;;825          
;;;826          status = USBH_FAIL;
0001f4  2702              MOVS     r7,#2
                  |L5.502|
;;;827        }
;;;828        break;
;;;829        
;;;830      default:
;;;831        break;
;;;832      }
;;;833      return status;
0001f6  4638              MOV      r0,r7
;;;834    }
0001f8  e8bd9ff0          POP      {r4-r12,pc}
;;;835    
                          ENDP

                  |L5.508|
                          DCD      ||area_number.14||

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;395      */
;;;396    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
000004  b092              SUB      sp,sp,#0x48
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;398      USBH_Status Status = USBH_BUSY;  
00000a  2601              MOVS     r6,#1
;;;399      uint8_t Local_Buffer[64];
;;;400      
;;;401      switch (phost->EnumState)
00000c  78a1              LDRB     r1,[r4,#2]
00000e  2500              MOVS     r5,#0
;;;402      {
;;;403      case ENUM_IDLE:  
;;;404        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;405        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
;;;406        {
;;;407          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
;;;408          
;;;409          /* Issue Reset  */
;;;410          HCD_ResetPort(pdev);
;;;411          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
;;;412          
;;;413          /* modify control channels configuration for MaxPacket size */
;;;414          USBH_Modify_Channel (pdev,
;;;415                               phost->Control.hc_num_out,
;;;416                               0,
;;;417                               0,
;;;418                               0,
;;;419                               phost->Control.ep0size);
;;;420          
;;;421          USBH_Modify_Channel (pdev,
;;;422                               phost->Control.hc_num_in,
;;;423                               0,
;;;424                               0,
;;;425                               0,
;;;426                               phost->Control.ep0size);      
;;;427        }
;;;428        break;
;;;429        
;;;430      case ENUM_GET_FULL_DEV_DESC:  
;;;431        /* Get FULL Device Desc  */
;;;432        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
;;;433          == USBH_OK)
;;;434        {
;;;435          /* user callback for device descriptor available */
;;;436          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
;;;437          phost->EnumState = ENUM_SET_ADDR;
;;;438        }
;;;439        break;
;;;440       
;;;441      case ENUM_SET_ADDR: 
;;;442        /* set address */
;;;443        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
;;;444        {
;;;445          USB_OTG_BSP_mDelay(2);
;;;446          phost->device_prop.address = USBH_DEVICE_ADDRESS;
;;;447          
;;;448          /* user callback for device address assigned */
;;;449          phost->usr_cb->DeviceAddressAssigned();
;;;450          phost->EnumState = ENUM_GET_CFG_DESC;
;;;451          
;;;452          /* modify control channels to update device address */
;;;453          USBH_Modify_Channel (pdev,
;;;454                               phost->Control.hc_num_in,
;;;455                               phost->device_prop.address,
;;;456                               0,
;;;457                               0,
;;;458                               0);
;;;459          
;;;460          USBH_Modify_Channel (pdev,
;;;461                               phost->Control.hc_num_out,
;;;462                               phost->device_prop.address,
;;;463                               0,
;;;464                               0,
;;;465                               0);         
;;;466        }
;;;467        break;
;;;468        
;;;469      case ENUM_GET_CFG_DESC:  
;;;470        /* get standard configuration descriptor */
;;;471        if ( USBH_Get_CfgDesc(pdev, 
;;;472                              phost,
;;;473                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;474        {
;;;475          phost->EnumState = ENUM_GET_FULL_CFG_DESC;
;;;476        }
;;;477        break;
;;;478        
;;;479      case ENUM_GET_FULL_CFG_DESC:  
;;;480        /* get FULL config descriptor (config, interface, endpoints) */
;;;481        if (USBH_Get_CfgDesc(pdev, 
;;;482                             phost,
;;;483                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;484        {
;;;485          /* User callback for configuration descriptors available */
;;;486          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
;;;487                                                          phost->device_prop.Itf_Desc,
;;;488                                                          phost->device_prop.Ep_Desc[0]);
;;;489          
;;;490          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
;;;491        }
;;;492        break;
;;;493        
;;;494      case ENUM_GET_MFC_STRING_DESC:  
;;;495        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
;;;496        { /* Check that Manufacturer String is available */
;;;497          
;;;498          if ( USBH_Get_StringDesc(pdev,
000010  20ff              MOVS     r0,#0xff
000012  f04f0801          MOV      r8,#1                 ;398
000016  290a              CMP      r1,#0xa               ;401
000018  d227              BCS      |L6.106|
00001a  e8dff001          TBB      [pc,r1]               ;401
00001e  0527              DCB      0x05,0x27
000020  375b6579          DCB      0x37,0x5b,0x65,0x79
000024  92abc4ce          DCB      0x92,0xab,0xc4,0xce
000028  2208              MOVS     r2,#8                 ;405
00002a  4621              MOV      r1,r4                 ;405
00002c  4638              MOV      r0,r7                 ;405
00002e  f7fffffe          BL       USBH_Get_DevDesc
000032  2800              CMP      r0,#0                 ;405
000034  d119              BNE      |L6.106|
000036  f8940029          LDRB     r0,[r4,#0x29]         ;407
00003a  71a0              STRB     r0,[r4,#6]            ;407
00003c  4638              MOV      r0,r7                 ;410
00003e  f7fffffe          BL       HCD_ResetPort
000042  f8848002          STRB     r8,[r4,#2]            ;411
000046  79a0              LDRB     r0,[r4,#6]            ;414
000048  2300              MOVS     r3,#0                 ;414
00004a  e9cd5000          STRD     r5,r0,[sp,#0]         ;414
00004e  7961              LDRB     r1,[r4,#5]            ;414
000050  461a              MOV      r2,r3                 ;414
000052  4638              MOV      r0,r7                 ;414
000054  f7fffffe          BL       USBH_Modify_Channel
000058  79a0              LDRB     r0,[r4,#6]            ;421
00005a  2300              MOVS     r3,#0                 ;421
00005c  e9cd5000          STRD     r5,r0,[sp,#0]         ;421
000060  7921              LDRB     r1,[r4,#4]            ;421
000062  461a              MOV      r2,r3                 ;421
000064  4638              MOV      r0,r7                 ;421
000066  f7fffffe          BL       USBH_Modify_Channel
                  |L6.106|
00006a  e0a7              B        |L6.444|
00006c  2212              MOVS     r2,#0x12              ;432
00006e  4621              MOV      r1,r4                 ;432
000070  4638              MOV      r0,r7                 ;432
000072  f7fffffe          BL       USBH_Get_DevDesc
000076  2800              CMP      r0,#0                 ;432
000078  d1f7              BNE      |L6.106|
00007a  f8d40080          LDR      r0,[r4,#0x80]         ;436
00007e  69c1              LDR      r1,[r0,#0x1c]         ;436
000080  f1040022          ADD      r0,r4,#0x22           ;436
000084  4788              BLX      r1                    ;436
000086  2002              MOVS     r0,#2                 ;437
000088  70a0              STRB     r0,[r4,#2]            ;437
00008a  e097              B        |L6.444|
00008c  2201              MOVS     r2,#1                 ;443
00008e  4621              MOV      r1,r4                 ;443
000090  4638              MOV      r0,r7                 ;443
000092  f7fffffe          BL       USBH_SetAddress
000096  2800              CMP      r0,#0                 ;443
000098  d11b              BNE      |L6.210|
00009a  2002              MOVS     r0,#2                 ;445
00009c  f7fffffe          BL       USB_OTG_BSP_mDelay
0000a0  1ca4              ADDS     r4,r4,#2              ;446
0000a2  f884801e          STRB     r8,[r4,#0x1e]         ;446
0000a6  f8d4007e          LDR      r0,[r4,#0x7e]         ;449
0000aa  6a00              LDR      r0,[r0,#0x20]         ;449
0000ac  4780              BLX      r0                    ;449
0000ae  2003              MOVS     r0,#3                 ;450
0000b0  7020              STRB     r0,[r4,#0]            ;450
0000b2  9500              STR      r5,[sp,#0]            ;453
0000b4  9501              STR      r5,[sp,#4]            ;453
0000b6  7fa2              LDRB     r2,[r4,#0x1e]         ;453
0000b8  78a1              LDRB     r1,[r4,#2]            ;453
0000ba  2300              MOVS     r3,#0                 ;453
0000bc  4638              MOV      r0,r7                 ;453
0000be  f7fffffe          BL       USBH_Modify_Channel
0000c2  9500              STR      r5,[sp,#0]            ;460
0000c4  9501              STR      r5,[sp,#4]            ;460
0000c6  7fa2              LDRB     r2,[r4,#0x1e]         ;460
0000c8  78e1              LDRB     r1,[r4,#3]            ;460
0000ca  2300              MOVS     r3,#0                 ;460
0000cc  4638              MOV      r0,r7                 ;460
0000ce  f7fffffe          BL       USBH_Modify_Channel
                  |L6.210|
0000d2  e073              B        |L6.444|
0000d4  2209              MOVS     r2,#9                 ;471
0000d6  4621              MOV      r1,r4                 ;471
0000d8  4638              MOV      r0,r7                 ;471
0000da  f7fffffe          BL       USBH_Get_CfgDesc
0000de  2800              CMP      r0,#0                 ;471
0000e0  d16c              BNE      |L6.444|
0000e2  2004              MOVS     r0,#4                 ;475
0000e4  70a0              STRB     r0,[r4,#2]            ;475
0000e6  e069              B        |L6.444|
0000e8  8ee2              LDRH     r2,[r4,#0x36]         ;481
0000ea  4621              MOV      r1,r4                 ;481
0000ec  4638              MOV      r0,r7                 ;481
0000ee  f7fffffe          BL       USBH_Get_CfgDesc
0000f2  2800              CMP      r0,#0                 ;481
0000f4  d162              BNE      |L6.444|
0000f6  f8d40080          LDR      r0,[r4,#0x80]         ;486
0000fa  f1040250          ADD      r2,r4,#0x50           ;486
0000fe  f104013e          ADD      r1,r4,#0x3e           ;486
000102  6a43              LDR      r3,[r0,#0x24]         ;486
000104  f1040034          ADD      r0,r4,#0x34           ;486
000108  4798              BLX      r3                    ;486
00010a  2005              MOVS     r0,#5                 ;490
00010c  70a0              STRB     r0,[r4,#2]            ;490
00010e  e055              B        |L6.444|
000110  f8942030          LDRB     r2,[r4,#0x30]         ;495
000114  2506              MOVS     r5,#6                 ;401
000116  b16a              CBZ      r2,|L6.308|
000118  9000              STR      r0,[sp,#0]
00011a  ab02              ADD      r3,sp,#8
00011c  4621              MOV      r1,r4
00011e  4638              MOV      r0,r7
000120  f7fffffe          BL       USBH_Get_StringDesc
000124  bb28              CBNZ     r0,|L6.370|
;;;499                                   phost,
;;;500                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;501                                   Local_Buffer , 
;;;502                                   0xff) == USBH_OK)
;;;503          {
;;;504            /* User callback for Manufacturing string */
;;;505            phost->usr_cb->ManufacturerString(Local_Buffer);
000126  f8d40080          LDR      r0,[r4,#0x80]
00012a  6a81              LDR      r1,[r0,#0x28]
00012c  a802              ADD      r0,sp,#8
00012e  4788              BLX      r1
;;;506            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000130  70a5              STRB     r5,[r4,#2]
000132  e043              B        |L6.444|
                  |L6.308|
;;;507          }
;;;508        }
;;;509        else
;;;510        {
;;;511          phost->usr_cb->ManufacturerString("N/A");      
000134  f8d40080          LDR      r0,[r4,#0x80]
000138  6a81              LDR      r1,[r0,#0x28]
00013a  a022              ADR      r0,|L6.452|
00013c  4788              BLX      r1
;;;512          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00013e  70a5              STRB     r5,[r4,#2]
000140  e03c              B        |L6.444|
;;;513        }
;;;514        break;
;;;515        
;;;516      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;517        if (phost->device_prop.Dev_Desc.iProduct != 0)
000142  f8942031          LDRB     r2,[r4,#0x31]
000146  2507              MOVS     r5,#7                 ;401
000148  b16a              CBZ      r2,|L6.358|
;;;518        { /* Check that Product string is available */
;;;519          if ( USBH_Get_StringDesc(pdev,
00014a  9000              STR      r0,[sp,#0]
00014c  ab02              ADD      r3,sp,#8
00014e  4621              MOV      r1,r4
000150  4638              MOV      r0,r7
000152  f7fffffe          BL       USBH_Get_StringDesc
000156  b960              CBNZ     r0,|L6.370|
;;;520                                   phost,
;;;521                                   phost->device_prop.Dev_Desc.iProduct, 
;;;522                                   Local_Buffer, 
;;;523                                   0xff) == USBH_OK)
;;;524          {
;;;525            /* User callback for Product string */
;;;526            phost->usr_cb->ProductString(Local_Buffer);
000158  f8d40080          LDR      r0,[r4,#0x80]
00015c  6ac1              LDR      r1,[r0,#0x2c]
00015e  a802              ADD      r0,sp,#8
000160  4788              BLX      r1
;;;527            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000162  70a5              STRB     r5,[r4,#2]
000164  e02a              B        |L6.444|
                  |L6.358|
;;;528          }
;;;529        }
;;;530        else
;;;531        {
;;;532          phost->usr_cb->ProductString("N/A");
000166  f8d40080          LDR      r0,[r4,#0x80]
00016a  6ac1              LDR      r1,[r0,#0x2c]
00016c  a015              ADR      r0,|L6.452|
00016e  4788              BLX      r1
;;;533          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000170  70a5              STRB     r5,[r4,#2]
                  |L6.370|
000172  e023              B        |L6.444|
;;;534        } 
;;;535        break;
;;;536        
;;;537      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;538        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
000174  f8942032          LDRB     r2,[r4,#0x32]
000178  2508              MOVS     r5,#8                 ;401
00017a  b16a              CBZ      r2,|L6.408|
;;;539        { /* Check that Serial number string is available */    
;;;540          if ( USBH_Get_StringDesc(pdev, 
00017c  9000              STR      r0,[sp,#0]
00017e  ab02              ADD      r3,sp,#8
000180  4621              MOV      r1,r4
000182  4638              MOV      r0,r7
000184  f7fffffe          BL       USBH_Get_StringDesc
000188  b9c0              CBNZ     r0,|L6.444|
;;;541                                   phost,
;;;542                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;543                                   Local_Buffer, 
;;;544                                   0xff) == USBH_OK)
;;;545          {
;;;546            /* User callback for Serial number string */
;;;547            phost->usr_cb->SerialNumString(Local_Buffer);
00018a  f8d40080          LDR      r0,[r4,#0x80]
00018e  6b01              LDR      r1,[r0,#0x30]
000190  a802              ADD      r0,sp,#8
000192  4788              BLX      r1
;;;548            phost->EnumState = ENUM_SET_CONFIGURATION;
000194  70a5              STRB     r5,[r4,#2]
000196  e011              B        |L6.444|
                  |L6.408|
;;;549          }
;;;550        }
;;;551        else
;;;552        {
;;;553          phost->usr_cb->SerialNumString("N/A");      
000198  f8d40080          LDR      r0,[r4,#0x80]
00019c  6b01              LDR      r1,[r0,#0x30]
00019e  a009              ADR      r0,|L6.452|
0001a0  4788              BLX      r1
;;;554          phost->EnumState = ENUM_SET_CONFIGURATION;
0001a2  70a5              STRB     r5,[r4,#2]
0001a4  e00a              B        |L6.444|
;;;555        }  
;;;556        break;
;;;557          
;;;558      case ENUM_SET_CONFIGURATION:
;;;559        /* set configuration  (default config) */
;;;560        if (USBH_SetCfg(pdev, 
0001a6  f8942039          LDRB     r2,[r4,#0x39]
0001aa  4621              MOV      r1,r4
0001ac  4638              MOV      r0,r7
0001ae  f7fffffe          BL       USBH_SetCfg
0001b2  b918              CBNZ     r0,|L6.444|
;;;561                        phost,
;;;562                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;563        {
;;;564          phost->EnumState = ENUM_DEV_CONFIGURED;
0001b4  2009              MOVS     r0,#9
0001b6  70a0              STRB     r0,[r4,#2]
0001b8  e000              B        |L6.444|
;;;565        }
;;;566        break;
;;;567    
;;;568        
;;;569      case ENUM_DEV_CONFIGURED:
;;;570        /* user callback for enumeration done */
;;;571        Status = USBH_OK;
0001ba  2600              MOVS     r6,#0
                  |L6.444|
;;;572        break;
;;;573        
;;;574      default:
;;;575        break;
;;;576      }  
;;;577      return Status;
;;;578    }
0001bc  b012              ADD      sp,sp,#0x48
0001be  4630              MOV      r0,r6                 ;577
0001c0  e8bd81f0          POP      {r4-r8,pc}
;;;579    
                          ENDP

                  |L6.452|
0001c4  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=1

                  USBH_Init PROC
;;;155      */
;;;156    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157                   USB_OTG_CORE_ID_TypeDef coreID,
;;;158                   USBH_HOST *phost,               
;;;159                   USBH_Class_cb_TypeDef *class_cb, 
;;;160                   USBH_Usr_cb_TypeDef *usr_cb)
;;;161    {
000004  4607              MOV      r7,r0
000006  9e06              LDR      r6,[sp,#0x18]
000008  4688              MOV      r8,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
;;;162         
;;;163      /* Hardware Init */
;;;164      USB_OTG_BSP_Init(pdev);  
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       USB_OTG_BSP_Init
;;;165      
;;;166      /* configure GPIO pin used for switching VBUS power */
;;;167      USB_OTG_BSP_ConfigVBUS(0);  
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;168      
;;;169      
;;;170      /* Host de-initializations */
;;;171      USBH_DeInit(pdev, phost);
00001a  4621              MOV      r1,r4
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USBH_DeInit
;;;172      
;;;173      /*Register class and user callbacks */
;;;174      phost->class_cb = class_cb;
000022  f8445f7c          STR      r5,[r4,#0x7c]!
;;;175      phost->usr_cb = usr_cb;  
000026  6066              STR      r6,[r4,#4]
;;;176        
;;;177      /* Start the USB OTG core */     
;;;178       HCD_Init(pdev , coreID);
000028  4641              MOV      r1,r8
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       HCD_Init
;;;179       
;;;180      /* Upon Init call usr call back */
;;;181      phost->usr_cb->Init();
000030  6860              LDR      r0,[r4,#4]
000032  6801              LDR      r1,[r0,#0]
000034  4788              BLX      r1
;;;182      
;;;183      /* Enable Interrupts */
;;;184      USB_OTG_BSP_EnableInterrupt(pdev);
000036  4638              MOV      r0,r7
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  f7ffbffe          B.W      USB_OTG_BSP_EnableInterrupt
;;;185    }
;;;186    
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;218    */
;;;219    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  b5fe              PUSH     {r1-r7,lr}
;;;220    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;221      volatile USBH_Status status = USBH_FAIL;
000006  2502              MOVS     r5,#2
000008  9502              STR      r5,[sp,#8]
;;;222      
;;;223      
;;;224      /* check for Host port events */
;;;225      if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       HCD_IsDeviceConnected
000010  b920              CBNZ     r0,|L8.28|
000012  7820              LDRB     r0,[r4,#0]
000014  b110              CBZ      r0,|L8.28|
;;;226      {
;;;227        if(phost->gState != HOST_DEV_DISCONNECTED) 
000016  2802              CMP      r0,#2
000018  d000              BEQ      |L8.28|
;;;228        {
;;;229          phost->gState = HOST_DEV_DISCONNECTED;
00001a  7025              STRB     r5,[r4,#0]
                  |L8.28|
;;;230        }
;;;231      }
;;;232        
;;;233      switch (phost->gState)
00001c  7820              LDRB     r0,[r4,#0]
00001e  2700              MOVS     r7,#0
;;;234      {
;;;235      
;;;236      case HOST_IDLE :
;;;237        
;;;238        if (HCD_IsDeviceConnected(pdev))  
;;;239        {
;;;240          phost->gState = HOST_DEV_ATTACHED;
;;;241          USB_OTG_BSP_mDelay(100);
;;;242        }
;;;243        break;
;;;244       
;;;245      case HOST_DEV_ATTACHED :
;;;246        
;;;247        phost->usr_cb->DeviceAttached();
;;;248        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
;;;249        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
;;;250      
;;;251        /* Reset USB Device */
;;;252        if ( HCD_ResetPort(pdev) == 0)
;;;253        {
;;;254          phost->usr_cb->ResetDevice();
;;;255          /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
;;;256          Host is Now ready to start the Enumeration 
;;;257          */
;;;258          
;;;259          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
;;;260          
;;;261          phost->gState = HOST_ENUMERATION;
;;;262          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
;;;263            
;;;264          /* Open Control pipes */
;;;265          USBH_Open_Channel (pdev,
;;;266                               phost->Control.hc_num_in,
;;;267                               phost->device_prop.address,
;;;268                               phost->device_prop.speed,
;;;269                               EP_TYPE_CTRL,
;;;270                               phost->Control.ep0size); 
;;;271          
;;;272          /* Open Control pipes */
;;;273          USBH_Open_Channel (pdev,
;;;274                               phost->Control.hc_num_out,
;;;275                               phost->device_prop.address,
;;;276                               phost->device_prop.speed,
;;;277                               EP_TYPE_CTRL,
;;;278                               phost->Control.ep0size);          
;;;279       }
;;;280        break;
;;;281        
;;;282      case HOST_ENUMERATION:     
;;;283        /* Check for enumeration status */  
;;;284        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
;;;285        { 
;;;286          /* The function shall return USBH_OK when full enumeration is complete */
;;;287          
;;;288          /* user callback for end of device basic enumeration */
;;;289          phost->usr_cb->EnumerationDone();
;;;290          
;;;291          phost->gState  = HOST_USR_INPUT;    
;;;292        }
;;;293        break;
;;;294        
;;;295      case HOST_USR_INPUT:    
;;;296        /*The function should return user response true to move to class state */
;;;297        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
;;;298        {
;;;299          if((phost->class_cb->Init(pdev, phost))\
;;;300            == USBH_OK)
;;;301          {
;;;302            phost->gState  = HOST_CLASS_REQUEST;     
;;;303          }     
;;;304        }   
;;;305        break;
;;;306        
;;;307      case HOST_CLASS_REQUEST:  
;;;308        /* process class standard contol requests state machine */ 
;;;309        status = phost->class_cb->Requests(pdev, phost);
;;;310        
;;;311         if(status == USBH_OK)
;;;312         {
;;;313           phost->gState  = HOST_CLASS;
;;;314         }  
;;;315         
;;;316         else
;;;317         {
;;;318           USBH_ErrorHandle(phost, status);
;;;319         }
;;;320     
;;;321        
;;;322        break;    
;;;323      case HOST_CLASS:   
;;;324        /* process class state machine */
;;;325        status = phost->class_cb->Machine(pdev, phost);
;;;326        USBH_ErrorHandle(phost, status);
;;;327        break;       
;;;328        
;;;329      case HOST_CTRL_XFER:
;;;330        /* process control transfer state machine */
;;;331        USBH_HandleControl(pdev, phost);    
;;;332        break;
;;;333        
;;;334      case HOST_SUSPENDED:
;;;335        break;
;;;336      
;;;337      case HOST_ERROR_STATE:
;;;338        /* Re-Initilaize Host for new Enumeration */
;;;339        USBH_DeInit(pdev, phost);
;;;340        phost->usr_cb->DeInit();
;;;341        phost->class_cb->DeInit(pdev, &phost->device_prop);
000020  f1040520          ADD      r5,r4,#0x20
000024  280b              CMP      r0,#0xb               ;233
000026  d247              BCS      |L8.184|
000028  e8dff000          TBB      [pc,r0]               ;233
00002c  06129d46          DCB      0x06,0x12,0x9d,0x46
000030  47647886          DCB      0x47,0x64,0x78,0x86
000034  54468d00          DCB      0x54,0x46,0x8d,0x00
000038  4630              MOV      r0,r6                 ;238
00003a  f7fffffe          BL       HCD_IsDeviceConnected
00003e  2800              CMP      r0,#0                 ;238
000040  d03a              BEQ      |L8.184|
000042  2001              MOVS     r0,#1                 ;240
000044  7020              STRB     r0,[r4,#0]            ;240
000046  e8bd40fe          POP      {r1-r7,lr}            ;241
00004a  2064              MOVS     r0,#0x64              ;241
00004c  f7ffbffe          B.W      USB_OTG_BSP_mDelay
000050  f8d40080          LDR      r0,[r4,#0x80]         ;247
000054  6880              LDR      r0,[r0,#8]            ;247
000056  4780              BLX      r0                    ;247
000058  2100              MOVS     r1,#0                 ;248
00005a  4630              MOV      r0,r6                 ;248
00005c  f7fffffe          BL       USBH_Alloc_Channel
000060  7160              STRB     r0,[r4,#5]            ;248
000062  2180              MOVS     r1,#0x80              ;249
000064  4630              MOV      r0,r6                 ;249
000066  f7fffffe          BL       USBH_Alloc_Channel
00006a  7120              STRB     r0,[r4,#4]            ;249
00006c  4630              MOV      r0,r6                 ;252
00006e  f7fffffe          BL       HCD_ResetPort
000072  2800              CMP      r0,#0                 ;252
000074  d120              BNE      |L8.184|
000076  1d24              ADDS     r4,r4,#4              ;254
000078  6fe0              LDR      r0,[r4,#0x7c]         ;254
00007a  68c0              LDR      r0,[r0,#0xc]          ;254
00007c  4780              BLX      r0                    ;254
00007e  4630              MOV      r0,r6                 ;259
000080  f7fffffe          BL       HCD_GetCurrentSpeed
000084  b2c0              UXTB     r0,r0                 ;259
000086  7760              STRB     r0,[r4,#0x1d]         ;259
000088  2104              MOVS     r1,#4                 ;261
00008a  f8041c04          STRB     r1,[r4,#-4]           ;261
00008e  6fe1              LDR      r1,[r4,#0x7c]         ;262
000090  6989              LDR      r1,[r1,#0x18]         ;262
000092  4788              BLX      r1                    ;262
000094  78a0              LDRB     r0,[r4,#2]            ;265
000096  e9cd7000          STRD     r7,r0,[sp,#0]         ;265
00009a  7f63              LDRB     r3,[r4,#0x1d]         ;265
00009c  7f22              LDRB     r2,[r4,#0x1c]         ;265
00009e  7821              LDRB     r1,[r4,#0]            ;265
0000a0  4630              MOV      r0,r6                 ;265
0000a2  f7fffffe          BL       USBH_Open_Channel
0000a6  78a0              LDRB     r0,[r4,#2]            ;273
0000a8  e9cd7000          STRD     r7,r0,[sp,#0]         ;273
0000ac  7f63              LDRB     r3,[r4,#0x1d]         ;273
0000ae  7f22              LDRB     r2,[r4,#0x1c]         ;273
0000b0  7861              LDRB     r1,[r4,#1]            ;273
0000b2  4630              MOV      r0,r6                 ;273
0000b4  f7fffffe          BL       USBH_Open_Channel
                  |L8.184|
;;;342        break;
;;;343        
;;;344      case HOST_DEV_DISCONNECTED :
;;;345        
;;;346        /* Manage User disconnect operations*/
;;;347        phost->usr_cb->DeviceDisconnected();
;;;348        
;;;349        /* Re-Initilaize Host for new Enumeration */
;;;350        USBH_DeInit(pdev, phost);
;;;351        phost->usr_cb->DeInit();
;;;352        phost->class_cb->DeInit(pdev, &phost->device_prop); 
;;;353        USBH_DeAllocate_AllChannel(pdev);  
;;;354        phost->gState = HOST_IDLE;
;;;355        
;;;356        break;
;;;357        
;;;358      default :
;;;359        break;
;;;360      }
;;;361    
;;;362    }
0000b8  bdfe              POP      {r1-r7,pc}
0000ba  4621              MOV      r1,r4                 ;284
0000bc  4630              MOV      r0,r6                 ;284
0000be  f7fffffe          BL       USBH_HandleEnum
0000c2  2800              CMP      r0,#0                 ;284
0000c4  d1f8              BNE      |L8.184|
0000c6  f8d40080          LDR      r0,[r4,#0x80]         ;289
0000ca  6b40              LDR      r0,[r0,#0x34]         ;289
0000cc  4780              BLX      r0                    ;289
0000ce  2008              MOVS     r0,#8                 ;291
0000d0  7020              STRB     r0,[r4,#0]            ;291
                  |L8.210|
0000d2  bdfe              POP      {r1-r7,pc}
0000d4  f8d40080          LDR      r0,[r4,#0x80]         ;297
0000d8  6b80              LDR      r0,[r0,#0x38]         ;297
0000da  4780              BLX      r0                    ;297
0000dc  2801              CMP      r0,#1                 ;297
0000de  d1f8              BNE      |L8.210|
0000e0  6fe0              LDR      r0,[r4,#0x7c]         ;299
0000e2  4621              MOV      r1,r4                 ;299
0000e4  6802              LDR      r2,[r0,#0]            ;299
0000e6  4630              MOV      r0,r6                 ;299
0000e8  4790              BLX      r2                    ;299
0000ea  2800              CMP      r0,#0                 ;299
0000ec  d1f1              BNE      |L8.210|
0000ee  2005              MOVS     r0,#5                 ;302
0000f0  7020              STRB     r0,[r4,#0]            ;302
0000f2  bdfe              POP      {r1-r7,pc}
0000f4  6fe0              LDR      r0,[r4,#0x7c]         ;309
0000f6  4621              MOV      r1,r4                 ;309
0000f8  6882              LDR      r2,[r0,#8]            ;309
0000fa  4630              MOV      r0,r6                 ;309
0000fc  4790              BLX      r2                    ;309
0000fe  9002              STR      r0,[sp,#8]            ;309
000100  f89d0008          LDRB     r0,[sp,#8]            ;311
000104  b138              CBZ      r0,|L8.278|
000106  f89d1008          LDRB     r1,[sp,#8]            ;318
00010a  b003              ADD      sp,sp,#0xc            ;318
00010c  4620              MOV      r0,r4                 ;318
00010e  e8bd40f0          POP      {r4-r7,lr}            ;318
000112  f7ffbffe          B.W      USBH_ErrorHandle
                  |L8.278|
000116  2006              MOVS     r0,#6                 ;313
000118  7020              STRB     r0,[r4,#0]            ;313
00011a  bdfe              POP      {r1-r7,pc}
00011c  6fe0              LDR      r0,[r4,#0x7c]         ;325
00011e  4621              MOV      r1,r4                 ;325
000120  68c2              LDR      r2,[r0,#0xc]          ;325
000122  4630              MOV      r0,r6                 ;325
000124  4790              BLX      r2                    ;325
000126  9002              STR      r0,[sp,#8]            ;325
000128  f89d1008          LDRB     r1,[sp,#8]            ;326
00012c  b003              ADD      sp,sp,#0xc            ;326
00012e  4620              MOV      r0,r4                 ;326
000130  e8bd40f0          POP      {r4-r7,lr}            ;326
000134  f7ffbffe          B.W      USBH_ErrorHandle
000138  b003              ADD      sp,sp,#0xc            ;331
00013a  4621              MOV      r1,r4                 ;331
00013c  4630              MOV      r0,r6                 ;331
00013e  e8bd40f0          POP      {r4-r7,lr}            ;331
000142  f7ffbffe          B.W      USBH_HandleControl
000146  4621              MOV      r1,r4                 ;339
000148  4630              MOV      r0,r6                 ;339
00014a  f7fffffe          BL       USBH_DeInit
00014e  f8d40080          LDR      r0,[r4,#0x80]         ;340
000152  6840              LDR      r0,[r0,#4]            ;340
000154  4780              BLX      r0                    ;340
000156  6fe0              LDR      r0,[r4,#0x7c]         ;341
000158  4629              MOV      r1,r5                 ;341
00015a  6842              LDR      r2,[r0,#4]            ;341
00015c  b003              ADD      sp,sp,#0xc            ;341
00015e  4630              MOV      r0,r6                 ;341
000160  e8bd40f0          POP      {r4-r7,lr}            ;341
000164  4710              BX       r2                    ;341
000166  f8d40080          LDR      r0,[r4,#0x80]         ;347
00016a  6900              LDR      r0,[r0,#0x10]         ;347
00016c  4780              BLX      r0                    ;347
00016e  4621              MOV      r1,r4                 ;350
000170  4630              MOV      r0,r6                 ;350
000172  f7fffffe          BL       USBH_DeInit
000176  f8d40080          LDR      r0,[r4,#0x80]         ;351
00017a  6840              LDR      r0,[r0,#4]            ;351
00017c  4780              BLX      r0                    ;351
00017e  6fe0              LDR      r0,[r4,#0x7c]         ;352
000180  4629              MOV      r1,r5                 ;352
000182  6842              LDR      r2,[r0,#4]            ;352
000184  4630              MOV      r0,r6                 ;352
000186  4790              BLX      r2                    ;352
000188  4630              MOV      r0,r6                 ;353
00018a  f7fffffe          BL       USBH_DeAllocate_AllChannel
00018e  7027              STRB     r7,[r4,#0]            ;354
000190  bdfe              POP      {r1-r7,pc}
;;;363    
                          ENDP


                          AREA ||i.USBH_SOF||, CODE, READONLY, ALIGN=1

                  USBH_SOF PROC
;;;143    
;;;144    uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
000000  2000              MOVS     r0,#0
;;;145    {
;;;146      /* This callback could be used to implement a scheduler process */
;;;147      return 0;  
;;;148    }
000002  4770              BX       lr
;;;149    /**
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  USBH_HCD_INT_cb
                          DCD      USBH_SOF
                          DCD      USBH_Connected
                          DCD      USBH_Disconnected

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  USBH_HCD_INT_fops
                          DCD      USBH_HCD_INT_cb

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  timeout
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_usbh_core_c_2210222f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REVSH|
#line 144
|__asm___11_usbh_core_c_2210222f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
