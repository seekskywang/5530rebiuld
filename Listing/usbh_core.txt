; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usbh_core.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usbh_core.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usbh_core.crf ..\USB\STM32_USB_HOST_Library\Core\src\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connected||, CODE, READONLY, ALIGN=1

                  USBH_Connected PROC
;;;117    */
;;;118    uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
000000  2101              MOVS     r1,#1
;;;119    {
;;;120      pdev->host.ConnSts = 1;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;121      return 0;
000006  2000              MOVS     r0,#0
;;;122    }
000008  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;192      */
;;;193    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;195      /* Software Init */
;;;196      
;;;197      phost->gState = HOST_IDLE;
000006  2000              MOVS     r0,#0
000008  7020              STRB     r0,[r4,#0]
;;;198      phost->gStateBkp = HOST_IDLE; 
00000a  7060              STRB     r0,[r4,#1]
;;;199      phost->EnumState = ENUM_IDLE;
00000c  70a0              STRB     r0,[r4,#2]
;;;200      phost->RequestState = CMD_SEND;  
00000e  2101              MOVS     r1,#1
000010  70e1              STRB     r1,[r4,#3]
;;;201      
;;;202      phost->Control.state = CTRL_SETUP;
000012  7721              STRB     r1,[r4,#0x1c]
;;;203      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000014  2240              MOVS     r2,#0x40
000016  71a2              STRB     r2,[r4,#6]
;;;204      
;;;205      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
000018  f8840020          STRB     r0,[r4,#0x20]
;;;206      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
00001c  f8841021          STRB     r1,[r4,#0x21]
;;;207      
;;;208      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000020  7921              LDRB     r1,[r4,#4]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Free_Channel
;;;209      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
000028  7961              LDRB     r1,[r4,#5]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USBH_Free_Channel
;;;210      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;211    }
000032  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP


                          AREA ||i.USBH_Disconnected||, CODE, READONLY, ALIGN=1

                  USBH_Disconnected PROC
;;;130    
;;;131    uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
000000  2100              MOVS     r1,#0
;;;132    {
;;;133      pdev->host.ConnSts = 0;
000002  f8c01310          STR      r1,[r0,#0x310]
;;;134      return 0;  
000006  2000              MOVS     r0,#0
;;;135    }
000008  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;370      */
;;;371    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4604              MOV      r4,r0
;;;373      /* Error unrecovered or not supported device speed */
;;;374      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
;;;375           (errType == USBH_UNRECOVERED_ERROR) )
;;;376      {
;;;377        phost->usr_cb->UnrecoveredError(); 
;;;378        phost->gState = HOST_ERROR_STATE;   
000004  250a              MOVS     r5,#0xa
000006  2905              CMP      r1,#5                 ;374
000008  d00a              BEQ      |L4.32|
00000a  2904              CMP      r1,#4                 ;375
00000c  d008              BEQ      |L4.32|
;;;379      }  
;;;380      /* USB host restart requested from application layer */
;;;381      else if(errType == USBH_APPLY_DEINIT)
00000e  2906              CMP      r1,#6
000010  d10b              BNE      |L4.42|
;;;382      {
;;;383        phost->gState = HOST_ERROR_STATE;  
000012  7025              STRB     r5,[r4,#0]
;;;384        /* user callback for initalization */
;;;385        phost->usr_cb->Init();
000014  f8d40080          LDR      r0,[r4,#0x80]
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  4700              BX       r0
                  |L4.32|
000020  f8d40080          LDR      r0,[r4,#0x80]         ;377
000024  6c40              LDR      r0,[r0,#0x44]         ;377
000026  4780              BLX      r0                    ;377
000028  7025              STRB     r5,[r4,#0]            ;378
                  |L4.42|
;;;386      } 
;;;387    }
00002a  bd70              POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;586      */
;;;587    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;588    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;589      uint8_t direction;  
;;;590      static uint16_t timeout = 0;
;;;591      USBH_Status status = USBH_OK;
000008  2600              MOVS     r6,#0
;;;592      URB_STATE URB_Status = URB_IDLE;
;;;593      
;;;594      phost->Control.status = CTRL_START;
00000a  2000              MOVS     r0,#0
00000c  74a0              STRB     r0,[r4,#0x12]
;;;595    
;;;596      
;;;597      switch (phost->Control.state)
00000e  7f20              LDRB     r0,[r4,#0x1c]
000010  2509              MOVS     r5,#9
000012  2101              MOVS     r1,#1
;;;598      {
;;;599      case CTRL_SETUP:
;;;600        /* send a SETUP packet */
;;;601        USBH_CtlSendSetup     (pdev, 
;;;602    	                   phost->Control.setup.d8 , 
;;;603    	                   phost->Control.hc_num_out);  
;;;604        phost->Control.state = CTRL_SETUP_WAIT;  
;;;605        break; 
;;;606        
;;;607      case CTRL_SETUP_WAIT:
;;;608        
;;;609        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
;;;610        /* case SETUP packet sent successfully */
;;;611        if(URB_Status == URB_DONE)
;;;612        { 
;;;613          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
;;;614          
;;;615          /* check if there is a data stage */
;;;616          if (phost->Control.setup.b.wLength.w != 0 )
;;;617          {        
;;;618            timeout = DATA_STAGE_TIMEOUT;
000014  f8df91f4          LDR      r9,|L5.524|
000018  f04f080b          MOV      r8,#0xb               ;597
00001c  f04f0b08          MOV      r11,#8                ;597
000020  f04f0a05          MOV      r10,#5                ;597
000024  280c              CMP      r0,#0xc               ;597
000026  d20f              BCS      |L5.72|
000028  e8dff000          TBB      [pc,r0]               ;597
00002c  ed060f3c          DCB      0xed,0x06,0x0f,0x3c
000030  4562708b          DCB      0x45,0x62,0x70,0x8b
000034  94b9cbe0          DCB      0x94,0xb9,0xcb,0xe0
000038  7962              LDRB     r2,[r4,#5]            ;601
00003a  f1040114          ADD      r1,r4,#0x14           ;601
00003e  4638              MOV      r0,r7                 ;601
000040  f7fffffe          BL       USBH_CtlSendSetup
000044  2002              MOVS     r0,#2                 ;604
000046  7720              STRB     r0,[r4,#0x1c]         ;604
                  |L5.72|
000048  e0dd              B        |L5.518|
00004a  7961              LDRB     r1,[r4,#5]            ;609
00004c  4638              MOV      r0,r7                 ;609
00004e  f7fffffe          BL       HCD_GetURB_State
000052  2801              CMP      r0,#1                 ;611
000054  d002              BEQ      |L5.92|
;;;619            if (direction == USB_D2H)
;;;620            {
;;;621              /* Data Direction is IN */
;;;622              phost->Control.state = CTRL_DATA_IN;
;;;623            }
;;;624            else
;;;625            {
;;;626              /* Data Direction is OUT */
;;;627              phost->Control.state = CTRL_DATA_OUT;
;;;628            } 
;;;629          }
;;;630          /* No DATA stage */
;;;631          else
;;;632          {
;;;633            timeout = NODATA_STAGE_TIMEOUT;
;;;634            
;;;635            /* If there is No Data Transfer Stage */
;;;636            if (direction == USB_D2H)
;;;637            {
;;;638              /* Data Direction is IN */
;;;639              phost->Control.state = CTRL_STATUS_OUT;
;;;640            }
;;;641            else
;;;642            {
;;;643              /* Data Direction is OUT */
;;;644              phost->Control.state = CTRL_STATUS_IN;
;;;645            } 
;;;646          }          
;;;647          /* Set the delay timer to enable timeout for data stage completion */
;;;648          phost->Control.timer = HCD_GetCurrentFrame(pdev);
;;;649        }
;;;650        else if(URB_Status == URB_ERROR)
000056  2803              CMP      r0,#3
000058  d01f              BEQ      |L5.154|
00005a  e0d4              B        |L5.518|
                  |L5.92|
00005c  7d20              LDRB     r0,[r4,#0x14]         ;613
00005e  f0000080          AND      r0,r0,#0x80           ;613
000062  8b61              LDRH     r1,[r4,#0x1a]         ;616
000064  b159              CBZ      r1,|L5.126|
000066  f2413188          MOV      r1,#0x1388            ;618
00006a  f8a91000          STRH     r1,[r9,#0]            ;618
00006e  2880              CMP      r0,#0x80              ;619
000070  d002              BEQ      |L5.120|
000072  f884a01c          STRB     r10,[r4,#0x1c]        ;627
000076  e009              B        |L5.140|
                  |L5.120|
000078  2003              MOVS     r0,#3                 ;622
00007a  7720              STRB     r0,[r4,#0x1c]         ;622
00007c  e006              B        |L5.140|
                  |L5.126|
00007e  2132              MOVS     r1,#0x32              ;633
000080  f8a91000          STRH     r1,[r9,#0]            ;633
000084  2880              CMP      r0,#0x80              ;636
000086  d006              BEQ      |L5.150|
000088  2007              MOVS     r0,#7                 ;644
00008a  7720              STRB     r0,[r4,#0x1c]         ;644
                  |L5.140|
00008c  4638              MOV      r0,r7                 ;648
00008e  f7fffffe          BL       HCD_GetCurrentFrame
000092  8220              STRH     r0,[r4,#0x10]         ;648
000094  e0b7              B        |L5.518|
                  |L5.150|
000096  7725              STRB     r5,[r4,#0x1c]         ;639
000098  e7f8              B        |L5.140|
                  |L5.154|
;;;651        {
;;;652          phost->Control.state = CTRL_ERROR;     
00009a  f884801c          STRB     r8,[r4,#0x1c]
;;;653          phost->Control.status = CTRL_XACTERR;
00009e  f884a012          STRB     r10,[r4,#0x12]
0000a2  e0b0              B        |L5.518|
;;;654        }    
;;;655        break;
;;;656        
;;;657      case CTRL_DATA_IN:  
;;;658        /* Issue an IN token */ 
;;;659        USBH_CtlReceiveData(pdev,
0000a4  7923              LDRB     r3,[r4,#4]
0000a6  89a2              LDRH     r2,[r4,#0xc]
0000a8  4638              MOV      r0,r7
0000aa  68a1              LDR      r1,[r4,#8]
0000ac  f7fffffe          BL       USBH_CtlReceiveData
;;;660                            phost->Control.buff, 
;;;661                            phost->Control.length,
;;;662                            phost->Control.hc_num_in);
;;;663     
;;;664        phost->Control.state = CTRL_DATA_IN_WAIT;
0000b0  2004              MOVS     r0,#4
0000b2  7720              STRB     r0,[r4,#0x1c]
;;;665        break;    
0000b4  e0a7              B        |L5.518|
;;;666        
;;;667      case CTRL_DATA_IN_WAIT:
;;;668        
;;;669        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
0000b6  7921              LDRB     r1,[r4,#4]
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       HCD_GetURB_State
;;;670        
;;;671        /* check is DATA packet transfered successfully */
;;;672        if  (URB_Status == URB_DONE)
0000be  2801              CMP      r0,#1
0000c0  d100              BNE      |L5.196|
;;;673        { 
;;;674          phost->Control.state = CTRL_STATUS_OUT;
0000c2  7725              STRB     r5,[r4,#0x1c]
                  |L5.196|
;;;675        }
;;;676       
;;;677        /* manage error cases*/
;;;678        if  (URB_Status == URB_STALL) 
0000c4  2804              CMP      r0,#4
0000c6  d00d              BEQ      |L5.228|
;;;679        { 
;;;680          /* In stall case, return to previous machine state*/
;;;681          phost->gState =   phost->gStateBkp;
;;;682        }   
;;;683        else if (URB_Status == URB_ERROR)
0000c8  2803              CMP      r0,#3
0000ca  d00e              BEQ      |L5.234|
;;;684        {
;;;685          /* Device error */
;;;686          phost->Control.state = CTRL_ERROR;    
;;;687        }
;;;688        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000cc  4638              MOV      r0,r7
0000ce  f7fffffe          BL       HCD_GetCurrentFrame
0000d2  8a21              LDRH     r1,[r4,#0x10]
0000d4  1a40              SUBS     r0,r0,r1
0000d6  f8b91000          LDRH     r1,[r9,#0]  ; timeout
0000da  4288              CMP      r0,r1
0000dc  d901              BLS      |L5.226|
;;;689        {
;;;690          /* timeout for IN transfer */
;;;691          phost->Control.state = CTRL_ERROR; 
0000de  f884801c          STRB     r8,[r4,#0x1c]
                  |L5.226|
0000e2  e090              B        |L5.518|
                  |L5.228|
0000e4  7860              LDRB     r0,[r4,#1]            ;681
0000e6  7020              STRB     r0,[r4,#0]            ;681
0000e8  e08d              B        |L5.518|
                  |L5.234|
0000ea  f884801c          STRB     r8,[r4,#0x1c]         ;686
0000ee  e08a              B        |L5.518|
;;;692        }   
;;;693        break;
;;;694        
;;;695      case CTRL_DATA_OUT:
;;;696        /* Start DATA out transfer (only one DATA packet)*/
;;;697        pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
0000f0  7960              LDRB     r0,[r4,#5]
0000f2  eb071040          ADD      r0,r7,r0,LSL #5
0000f6  f88013c5          STRB     r1,[r0,#0x3c5]
;;;698            
;;;699        USBH_CtlSendData (pdev,
0000fa  7963              LDRB     r3,[r4,#5]
0000fc  89a2              LDRH     r2,[r4,#0xc]
0000fe  4638              MOV      r0,r7
000100  68a1              LDR      r1,[r4,#8]
000102  f7fffffe          BL       USBH_CtlSendData
;;;700                          phost->Control.buff, 
;;;701                          phost->Control.length , 
;;;702                          phost->Control.hc_num_out);
;;;703        
;;;704    
;;;705    
;;;706    
;;;707        
;;;708        phost->Control.state = CTRL_DATA_OUT_WAIT;
000106  2006              MOVS     r0,#6
000108  7720              STRB     r0,[r4,#0x1c]
;;;709        break;
00010a  e07c              B        |L5.518|
;;;710        
;;;711      case CTRL_DATA_OUT_WAIT:
;;;712        
;;;713        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
00010c  7961              LDRB     r1,[r4,#5]
00010e  4638              MOV      r0,r7
000110  f7fffffe          BL       HCD_GetURB_State
;;;714        if  (URB_Status == URB_DONE)
000114  2801              CMP      r0,#1
000116  d006              BEQ      |L5.294|
;;;715        { /* If the Setup Pkt is sent successful, then change the state */
;;;716          phost->Control.state = CTRL_STATUS_IN;
;;;717        }
;;;718        
;;;719        /* handle error cases */
;;;720        else if  (URB_Status == URB_STALL) 
000118  2804              CMP      r0,#4
00011a  d007              BEQ      |L5.300|
;;;721        { 
;;;722          /* In stall case, return to previous machine state*/
;;;723          phost->gState =   phost->gStateBkp;
;;;724          phost->Control.state = CTRL_STALLED;  
;;;725        } 
;;;726        else if  (URB_Status == URB_NOTREADY)
00011c  2802              CMP      r0,#2
00011e  d00a              BEQ      |L5.310|
;;;727        { 
;;;728          /* Nack received from device */
;;;729          phost->Control.state = CTRL_DATA_OUT;
;;;730        }    
;;;731        else if (URB_Status == URB_ERROR)
000120  2803              CMP      r0,#3
000122  d00b              BEQ      |L5.316|
000124  e06f              B        |L5.518|
                  |L5.294|
000126  2007              MOVS     r0,#7                 ;716
000128  7720              STRB     r0,[r4,#0x1c]         ;716
00012a  e06c              B        |L5.518|
                  |L5.300|
00012c  7860              LDRB     r0,[r4,#1]            ;723
00012e  7020              STRB     r0,[r4,#0]            ;723
000130  200c              MOVS     r0,#0xc               ;724
000132  7720              STRB     r0,[r4,#0x1c]         ;724
000134  e067              B        |L5.518|
                  |L5.310|
000136  f884a01c          STRB     r10,[r4,#0x1c]        ;729
00013a  e064              B        |L5.518|
                  |L5.316|
;;;732        {
;;;733          /* device error */
;;;734          phost->Control.state = CTRL_ERROR;      
00013c  f884801c          STRB     r8,[r4,#0x1c]
000140  e061              B        |L5.518|
;;;735        } 
;;;736        break;
;;;737        
;;;738        
;;;739      case CTRL_STATUS_IN:
;;;740        /* Send 0 bytes out packet */
;;;741        USBH_CtlReceiveData (pdev,
000142  2200              MOVS     r2,#0
000144  7923              LDRB     r3,[r4,#4]
000146  4611              MOV      r1,r2
000148  4638              MOV      r0,r7
00014a  f7fffffe          BL       USBH_CtlReceiveData
;;;742                             0,
;;;743                             0,
;;;744                             phost->Control.hc_num_in);
;;;745        
;;;746        phost->Control.state = CTRL_STATUS_IN_WAIT;
00014e  f884b01c          STRB     r11,[r4,#0x1c]
;;;747        
;;;748        break;
000152  e058              B        |L5.518|
;;;749        
;;;750      case CTRL_STATUS_IN_WAIT:
;;;751        
;;;752        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
000154  7921              LDRB     r1,[r4,#4]
000156  4638              MOV      r0,r7
000158  f7fffffe          BL       HCD_GetURB_State
00015c  4605              MOV      r5,r0
;;;753        
;;;754        if  ( URB_Status == URB_DONE)
00015e  2d01              CMP      r5,#1
000160  d00d              BEQ      |L5.382|
;;;755        { /* Control transfers completed, Exit the State Machine */
;;;756          phost->gState =   phost->gStateBkp;
;;;757          phost->Control.state = CTRL_COMPLETE;
;;;758        }
;;;759        
;;;760        else if (URB_Status == URB_ERROR)
000162  2d03              CMP      r5,#3
000164  d010              BEQ      |L5.392|
;;;761        {
;;;762          phost->Control.state = CTRL_ERROR;  
;;;763        }
;;;764        
;;;765        else if((HCD_GetCurrentFrame(pdev)\
000166  4638              MOV      r0,r7
000168  f7fffffe          BL       HCD_GetCurrentFrame
00016c  8a21              LDRH     r1,[r4,#0x10]
00016e  1a40              SUBS     r0,r0,r1
000170  f8b91000          LDRH     r1,[r9,#0]  ; timeout
000174  4288              CMP      r0,r1
000176  d90a              BLS      |L5.398|
;;;766          - phost->Control.timer) > timeout)
;;;767        {
;;;768          phost->Control.state = CTRL_ERROR; 
000178  f884801c          STRB     r8,[r4,#0x1c]
00017c  e043              B        |L5.518|
                  |L5.382|
00017e  7860              LDRB     r0,[r4,#1]            ;756
000180  7020              STRB     r0,[r4,#0]            ;756
000182  200d              MOVS     r0,#0xd               ;757
000184  7720              STRB     r0,[r4,#0x1c]         ;757
000186  e03e              B        |L5.518|
                  |L5.392|
000188  f884801c          STRB     r8,[r4,#0x1c]         ;762
00018c  e03b              B        |L5.518|
                  |L5.398|
;;;769        }
;;;770         else if(URB_Status == URB_STALL)
00018e  2d04              CMP      r5,#4
000190  d139              BNE      |L5.518|
;;;771        {
;;;772          /* Control transfers completed, Exit the State Machine */
;;;773          phost->gState =   phost->gStateBkp;
000192  7860              LDRB     r0,[r4,#1]
000194  7020              STRB     r0,[r4,#0]
;;;774          phost->Control.status = CTRL_STALL;
000196  2004              MOVS     r0,#4
000198  74a0              STRB     r0,[r4,#0x12]
;;;775          status = USBH_NOT_SUPPORTED;
00019a  2603              MOVS     r6,#3
00019c  e033              B        |L5.518|
;;;776        }
;;;777        break;
;;;778        
;;;779      case CTRL_STATUS_OUT:
;;;780        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
00019e  7960              LDRB     r0,[r4,#5]
0001a0  eb071040          ADD      r0,r7,r0,LSL #5
0001a4  f89013c5          LDRB     r1,[r0,#0x3c5]
0001a8  f0810101          EOR      r1,r1,#1
0001ac  f88013c5          STRB     r1,[r0,#0x3c5]
;;;781        USBH_CtlSendData (pdev,
0001b0  2200              MOVS     r2,#0
0001b2  7963              LDRB     r3,[r4,#5]
0001b4  4611              MOV      r1,r2
0001b6  4638              MOV      r0,r7
0001b8  f7fffffe          BL       USBH_CtlSendData
;;;782                          0,
;;;783                          0,
;;;784                          phost->Control.hc_num_out);
;;;785        
;;;786        phost->Control.state = CTRL_STATUS_OUT_WAIT;
0001bc  200a              MOVS     r0,#0xa
0001be  7720              STRB     r0,[r4,#0x1c]
;;;787        break;
0001c0  e021              B        |L5.518|
;;;788        
;;;789      case CTRL_STATUS_OUT_WAIT: 
;;;790        
;;;791        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
0001c2  7961              LDRB     r1,[r4,#5]
0001c4  4638              MOV      r0,r7
0001c6  f7fffffe          BL       HCD_GetURB_State
;;;792        if  (URB_Status == URB_DONE)
0001ca  2801              CMP      r0,#1
0001cc  d004              BEQ      |L5.472|
;;;793        { 
;;;794          phost->gState =   phost->gStateBkp; 
;;;795          phost->Control.state = CTRL_COMPLETE; 
;;;796        }
;;;797        else if  (URB_Status == URB_NOTREADY)
0001ce  2802              CMP      r0,#2
0001d0  d007              BEQ      |L5.482|
;;;798        { 
;;;799          phost->Control.state = CTRL_STATUS_OUT;
;;;800        }      
;;;801        else if (URB_Status == URB_ERROR)
0001d2  2803              CMP      r0,#3
0001d4  d007              BEQ      |L5.486|
0001d6  e016              B        |L5.518|
                  |L5.472|
0001d8  7860              LDRB     r0,[r4,#1]            ;794
0001da  7020              STRB     r0,[r4,#0]            ;794
0001dc  200d              MOVS     r0,#0xd               ;795
0001de  7720              STRB     r0,[r4,#0x1c]         ;795
0001e0  e011              B        |L5.518|
                  |L5.482|
0001e2  7725              STRB     r5,[r4,#0x1c]         ;799
0001e4  e00f              B        |L5.518|
                  |L5.486|
;;;802        {
;;;803          phost->Control.state = CTRL_ERROR;      
0001e6  f884801c          STRB     r8,[r4,#0x1c]
0001ea  e00c              B        |L5.518|
;;;804        }
;;;805        break;
;;;806        
;;;807      case CTRL_ERROR:
;;;808        /* 
;;;809        After a halt condition is encountered or an error is detected by the 
;;;810        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;811        PID; i.e., recovery actions via some other pipe are not required for control
;;;812        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;813        required to clear the halt or error condition if the next Setup PID is not 
;;;814        accepted.
;;;815        */
;;;816        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001ec  7ba0              LDRB     r0,[r4,#0xe]
0001ee  1c40              ADDS     r0,r0,#1
0001f0  b2c0              UXTB     r0,r0
0001f2  73a0              STRB     r0,[r4,#0xe]
0001f4  2802              CMP      r0,#2
0001f6  d801              BHI      |L5.508|
;;;817        {
;;;818          /* Do the transmission again, starting from SETUP Packet */
;;;819          phost->Control.state = CTRL_SETUP; 
0001f8  7721              STRB     r1,[r4,#0x1c]
0001fa  e004              B        |L5.518|
                  |L5.508|
;;;820        }
;;;821        else
;;;822        {
;;;823          phost->Control.status = CTRL_FAIL;
0001fc  f884b012          STRB     r11,[r4,#0x12]
;;;824          phost->gState =   phost->gStateBkp;
000200  7860              LDRB     r0,[r4,#1]
000202  7020              STRB     r0,[r4,#0]
;;;825          
;;;826          status = USBH_FAIL;
000204  2602              MOVS     r6,#2
                  |L5.518|
;;;827        }
;;;828        break;
;;;829        
;;;830      default:
;;;831        break;
;;;832      }
;;;833      return status;
000206  4630              MOV      r0,r6
;;;834    }
000208  e8bd9ff0          POP      {r4-r12,pc}
;;;835    
                          ENDP

                  |L5.524|
                          DCD      ||area_number.14||

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;395      */
;;;396    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;397    {
000004  b092              SUB      sp,sp,#0x48
000006  4606              MOV      r6,r0
000008  460c              MOV      r4,r1
;;;398      USBH_Status Status = USBH_BUSY;  
00000a  2501              MOVS     r5,#1
;;;399      uint8_t Local_Buffer[64];
;;;400      
;;;401      switch (phost->EnumState)
00000c  78a1              LDRB     r1,[r4,#2]
00000e  2700              MOVS     r7,#0
;;;402      {
;;;403      case ENUM_IDLE:  
;;;404        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;405        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
;;;406        {
;;;407          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
;;;408          
;;;409          /* Issue Reset  */
;;;410          HCD_ResetPort(pdev);
;;;411          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
;;;412          
;;;413          /* modify control channels configuration for MaxPacket size */
;;;414          USBH_Modify_Channel (pdev,
;;;415                               phost->Control.hc_num_out,
;;;416                               0,
;;;417                               0,
;;;418                               0,
;;;419                               phost->Control.ep0size);
;;;420          
;;;421          USBH_Modify_Channel (pdev,
;;;422                               phost->Control.hc_num_in,
;;;423                               0,
;;;424                               0,
;;;425                               0,
;;;426                               phost->Control.ep0size);      
;;;427        }
;;;428        break;
;;;429        
;;;430      case ENUM_GET_FULL_DEV_DESC:  
;;;431        /* Get FULL Device Desc  */
;;;432        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
;;;433          == USBH_OK)
;;;434        {
;;;435          /* user callback for device descriptor available */
;;;436          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
;;;437          phost->EnumState = ENUM_SET_ADDR;
;;;438        }
;;;439        break;
;;;440       
;;;441      case ENUM_SET_ADDR: 
;;;442        /* set address */
;;;443        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
;;;444        {
;;;445          USB_OTG_BSP_mDelay(2);
;;;446          phost->device_prop.address = USBH_DEVICE_ADDRESS;
;;;447          
;;;448          /* user callback for device address assigned */
;;;449          phost->usr_cb->DeviceAddressAssigned();
;;;450          phost->EnumState = ENUM_GET_CFG_DESC;
;;;451          
;;;452          /* modify control channels to update device address */
;;;453          USBH_Modify_Channel (pdev,
;;;454                               phost->Control.hc_num_in,
;;;455                               phost->device_prop.address,
;;;456                               0,
;;;457                               0,
;;;458                               0);
;;;459          
;;;460          USBH_Modify_Channel (pdev,
;;;461                               phost->Control.hc_num_out,
;;;462                               phost->device_prop.address,
;;;463                               0,
;;;464                               0,
;;;465                               0);         
;;;466        }
;;;467        break;
;;;468        
;;;469      case ENUM_GET_CFG_DESC:  
;;;470        /* get standard configuration descriptor */
;;;471        if ( USBH_Get_CfgDesc(pdev, 
;;;472                              phost,
;;;473                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;474        {
;;;475          phost->EnumState = ENUM_GET_FULL_CFG_DESC;
;;;476        }
;;;477        break;
;;;478        
;;;479      case ENUM_GET_FULL_CFG_DESC:  
;;;480        /* get FULL config descriptor (config, interface, endpoints) */
;;;481        if (USBH_Get_CfgDesc(pdev, 
;;;482                             phost,
;;;483                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;484        {
;;;485          /* User callback for configuration descriptors available */
;;;486          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
;;;487                                                          phost->device_prop.Itf_Desc,
;;;488                                                          phost->device_prop.Ep_Desc[0]);
;;;489          
;;;490          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
;;;491        }
;;;492        break;
;;;493        
;;;494      case ENUM_GET_MFC_STRING_DESC:  
;;;495        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
;;;496        { /* Check that Manufacturer String is available */
;;;497          
;;;498          if ( USBH_Get_StringDesc(pdev,
000010  20ff              MOVS     r0,#0xff
000012  46a8              MOV      r8,r5                 ;398
000014  290a              CMP      r1,#0xa               ;401
000016  d227              BCS      |L6.104|
000018  e8dff001          TBB      [pc,r1]               ;401
00001c  0527375c          DCB      0x05,0x27,0x37,0x5c
000020  667a93ac          DCB      0x66,0x7a,0x93,0xac
000024  c5cf              DCB      0xc5,0xcf
000026  2208              MOVS     r2,#8                 ;405
000028  4621              MOV      r1,r4                 ;405
00002a  4630              MOV      r0,r6                 ;405
00002c  f7fffffe          BL       USBH_Get_DevDesc
000030  2800              CMP      r0,#0                 ;405
000032  d119              BNE      |L6.104|
000034  f8940029          LDRB     r0,[r4,#0x29]         ;407
000038  71a0              STRB     r0,[r4,#6]            ;407
00003a  4630              MOV      r0,r6                 ;410
00003c  f7fffffe          BL       HCD_ResetPort
000040  f8848002          STRB     r8,[r4,#2]            ;411
000044  79a0              LDRB     r0,[r4,#6]            ;414
000046  2300              MOVS     r3,#0                 ;414
000048  e9cd7000          STRD     r7,r0,[sp,#0]         ;414
00004c  7961              LDRB     r1,[r4,#5]            ;414
00004e  461a              MOV      r2,r3                 ;414
000050  4630              MOV      r0,r6                 ;414
000052  f7fffffe          BL       USBH_Modify_Channel
000056  79a0              LDRB     r0,[r4,#6]            ;421
000058  2300              MOVS     r3,#0                 ;421
00005a  e9cd7000          STRD     r7,r0,[sp,#0]         ;421
00005e  7921              LDRB     r1,[r4,#4]            ;421
000060  461a              MOV      r2,r3                 ;421
000062  4630              MOV      r0,r6                 ;421
000064  f7fffffe          BL       USBH_Modify_Channel
                  |L6.104|
000068  e0a8              B        |L6.444|
00006a  2212              MOVS     r2,#0x12              ;432
00006c  4621              MOV      r1,r4                 ;432
00006e  4630              MOV      r0,r6                 ;432
000070  f7fffffe          BL       USBH_Get_DevDesc
000074  2800              CMP      r0,#0                 ;432
000076  d1f7              BNE      |L6.104|
000078  f8d40080          LDR      r0,[r4,#0x80]         ;436
00007c  69c1              LDR      r1,[r0,#0x1c]         ;436
00007e  f1040022          ADD      r0,r4,#0x22           ;436
000082  4788              BLX      r1                    ;436
000084  2002              MOVS     r0,#2                 ;437
000086  70a0              STRB     r0,[r4,#2]            ;437
000088  e098              B        |L6.444|
00008a  2201              MOVS     r2,#1                 ;443
00008c  4621              MOV      r1,r4                 ;443
00008e  4630              MOV      r0,r6                 ;443
000090  f7fffffe          BL       USBH_SetAddress
000094  2800              CMP      r0,#0                 ;443
000096  d11c              BNE      |L6.210|
000098  2002              MOVS     r0,#2                 ;445
00009a  f7fffffe          BL       USB_OTG_BSP_mDelay
00009e  f1040404          ADD      r4,r4,#4              ;446
0000a2  f884801c          STRB     r8,[r4,#0x1c]         ;446
0000a6  6fe0              LDR      r0,[r4,#0x7c]         ;449
0000a8  6a00              LDR      r0,[r0,#0x20]         ;449
0000aa  4780              BLX      r0                    ;449
0000ac  2003              MOVS     r0,#3                 ;450
0000ae  f8040c02          STRB     r0,[r4,#-2]           ;450
0000b2  9700              STR      r7,[sp,#0]            ;453
0000b4  9701              STR      r7,[sp,#4]            ;453
0000b6  7f22              LDRB     r2,[r4,#0x1c]         ;453
0000b8  7821              LDRB     r1,[r4,#0]            ;453
0000ba  2300              MOVS     r3,#0                 ;453
0000bc  4630              MOV      r0,r6                 ;453
0000be  f7fffffe          BL       USBH_Modify_Channel
0000c2  9700              STR      r7,[sp,#0]            ;460
0000c4  9701              STR      r7,[sp,#4]            ;460
0000c6  7f22              LDRB     r2,[r4,#0x1c]         ;460
0000c8  7861              LDRB     r1,[r4,#1]            ;460
0000ca  2300              MOVS     r3,#0                 ;460
0000cc  4630              MOV      r0,r6                 ;460
0000ce  f7fffffe          BL       USBH_Modify_Channel
                  |L6.210|
0000d2  e073              B        |L6.444|
0000d4  2209              MOVS     r2,#9                 ;471
0000d6  4621              MOV      r1,r4                 ;471
0000d8  4630              MOV      r0,r6                 ;471
0000da  f7fffffe          BL       USBH_Get_CfgDesc
0000de  2800              CMP      r0,#0                 ;471
0000e0  d16c              BNE      |L6.444|
0000e2  2004              MOVS     r0,#4                 ;475
0000e4  70a0              STRB     r0,[r4,#2]            ;475
0000e6  e069              B        |L6.444|
0000e8  8ee2              LDRH     r2,[r4,#0x36]         ;481
0000ea  4621              MOV      r1,r4                 ;481
0000ec  4630              MOV      r0,r6                 ;481
0000ee  f7fffffe          BL       USBH_Get_CfgDesc
0000f2  2800              CMP      r0,#0                 ;481
0000f4  d162              BNE      |L6.444|
0000f6  f8d40080          LDR      r0,[r4,#0x80]         ;486
0000fa  f1040250          ADD      r2,r4,#0x50           ;486
0000fe  f104013e          ADD      r1,r4,#0x3e           ;486
000102  6a43              LDR      r3,[r0,#0x24]         ;486
000104  f1040034          ADD      r0,r4,#0x34           ;486
000108  4798              BLX      r3                    ;486
00010a  2005              MOVS     r0,#5                 ;490
00010c  70a0              STRB     r0,[r4,#2]            ;490
00010e  e055              B        |L6.444|
000110  f8942030          LDRB     r2,[r4,#0x30]         ;495
000114  2706              MOVS     r7,#6                 ;401
000116  b16a              CBZ      r2,|L6.308|
000118  9000              STR      r0,[sp,#0]
00011a  ab02              ADD      r3,sp,#8
00011c  4621              MOV      r1,r4
00011e  4630              MOV      r0,r6
000120  f7fffffe          BL       USBH_Get_StringDesc
000124  bb28              CBNZ     r0,|L6.370|
;;;499                                   phost,
;;;500                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;501                                   Local_Buffer , 
;;;502                                   0xff) == USBH_OK)
;;;503          {
;;;504            /* User callback for Manufacturing string */
;;;505            phost->usr_cb->ManufacturerString(Local_Buffer);
000126  f8d40080          LDR      r0,[r4,#0x80]
00012a  6a81              LDR      r1,[r0,#0x28]
00012c  a802              ADD      r0,sp,#8
00012e  4788              BLX      r1
;;;506            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000130  70a7              STRB     r7,[r4,#2]
000132  e043              B        |L6.444|
                  |L6.308|
;;;507          }
;;;508        }
;;;509        else
;;;510        {
;;;511          phost->usr_cb->ManufacturerString("N/A");      
000134  f8d40080          LDR      r0,[r4,#0x80]
000138  6a81              LDR      r1,[r0,#0x28]
00013a  a022              ADR      r0,|L6.452|
00013c  4788              BLX      r1
;;;512          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00013e  70a7              STRB     r7,[r4,#2]
000140  e03c              B        |L6.444|
;;;513        }
;;;514        break;
;;;515        
;;;516      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;517        if (phost->device_prop.Dev_Desc.iProduct != 0)
000142  f8942031          LDRB     r2,[r4,#0x31]
000146  2707              MOVS     r7,#7                 ;401
000148  b16a              CBZ      r2,|L6.358|
;;;518        { /* Check that Product string is available */
;;;519          if ( USBH_Get_StringDesc(pdev,
00014a  9000              STR      r0,[sp,#0]
00014c  ab02              ADD      r3,sp,#8
00014e  4621              MOV      r1,r4
000150  4630              MOV      r0,r6
000152  f7fffffe          BL       USBH_Get_StringDesc
000156  b960              CBNZ     r0,|L6.370|
;;;520                                   phost,
;;;521                                   phost->device_prop.Dev_Desc.iProduct, 
;;;522                                   Local_Buffer, 
;;;523                                   0xff) == USBH_OK)
;;;524          {
;;;525            /* User callback for Product string */
;;;526            phost->usr_cb->ProductString(Local_Buffer);
000158  f8d40080          LDR      r0,[r4,#0x80]
00015c  6ac1              LDR      r1,[r0,#0x2c]
00015e  a802              ADD      r0,sp,#8
000160  4788              BLX      r1
;;;527            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000162  70a7              STRB     r7,[r4,#2]
000164  e02a              B        |L6.444|
                  |L6.358|
;;;528          }
;;;529        }
;;;530        else
;;;531        {
;;;532          phost->usr_cb->ProductString("N/A");
000166  f8d40080          LDR      r0,[r4,#0x80]
00016a  6ac1              LDR      r1,[r0,#0x2c]
00016c  a015              ADR      r0,|L6.452|
00016e  4788              BLX      r1
;;;533          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000170  70a7              STRB     r7,[r4,#2]
                  |L6.370|
000172  e023              B        |L6.444|
;;;534        } 
;;;535        break;
;;;536        
;;;537      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;538        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
000174  f8942032          LDRB     r2,[r4,#0x32]
000178  2708              MOVS     r7,#8                 ;401
00017a  b16a              CBZ      r2,|L6.408|
;;;539        { /* Check that Serial number string is available */    
;;;540          if ( USBH_Get_StringDesc(pdev, 
00017c  9000              STR      r0,[sp,#0]
00017e  ab02              ADD      r3,sp,#8
000180  4621              MOV      r1,r4
000182  4630              MOV      r0,r6
000184  f7fffffe          BL       USBH_Get_StringDesc
000188  b9c0              CBNZ     r0,|L6.444|
;;;541                                   phost,
;;;542                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;543                                   Local_Buffer, 
;;;544                                   0xff) == USBH_OK)
;;;545          {
;;;546            /* User callback for Serial number string */
;;;547            phost->usr_cb->SerialNumString(Local_Buffer);
00018a  f8d40080          LDR      r0,[r4,#0x80]
00018e  6b01              LDR      r1,[r0,#0x30]
000190  a802              ADD      r0,sp,#8
000192  4788              BLX      r1
;;;548            phost->EnumState = ENUM_SET_CONFIGURATION;
000194  70a7              STRB     r7,[r4,#2]
000196  e011              B        |L6.444|
                  |L6.408|
;;;549          }
;;;550        }
;;;551        else
;;;552        {
;;;553          phost->usr_cb->SerialNumString("N/A");      
000198  f8d40080          LDR      r0,[r4,#0x80]
00019c  6b01              LDR      r1,[r0,#0x30]
00019e  a009              ADR      r0,|L6.452|
0001a0  4788              BLX      r1
;;;554          phost->EnumState = ENUM_SET_CONFIGURATION;
0001a2  70a7              STRB     r7,[r4,#2]
0001a4  e00a              B        |L6.444|
;;;555        }  
;;;556        break;
;;;557          
;;;558      case ENUM_SET_CONFIGURATION:
;;;559        /* set configuration  (default config) */
;;;560        if (USBH_SetCfg(pdev, 
0001a6  f8942039          LDRB     r2,[r4,#0x39]
0001aa  4621              MOV      r1,r4
0001ac  4630              MOV      r0,r6
0001ae  f7fffffe          BL       USBH_SetCfg
0001b2  b918              CBNZ     r0,|L6.444|
;;;561                        phost,
;;;562                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;563        {
;;;564          phost->EnumState = ENUM_DEV_CONFIGURED;
0001b4  2009              MOVS     r0,#9
0001b6  70a0              STRB     r0,[r4,#2]
0001b8  e000              B        |L6.444|
;;;565        }
;;;566        break;
;;;567    
;;;568        
;;;569      case ENUM_DEV_CONFIGURED:
;;;570        /* user callback for enumeration done */
;;;571        Status = USBH_OK;
0001ba  2500              MOVS     r5,#0
                  |L6.444|
;;;572        break;
;;;573        
;;;574      default:
;;;575        break;
;;;576      }  
;;;577      return Status;
;;;578    }
0001bc  b012              ADD      sp,sp,#0x48
0001be  4628              MOV      r0,r5                 ;577
0001c0  e8bd81f0          POP      {r4-r8,pc}
;;;579    
                          ENDP

                  |L6.452|
0001c4  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=1

                  USBH_Init PROC
;;;155      */
;;;156    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157                   USB_OTG_CORE_ID_TypeDef coreID,
;;;158                   USBH_HOST *phost,               
;;;159                   USBH_Class_cb_TypeDef *class_cb, 
;;;160                   USBH_Usr_cb_TypeDef *usr_cb)
;;;161    {
000004  4607              MOV      r7,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  460e              MOV      r6,r1
00000c  ed9d8a08          VLDR     s16,[sp,#0x20]
000010  4614              MOV      r4,r2
000012  461d              MOV      r5,r3
;;;162         
;;;163      /* Hardware Init */
;;;164      USB_OTG_BSP_Init(pdev);  
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       USB_OTG_BSP_Init
;;;165      
;;;166      /* configure GPIO pin used for switching VBUS power */
;;;167      USB_OTG_BSP_ConfigVBUS(0);  
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;168      
;;;169      
;;;170      /* Host de-initializations */
;;;171      USBH_DeInit(pdev, phost);
000020  4621              MOV      r1,r4
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       USBH_DeInit
;;;172      
;;;173      /*Register class and user callbacks */
;;;174      phost->class_cb = class_cb;
000028  67e5              STR      r5,[r4,#0x7c]
;;;175      phost->usr_cb = usr_cb;  
00002a  ed848a20          VSTR     s16,[r4,#0x80]
;;;176        
;;;177      /* Start the USB OTG core */     
;;;178       HCD_Init(pdev , coreID);
00002e  4631              MOV      r1,r6
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       HCD_Init
;;;179       
;;;180      /* Upon Init call usr call back */
;;;181      phost->usr_cb->Init();
000036  f8d40080          LDR      r0,[r4,#0x80]
00003a  6800              LDR      r0,[r0,#0]
00003c  4780              BLX      r0
;;;182      
;;;183      /* Enable Interrupts */
;;;184      USB_OTG_BSP_EnableInterrupt(pdev);
00003e  ecbd8b02          VPOP     {d8}
000042  4638              MOV      r0,r7
000044  e8bd41f0          POP      {r4-r8,lr}
000048  f7ffbffe          B.W      USB_OTG_BSP_EnableInterrupt
;;;185    }
;;;186    
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;218    */
;;;219    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;220    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;221      volatile USBH_Status status = USBH_FAIL;
;;;222      
;;;223      
;;;224      /* check for Host port events */
;;;225      if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       HCD_IsDeviceConnected
00000e  b928              CBNZ     r0,|L8.28|
000010  7820              LDRB     r0,[r4,#0]
000012  b118              CBZ      r0,|L8.28|
;;;226      {
;;;227        if(phost->gState != HOST_DEV_DISCONNECTED) 
000014  2802              CMP      r0,#2
000016  d001              BEQ      |L8.28|
;;;228        {
;;;229          phost->gState = HOST_DEV_DISCONNECTED;
000018  2002              MOVS     r0,#2
00001a  7020              STRB     r0,[r4,#0]
                  |L8.28|
;;;230        }
;;;231      }
;;;232        
;;;233      switch (phost->gState)
00001c  7820              LDRB     r0,[r4,#0]
00001e  2700              MOVS     r7,#0                 ;225
;;;234      {
;;;235      
;;;236      case HOST_IDLE :
;;;237        
;;;238        if (HCD_IsDeviceConnected(pdev))  
;;;239        {
;;;240          phost->gState = HOST_DEV_ATTACHED;
;;;241          USB_OTG_BSP_mDelay(100);
;;;242        }
;;;243        break;
;;;244       
;;;245      case HOST_DEV_ATTACHED :
;;;246        
;;;247        phost->usr_cb->DeviceAttached();
;;;248        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
;;;249        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
;;;250      
;;;251        /* Reset USB Device */
;;;252        if ( HCD_ResetPort(pdev) == 0)
;;;253        {
;;;254          phost->usr_cb->ResetDevice();
;;;255          /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
;;;256          Host is Now ready to start the Enumeration 
;;;257          */
;;;258          
;;;259          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
;;;260          
;;;261          phost->gState = HOST_ENUMERATION;
;;;262          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
;;;263            
;;;264          /* Open Control pipes */
;;;265          USBH_Open_Channel (pdev,
;;;266                               phost->Control.hc_num_in,
;;;267                               phost->device_prop.address,
;;;268                               phost->device_prop.speed,
;;;269                               EP_TYPE_CTRL,
;;;270                               phost->Control.ep0size); 
;;;271          
;;;272          /* Open Control pipes */
;;;273          USBH_Open_Channel (pdev,
;;;274                               phost->Control.hc_num_out,
;;;275                               phost->device_prop.address,
;;;276                               phost->device_prop.speed,
;;;277                               EP_TYPE_CTRL,
;;;278                               phost->Control.ep0size);          
;;;279       }
;;;280        break;
;;;281        
;;;282      case HOST_ENUMERATION:     
;;;283        /* Check for enumeration status */  
;;;284        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
;;;285        { 
;;;286          /* The function shall return USBH_OK when full enumeration is complete */
;;;287          
;;;288          /* user callback for end of device basic enumeration */
;;;289          phost->usr_cb->EnumerationDone();
;;;290          
;;;291          phost->gState  = HOST_USR_INPUT;    
;;;292        }
;;;293        break;
;;;294        
;;;295      case HOST_USR_INPUT:    
;;;296        /*The function should return user response true to move to class state */
;;;297        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
;;;298        {
;;;299          if((phost->class_cb->Init(pdev, phost))\
;;;300            == USBH_OK)
;;;301          {
;;;302            phost->gState  = HOST_CLASS_REQUEST;     
;;;303          }     
;;;304        }   
;;;305        break;
;;;306        
;;;307      case HOST_CLASS_REQUEST:  
;;;308        /* process class standard contol requests state machine */ 
;;;309        status = phost->class_cb->Requests(pdev, phost);
;;;310        
;;;311         if(status == USBH_OK)
;;;312         {
;;;313           phost->gState  = HOST_CLASS;
;;;314         }  
;;;315         
;;;316         else
;;;317         {
;;;318           USBH_ErrorHandle(phost, status);
;;;319         }
;;;320     
;;;321        
;;;322        break;    
;;;323      case HOST_CLASS:   
;;;324        /* process class state machine */
;;;325        status = phost->class_cb->Machine(pdev, phost);
;;;326        USBH_ErrorHandle(phost, status);
;;;327        break;       
;;;328        
;;;329      case HOST_CTRL_XFER:
;;;330        /* process control transfer state machine */
;;;331        USBH_HandleControl(pdev, phost);    
;;;332        break;
;;;333        
;;;334      case HOST_SUSPENDED:
;;;335        break;
;;;336      
;;;337      case HOST_ERROR_STATE:
;;;338        /* Re-Initilaize Host for new Enumeration */
;;;339        USBH_DeInit(pdev, phost);
;;;340        phost->usr_cb->DeInit();
;;;341        phost->class_cb->DeInit(pdev, &phost->device_prop);
000020  f1040520          ADD      r5,r4,#0x20
000024  280b              CMP      r0,#0xb               ;233
000026  d248              BCS      |L8.186|
000028  e8dff000          TBB      [pc,r0]               ;233
00002c  06129647          DCB      0x06,0x12,0x96,0x47
000030  49667580          DCB      0x49,0x66,0x75,0x80
000034  56478600          DCB      0x56,0x47,0x86,0x00
000038  4630              MOV      r0,r6                 ;238
00003a  f7fffffe          BL       HCD_IsDeviceConnected
00003e  2800              CMP      r0,#0                 ;238
000040  d03b              BEQ      |L8.186|
000042  2001              MOVS     r0,#1                 ;240
000044  7020              STRB     r0,[r4,#0]            ;240
000046  e8bd41fc          POP      {r2-r8,lr}            ;241
00004a  2064              MOVS     r0,#0x64              ;241
00004c  f7ffbffe          B.W      USB_OTG_BSP_mDelay
000050  f8d40080          LDR      r0,[r4,#0x80]         ;247
000054  6880              LDR      r0,[r0,#8]            ;247
000056  4780              BLX      r0                    ;247
000058  2100              MOVS     r1,#0                 ;248
00005a  4630              MOV      r0,r6                 ;248
00005c  f7fffffe          BL       USBH_Alloc_Channel
000060  7160              STRB     r0,[r4,#5]            ;248
000062  2180              MOVS     r1,#0x80              ;249
000064  4630              MOV      r0,r6                 ;249
000066  f7fffffe          BL       USBH_Alloc_Channel
00006a  7120              STRB     r0,[r4,#4]            ;249
00006c  4630              MOV      r0,r6                 ;252
00006e  f7fffffe          BL       HCD_ResetPort
000072  2800              CMP      r0,#0                 ;252
000074  d121              BNE      |L8.186|
000076  f1040404          ADD      r4,r4,#4              ;254
00007a  6fe0              LDR      r0,[r4,#0x7c]         ;254
00007c  68c0              LDR      r0,[r0,#0xc]          ;254
00007e  4780              BLX      r0                    ;254
000080  4630              MOV      r0,r6                 ;259
000082  f7fffffe          BL       HCD_GetCurrentSpeed
000086  b2c0              UXTB     r0,r0                 ;259
000088  7760              STRB     r0,[r4,#0x1d]         ;259
00008a  2104              MOVS     r1,#4                 ;261
00008c  f8041c04          STRB     r1,[r4,#-4]           ;261
000090  6fe1              LDR      r1,[r4,#0x7c]         ;262
000092  6989              LDR      r1,[r1,#0x18]         ;262
000094  4788              BLX      r1                    ;262
000096  78a0              LDRB     r0,[r4,#2]            ;265
000098  e9cd7000          STRD     r7,r0,[sp,#0]         ;265
00009c  7f63              LDRB     r3,[r4,#0x1d]         ;265
00009e  7f22              LDRB     r2,[r4,#0x1c]         ;265
0000a0  7821              LDRB     r1,[r4,#0]            ;265
0000a2  4630              MOV      r0,r6                 ;265
0000a4  f7fffffe          BL       USBH_Open_Channel
0000a8  78a0              LDRB     r0,[r4,#2]            ;273
0000aa  e9cd7000          STRD     r7,r0,[sp,#0]         ;273
0000ae  7f63              LDRB     r3,[r4,#0x1d]         ;273
0000b0  7f22              LDRB     r2,[r4,#0x1c]         ;273
0000b2  7861              LDRB     r1,[r4,#1]            ;273
0000b4  4630              MOV      r0,r6                 ;273
0000b6  f7fffffe          BL       USBH_Open_Channel
                  |L8.186|
;;;342        break;
;;;343        
;;;344      case HOST_DEV_DISCONNECTED :
;;;345        
;;;346        /* Manage User disconnect operations*/
;;;347        phost->usr_cb->DeviceDisconnected();
;;;348        
;;;349        /* Re-Initilaize Host for new Enumeration */
;;;350        USBH_DeInit(pdev, phost);
;;;351        phost->usr_cb->DeInit();
;;;352        phost->class_cb->DeInit(pdev, &phost->device_prop); 
;;;353        USBH_DeAllocate_AllChannel(pdev);  
;;;354        phost->gState = HOST_IDLE;
;;;355        
;;;356        break;
;;;357        
;;;358      default :
;;;359        break;
;;;360      }
;;;361    
;;;362    }
0000ba  e8bd81fc          POP      {r2-r8,pc}
0000be  4621              MOV      r1,r4                 ;284
0000c0  4630              MOV      r0,r6                 ;284
0000c2  f7fffffe          BL       USBH_HandleEnum
0000c6  2800              CMP      r0,#0                 ;284
0000c8  d1f7              BNE      |L8.186|
0000ca  f8d40080          LDR      r0,[r4,#0x80]         ;289
0000ce  6b40              LDR      r0,[r0,#0x34]         ;289
0000d0  4780              BLX      r0                    ;289
0000d2  2008              MOVS     r0,#8                 ;291
0000d4  7020              STRB     r0,[r4,#0]            ;291
0000d6  e7f0              B        |L8.186|
0000d8  f8d40080          LDR      r0,[r4,#0x80]         ;297
0000dc  6b80              LDR      r0,[r0,#0x38]         ;297
0000de  4780              BLX      r0                    ;297
0000e0  2801              CMP      r0,#1                 ;297
0000e2  d1ea              BNE      |L8.186|
0000e4  6fe0              LDR      r0,[r4,#0x7c]         ;299
0000e6  4621              MOV      r1,r4                 ;299
0000e8  6802              LDR      r2,[r0,#0]            ;299
0000ea  4630              MOV      r0,r6                 ;299
0000ec  4790              BLX      r2                    ;299
0000ee  2800              CMP      r0,#0                 ;299
0000f0  d1e3              BNE      |L8.186|
0000f2  2005              MOVS     r0,#5                 ;302
0000f4  7020              STRB     r0,[r4,#0]            ;302
0000f6  e7e0              B        |L8.186|
0000f8  6fe0              LDR      r0,[r4,#0x7c]         ;309
0000fa  4621              MOV      r1,r4                 ;309
0000fc  6882              LDR      r2,[r0,#8]            ;309
0000fe  4630              MOV      r0,r6                 ;309
000100  4790              BLX      r2                    ;309
000102  4601              MOV      r1,r0                 ;309
000104  b121              CBZ      r1,|L8.272|
000106  4620              MOV      r0,r4                 ;318
000108  e8bd41fc          POP      {r2-r8,lr}            ;318
00010c  f7ffbffe          B.W      USBH_ErrorHandle
                  |L8.272|
000110  2006              MOVS     r0,#6                 ;313
000112  7020              STRB     r0,[r4,#0]            ;313
000114  e7d1              B        |L8.186|
000116  6fe0              LDR      r0,[r4,#0x7c]         ;325
000118  4621              MOV      r1,r4                 ;325
00011a  68c2              LDR      r2,[r0,#0xc]          ;325
00011c  4630              MOV      r0,r6                 ;325
00011e  4790              BLX      r2                    ;325
000120  4601              MOV      r1,r0                 ;325
000122  4620              MOV      r0,r4                 ;326
000124  e8bd41fc          POP      {r2-r8,lr}            ;326
000128  f7ffbffe          B.W      USBH_ErrorHandle
00012c  4621              MOV      r1,r4                 ;331
00012e  4630              MOV      r0,r6                 ;331
000130  e8bd41fc          POP      {r2-r8,lr}            ;331
000134  f7ffbffe          B.W      USBH_HandleControl
000138  4621              MOV      r1,r4                 ;339
00013a  4630              MOV      r0,r6                 ;339
00013c  f7fffffe          BL       USBH_DeInit
000140  f8d40080          LDR      r0,[r4,#0x80]         ;340
000144  6840              LDR      r0,[r0,#4]            ;340
000146  4780              BLX      r0                    ;340
000148  6fe0              LDR      r0,[r4,#0x7c]         ;341
00014a  4629              MOV      r1,r5                 ;341
00014c  6842              LDR      r2,[r0,#4]            ;341
00014e  b002              ADD      sp,sp,#8              ;341
000150  4630              MOV      r0,r6                 ;341
000152  e8bd41f0          POP      {r4-r8,lr}            ;341
000156  4710              BX       r2                    ;341
000158  f8d40080          LDR      r0,[r4,#0x80]         ;347
00015c  6900              LDR      r0,[r0,#0x10]         ;347
00015e  4780              BLX      r0                    ;347
000160  4621              MOV      r1,r4                 ;350
000162  4630              MOV      r0,r6                 ;350
000164  f7fffffe          BL       USBH_DeInit
000168  f8d40080          LDR      r0,[r4,#0x80]         ;351
00016c  6840              LDR      r0,[r0,#4]            ;351
00016e  4780              BLX      r0                    ;351
000170  6fe0              LDR      r0,[r4,#0x7c]         ;352
000172  4629              MOV      r1,r5                 ;352
000174  6842              LDR      r2,[r0,#4]            ;352
000176  4630              MOV      r0,r6                 ;352
000178  4790              BLX      r2                    ;352
00017a  4630              MOV      r0,r6                 ;353
00017c  f7fffffe          BL       USBH_DeAllocate_AllChannel
000180  7027              STRB     r7,[r4,#0]            ;354
000182  e79a              B        |L8.186|
;;;363    
                          ENDP


                          AREA ||i.USBH_SOF||, CODE, READONLY, ALIGN=1

                  USBH_SOF PROC
;;;143    
;;;144    uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
000000  2000              MOVS     r0,#0
;;;145    {
;;;146      /* This callback could be used to implement a scheduler process */
;;;147      return 0;  
;;;148    }
000002  4770              BX       lr
;;;149    /**
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  USBH_HCD_INT_cb
                          DCD      USBH_SOF
                          DCD      USBH_Connected
                          DCD      USBH_Disconnected

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  USBH_HCD_INT_fops
                          DCD      USBH_HCD_INT_cb

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  timeout
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_core.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_usbh_core_c_2210222f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REVSH|
#line 128
|__asm___11_usbh_core_c_2210222f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
