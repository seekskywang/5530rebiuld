; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usbh_hcs.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usbh_hcs.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usbh_hcs.crf ..\USB\STM32_USB_HOST_Library\Core\src\usbh_hcs.c]
                          THUMB

                          AREA ||i.USBH_Alloc_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Alloc_Channel PROC
;;;173      */
;;;174    uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;176      uint16_t hc_num;
;;;177      
;;;178      hc_num =  USBH_GetFreeChannel(pdev);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       USBH_GetFreeChannel
;;;179    
;;;180      if (hc_num != HC_ERROR)
00000c  f5a0417f          SUB      r1,r0,#0xff00
000010  39ff              SUBS     r1,r1,#0xff
000012  d005              BEQ      |L1.32|
;;;181      {
;;;182    	pdev->host.channel[hc_num] = HC_USED | ep_addr;
000014  eb050240          ADD      r2,r5,r0,LSL #1
000018  f4444100          ORR      r1,r4,#0x8000
00001c  f8a2158c          STRH     r1,[r2,#0x58c]
                  |L1.32|
;;;183      }
;;;184      return hc_num;
000020  b2c0              UXTB     r0,r0
;;;185    }
000022  bd70              POP      {r4-r6,pc}
;;;186    
                          ENDP


                          AREA ||i.USBH_DeAllocate_AllChannel||, CODE, READONLY, ALIGN=1

                  USBH_DeAllocate_AllChannel PROC
;;;208      */
;;;209    uint8_t USBH_DeAllocate_AllChannel  (USB_OTG_CORE_HANDLE *pdev)
000000  2102              MOVS     r1,#2
;;;210    {
;;;211       uint8_t idx;
;;;212       
;;;213       for (idx = 2; idx < HC_MAX ; idx ++)
;;;214       {
;;;215    	 pdev->host.channel[idx] = 0;
000002  2200              MOVS     r2,#0
                  |L2.4|
000004  eb000341          ADD      r3,r0,r1,LSL #1
000008  f8a3258c          STRH     r2,[r3,#0x58c]
00000c  1c49              ADDS     r1,r1,#1              ;213
00000e  b2c9              UXTB     r1,r1                 ;213
000010  2908              CMP      r1,#8                 ;213
000012  d3f7              BCC      |L2.4|
;;;216       }
;;;217       return USBH_OK;
000014  2000              MOVS     r0,#0
;;;218    }
000016  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.USBH_Free_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Free_Channel PROC
;;;192      */
;;;193    uint8_t USBH_Free_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t idx)
000000  2908              CMP      r1,#8
;;;194    {
;;;195       if(idx < HC_MAX)
000002  d208              BCS      |L3.22|
;;;196       {
;;;197    	 pdev->host.channel[idx] &= HC_USED_MASK;
000004  eb000041          ADD      r0,r0,r1,LSL #1
000008  f200518c          ADD      r1,r0,#0x58c
00000c  f8b0058c          LDRH     r0,[r0,#0x58c]
000010  f3c0000e          UBFX     r0,r0,#0,#15
000014  8008              STRH     r0,[r1,#0]
                  |L3.22|
;;;198       }
;;;199       return USBH_OK;
000016  2000              MOVS     r0,#0
;;;200    }
000018  4770              BX       lr
;;;201    
                          ENDP


                          AREA ||i.USBH_GetFreeChannel||, CODE, READONLY, ALIGN=1

                  USBH_GetFreeChannel PROC
;;;225      */
;;;226    static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;227    {
;;;228      uint8_t idx = 0;
000002  2000              MOVS     r0,#0
                  |L4.4|
;;;229      
;;;230      for (idx = 0 ; idx < HC_MAX ; idx++)
;;;231      {
;;;232    	if ((pdev->host.channel[idx] & HC_USED) == 0)
000004  eb010240          ADD      r2,r1,r0,LSL #1
000008  f8b2258c          LDRH     r2,[r2,#0x58c]
00000c  0412              LSLS     r2,r2,#16
00000e  d505              BPL      |L4.28|
000010  1c40              ADDS     r0,r0,#1              ;230
000012  b2c0              UXTB     r0,r0                 ;230
000014  2808              CMP      r0,#8                 ;230
000016  d3f5              BCC      |L4.4|
;;;233    	{
;;;234    	   return idx;
;;;235    	} 
;;;236      }
;;;237      return HC_ERROR;
000018  f64f70ff          MOV      r0,#0xffff
                  |L4.28|
;;;238    }
00001c  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.USBH_Modify_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Modify_Channel PROC
;;;139      */
;;;140    uint8_t USBH_Modify_Channel (USB_OTG_CORE_HANDLE *pdev,
000000  b510              PUSH     {r4,lr}
;;;141                                uint8_t hc_num,
;;;142                                uint8_t dev_address,
;;;143                                uint8_t speed,
;;;144                                uint8_t ep_type,
;;;145                                uint16_t mps)
;;;146    {
000002  f8ddc00c          LDR      r12,[sp,#0xc]
;;;147      
;;;148      if(dev_address != 0)
;;;149      {
;;;150        pdev->host.hc[hc_num].dev_addr = dev_address;  
000006  eb001441          ADD      r4,r0,r1,LSL #5
00000a  b10a              CBZ      r2,|L5.16|
00000c  f88423ac          STRB     r2,[r4,#0x3ac]
                  |L5.16|
;;;151      }
;;;152      
;;;153      if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
000010  f8b423b2          LDRH     r2,[r4,#0x3b2]
000014  4562              CMP      r2,r12
000016  d004              BEQ      |L5.34|
000018  f1bc0f00          CMP      r12,#0
00001c  d001              BEQ      |L5.34|
;;;154      {
;;;155        pdev->host.hc[hc_num].max_packet = mps; 
00001e  f8a4c3b2          STRH     r12,[r4,#0x3b2]
                  |L5.34|
;;;156      }
;;;157      
;;;158      if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
000022  f89423af          LDRB     r2,[r4,#0x3af]
000026  429a              CMP      r2,r3
000028  d002              BEQ      |L5.48|
00002a  b10b              CBZ      r3,|L5.48|
;;;159      {
;;;160        pdev->host.hc[hc_num].speed = speed; 
00002c  f88433af          STRB     r3,[r4,#0x3af]
                  |L5.48|
;;;161      }
;;;162      
;;;163      USB_OTG_HC_Init(pdev, hc_num);
000030  f7fffffe          BL       USB_OTG_HC_Init
;;;164      return HC_OK; 
000034  2000              MOVS     r0,#0
;;;165    
;;;166    }
000036  bd10              POP      {r4,pc}
;;;167    
                          ENDP


                          AREA ||i.USBH_Open_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Open_Channel PROC
;;;101      */
;;;102    uint8_t USBH_Open_Channel  (USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103                                uint8_t hc_num,
;;;104                                uint8_t dev_address,
;;;105                                uint8_t speed,
;;;106                                uint8_t ep_type,
;;;107                                uint16_t mps)
;;;108    {
000004  e9dd6c06          LDRD     r6,r12,[sp,#0x18]
;;;109    
;;;110      pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
000008  eb000441          ADD      r4,r0,r1,LSL #1
00000c  f204558c          ADD      r5,r4,#0x58c
000010  f8b4458c          LDRH     r4,[r4,#0x58c]
000014  f004077f          AND      r7,r4,#0x7f
000018  eb001441          ADD      r4,r0,r1,LSL #5
00001c  f504746b          ADD      r4,r4,#0x3ac
000020  7067              STRB     r7,[r4,#1]
;;;111      pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
000022  882d              LDRH     r5,[r5,#0]
000024  f3c515c0          UBFX     r5,r5,#7,#1
000028  70a5              STRB     r5,[r4,#2]
;;;112      pdev->host.hc[hc_num].dev_addr = dev_address;  
00002a  7022              STRB     r2,[r4,#0]
;;;113      pdev->host.hc[hc_num].ep_type = ep_type;  
00002c  7166              STRB     r6,[r4,#5]
;;;114      pdev->host.hc[hc_num].max_packet = mps; 
00002e  f8a4c006          STRH     r12,[r4,#6]
;;;115      pdev->host.hc[hc_num].speed = speed; 
000032  70e3              STRB     r3,[r4,#3]
;;;116      pdev->host.hc[hc_num].toggle_in = 0; 
000034  f04f0200          MOV      r2,#0
000038  7622              STRB     r2,[r4,#0x18]
;;;117      pdev->host.hc[hc_num].toggle_out = 0;   
00003a  7662              STRB     r2,[r4,#0x19]
00003c  f5a4746b          SUB      r4,r4,#0x3ac
;;;118      if(speed == HPRT0_PRTSPD_HIGH_SPEED)
000040  b913              CBNZ     r3,|L6.72|
;;;119      {
;;;120        pdev->host.hc[hc_num].do_ping = 1;
000042  2201              MOVS     r2,#1
000044  f88423b0          STRB     r2,[r4,#0x3b0]
                  |L6.72|
;;;121      }
;;;122      
;;;123      USB_OTG_HC_Init(pdev, hc_num) ;
000048  f7fffffe          BL       USB_OTG_HC_Init
;;;124      
;;;125      return HC_OK; 
00004c  2000              MOVS     r0,#0
;;;126    
;;;127    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;128    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\USB\\STM32_USB_HOST_Library\\Core\\src\\usbh_hcs.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usbh_hcs_c_cb343afe____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usbh_hcs_c_cb343afe____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usbh_hcs_c_cb343afe____REVSH|
#line 128
|__asm___10_usbh_hcs_c_cb343afe____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
