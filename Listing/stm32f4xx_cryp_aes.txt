; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\stm32f4xx_cryp_aes.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f4xx_cryp_aes.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\stm32f4xx_cryp_aes.crf --no_multibyte_chars ..\Libraries\FWlib\src\stm32f4xx_cryp_aes.c]
                          THUMB

                          AREA ||i.CRYP_AES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CBC PROC
;;;293      */
;;;294    ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;295                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;296                             uint8_t *Output)
;;;297    {
000004  b091              SUB      sp,sp,#0x44
000006  468b              MOV      r11,r1
000008  e9dd961f          LDRD     r9,r6,[sp,#0x7c]
00000c  9d1e              LDR      r5,[sp,#0x78]
00000e  4614              MOV      r4,r2
000010  469a              MOV      r10,r3
;;;298      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;299      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;300      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;301      __IO uint32_t counter = 0;
000012  f04f0800          MOV      r8,#0
000016  f8cd8000          STR      r8,[sp,#0]
;;;302      uint32_t busystatus = 0;
;;;303      ErrorStatus status = SUCCESS;
00001a  2701              MOVS     r7,#1
;;;304      uint32_t keyaddr    = (uint32_t)Key;
;;;305      uint32_t inputaddr  = (uint32_t)Input;
;;;306      uint32_t outputaddr = (uint32_t)Output;
;;;307      uint32_t ivaddr = (uint32_t)InitVectors;
;;;308      uint32_t i = 0;
;;;309    
;;;310      /* Crypto structures initialisation*/
;;;311      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00001c  a805              ADD      r0,sp,#0x14
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;312    
;;;313      switch(Keysize)
000022  f1ba0f80          CMP      r10,#0x80
000026  d04c              BEQ      |L1.194|
000028  0238              LSLS     r0,r7,#8
00002a  f1ba0fc0          CMP      r10,#0xc0
00002e  d057              BEQ      |L1.224|
000030  4582              CMP      r10,r0
000032  d119              BNE      |L1.104|
;;;314      {
;;;315        case 128:
;;;316        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;317        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;318        keyaddr+=4;
;;;319        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;320        keyaddr+=4;
;;;321        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;322        keyaddr+=4;
;;;323        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;324        break;
;;;325        case 192:
;;;326        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;327        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;328        keyaddr+=4;
;;;329        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;330        keyaddr+=4;
;;;331        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;332        keyaddr+=4;
;;;333        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;334        keyaddr+=4;
;;;335        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;336        keyaddr+=4;
;;;337        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;338        break;
;;;339        case 256:
;;;340        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000034  0040              LSLS     r0,r0,#1
000036  9010              STR      r0,[sp,#0x40]
;;;341        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
000038  6820              LDR      r0,[r4,#0]
00003a  ba00              REV      r0,r0
00003c  9005              STR      r0,[sp,#0x14]
;;;342        keyaddr+=4;
;;;343        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
00003e  6860              LDR      r0,[r4,#4]
000040  ba00              REV      r0,r0
000042  9006              STR      r0,[sp,#0x18]
;;;344        keyaddr+=4;
;;;345        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000044  68a0              LDR      r0,[r4,#8]
000046  ba00              REV      r0,r0
000048  9007              STR      r0,[sp,#0x1c]
;;;346        keyaddr+=4;
;;;347        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  ba00              REV      r0,r0
00004e  9008              STR      r0,[sp,#0x20]
;;;348        keyaddr+=4;
;;;349        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000050  6920              LDR      r0,[r4,#0x10]
000052  ba00              REV      r0,r0
000054  9009              STR      r0,[sp,#0x24]
;;;350        keyaddr+=4;
;;;351        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000056  6960              LDR      r0,[r4,#0x14]
000058  ba00              REV      r0,r0
00005a  900a              STR      r0,[sp,#0x28]
;;;352        keyaddr+=4;
;;;353        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  ba00              REV      r0,r0
000060  900b              STR      r0,[sp,#0x2c]
;;;354        keyaddr+=4;
;;;355        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000062  69e0              LDR      r0,[r4,#0x1c]
000064  ba00              REV      r0,r0
000066  900c              STR      r0,[sp,#0x30]
                  |L1.104|
;;;356        break;
;;;357        default:
;;;358        break;
;;;359      }
;;;360    
;;;361      /* CRYP Initialization Vectors */
;;;362      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
000068  f8db0000          LDR      r0,[r11,#0]
00006c  ba00              REV      r0,r0
00006e  9001              STR      r0,[sp,#4]
;;;363      ivaddr+=4;
;;;364      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000070  f8db0004          LDR      r0,[r11,#4]
000074  ba00              REV      r0,r0
000076  9002              STR      r0,[sp,#8]
;;;365      ivaddr+=4;
;;;366      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
000078  f8db0008          LDR      r0,[r11,#8]
00007c  ba00              REV      r0,r0
00007e  9003              STR      r0,[sp,#0xc]
;;;367      ivaddr+=4;
;;;368      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
000080  f8db000c          LDR      r0,[r11,#0xc]
000084  ba00              REV      r0,r0
000086  9004              STR      r0,[sp,#0x10]
000088  9811              LDR      r0,[sp,#0x44]         ;324
;;;369    
;;;370    
;;;371      /*------------------ AES Decryption ------------------*/
;;;372      if(Mode == MODE_DECRYPT) /* AES decryption */
;;;373      {
;;;374        /* Flush IN/OUT FIFOs */
;;;375        CRYP_FIFOFlush();
;;;376    
;;;377        /* Crypto Init for Key preparation for decryption process */
;;;378        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;379        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
;;;380        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
;;;381    
;;;382        CRYP_Init(&AES_CRYP_InitStructure);
;;;383    
;;;384        /* Key Initialisation */
;;;385        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;386    
;;;387        /* Enable Crypto processor */
;;;388        CRYP_Cmd(ENABLE);
;;;389    
;;;390        /* wait until the Busy flag is RESET */
;;;391        do
;;;392        {
;;;393          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;394          counter++;
;;;395        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
00008a  f44f3a80          MOV      r10,#0x10000
00008e  b3d8              CBZ      r0,|L1.264|
;;;396    
;;;397        if (busystatus != RESET)
;;;398       {
;;;399           status = ERROR;
;;;400        }
;;;401        else
;;;402        {
;;;403          /* Crypto Init for decryption process */  
;;;404          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;405        }
;;;406      }
;;;407      /*------------------ AES Encryption ------------------*/
;;;408      else /* AES encryption */
;;;409      {
;;;410        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000090  a805              ADD      r0,sp,#0x14
000092  f7fffffe          BL       CRYP_KeyInit
;;;411    
;;;412        /* Crypto Init for Encryption process */
;;;413        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
000096  f8cd8034          STR      r8,[sp,#0x34]
                  |L1.154|
;;;414      }
;;;415      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
00009a  2028              MOVS     r0,#0x28
00009c  900e              STR      r0,[sp,#0x38]
;;;416      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00009e  2080              MOVS     r0,#0x80
0000a0  900f              STR      r0,[sp,#0x3c]
;;;417      CRYP_Init(&AES_CRYP_InitStructure);
0000a2  a80d              ADD      r0,sp,#0x34
0000a4  f7fffffe          BL       CRYP_Init
;;;418    
;;;419      /* CRYP Initialization Vectors */
;;;420      CRYP_IVInit(&AES_CRYP_IVInitStructure);
0000a8  a801              ADD      r0,sp,#4
0000aa  f7fffffe          BL       CRYP_IVInit
;;;421    
;;;422      /* Flush IN/OUT FIFOs */
;;;423      CRYP_FIFOFlush();
0000ae  f7fffffe          BL       CRYP_FIFOFlush
;;;424    
;;;425      /* Enable Crypto processor */
;;;426      CRYP_Cmd(ENABLE);
0000b2  2001              MOVS     r0,#1
0000b4  f7fffffe          BL       CRYP_Cmd
;;;427    
;;;428      if(CRYP_GetCmdStatus() == DISABLE)
0000b8  f7fffffe          BL       CRYP_GetCmdStatus
0000bc  b3f0              CBZ      r0,|L1.316|
;;;429      {
;;;430        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;431           the CRYP peripheral (please check the device sales type. */
;;;432        return(ERROR);
;;;433      }
;;;434      
;;;435      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
0000be  2400              MOVS     r4,#0
0000c0  e078              B        |L1.436|
                  |L1.194|
0000c2  f8cd8040          STR      r8,[sp,#0x40]         ;316
0000c6  6820              LDR      r0,[r4,#0]            ;317
0000c8  ba00              REV      r0,r0                 ;317
0000ca  9009              STR      r0,[sp,#0x24]         ;317
0000cc  6860              LDR      r0,[r4,#4]            ;319
0000ce  ba00              REV      r0,r0                 ;319
0000d0  900a              STR      r0,[sp,#0x28]         ;319
0000d2  68a0              LDR      r0,[r4,#8]            ;321
0000d4  ba00              REV      r0,r0                 ;321
0000d6  900b              STR      r0,[sp,#0x2c]         ;321
0000d8  68e0              LDR      r0,[r4,#0xc]          ;323
0000da  ba00              REV      r0,r0                 ;323
0000dc  900c              STR      r0,[sp,#0x30]         ;323
0000de  e7c3              B        |L1.104|
                  |L1.224|
0000e0  9010              STR      r0,[sp,#0x40]         ;326
0000e2  6820              LDR      r0,[r4,#0]            ;327
0000e4  ba00              REV      r0,r0                 ;327
0000e6  9007              STR      r0,[sp,#0x1c]         ;327
0000e8  6860              LDR      r0,[r4,#4]            ;329
0000ea  ba00              REV      r0,r0                 ;329
0000ec  9008              STR      r0,[sp,#0x20]         ;329
0000ee  68a0              LDR      r0,[r4,#8]            ;331
0000f0  ba00              REV      r0,r0                 ;331
0000f2  9009              STR      r0,[sp,#0x24]         ;331
0000f4  68e0              LDR      r0,[r4,#0xc]          ;333
0000f6  ba00              REV      r0,r0                 ;333
0000f8  900a              STR      r0,[sp,#0x28]         ;333
0000fa  6920              LDR      r0,[r4,#0x10]         ;335
0000fc  ba00              REV      r0,r0                 ;335
0000fe  900b              STR      r0,[sp,#0x2c]         ;335
000100  6960              LDR      r0,[r4,#0x14]         ;337
000102  ba00              REV      r0,r0                 ;337
000104  900c              STR      r0,[sp,#0x30]         ;337
000106  e7af              B        |L1.104|
                  |L1.264|
000108  e7ff              B        |L1.266|
                  |L1.266|
00010a  f7fffffe          BL       CRYP_FIFOFlush
00010e  2404              MOVS     r4,#4                 ;378
000110  940d              STR      r4,[sp,#0x34]         ;378
000112  2038              MOVS     r0,#0x38              ;379
000114  900e              STR      r0,[sp,#0x38]         ;379
000116  f8cd803c          STR      r8,[sp,#0x3c]         ;380
00011a  a80d              ADD      r0,sp,#0x34           ;382
00011c  f7fffffe          BL       CRYP_Init
000120  a805              ADD      r0,sp,#0x14           ;385
000122  f7fffffe          BL       CRYP_KeyInit
000126  2001              MOVS     r0,#1                 ;388
000128  f7fffffe          BL       CRYP_Cmd
                  |L1.300|
00012c  2010              MOVS     r0,#0x10              ;393
00012e  f7fffffe          BL       CRYP_GetFlagStatus
000132  9900              LDR      r1,[sp,#0]            ;394
000134  1c49              ADDS     r1,r1,#1              ;394
000136  9100              STR      r1,[sp,#0]            ;394
000138  9900              LDR      r1,[sp,#0]            ;395
00013a  e000              B        |L1.318|
                  |L1.316|
00013c  e008              B        |L1.336|
                  |L1.318|
00013e  4551              CMP      r1,r10                ;395
000140  d001              BEQ      |L1.326|
000142  2800              CMP      r0,#0                 ;395
000144  d1f2              BNE      |L1.300|
                  |L1.326|
000146  b108              CBZ      r0,|L1.332|
000148  2700              MOVS     r7,#0                 ;399
00014a  e7a6              B        |L1.154|
                  |L1.332|
00014c  940d              STR      r4,[sp,#0x34]         ;404
00014e  e7a4              B        |L1.154|
                  |L1.336|
000150  2000              MOVS     r0,#0                 ;432
                  |L1.338|
;;;436      {
;;;437    
;;;438        /* Write the Input block in the IN FIFO */
;;;439        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;440        inputaddr+=4;
;;;441        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;442        inputaddr+=4;
;;;443        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;444        inputaddr+=4;
;;;445        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;446        inputaddr+=4;
;;;447        /* Wait until the complete message has been processed */
;;;448        counter = 0;
;;;449        do
;;;450        {
;;;451          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;452          counter++;
;;;453        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;454    
;;;455        if (busystatus != RESET)
;;;456       {
;;;457           status = ERROR;
;;;458        }
;;;459        else
;;;460        {
;;;461    
;;;462          /* Read the Output block from the Output FIFO */
;;;463          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;464          outputaddr+=4;
;;;465          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;466          outputaddr+=4;
;;;467          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;468          outputaddr+=4;
;;;469          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;470          outputaddr+=4;
;;;471        }
;;;472      }
;;;473    
;;;474      /* Disable Crypto */
;;;475      CRYP_Cmd(DISABLE);
;;;476    
;;;477      return status;
;;;478    }
000152  b015              ADD      sp,sp,#0x54
000154  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.344|
000158  6828              LDR      r0,[r5,#0]            ;439
00015a  f7fffffe          BL       CRYP_DataIn
00015e  1d2d              ADDS     r5,r5,#4              ;440
000160  6828              LDR      r0,[r5,#0]            ;441
000162  f7fffffe          BL       CRYP_DataIn
000166  1d2d              ADDS     r5,r5,#4              ;442
000168  6828              LDR      r0,[r5,#0]            ;443
00016a  f7fffffe          BL       CRYP_DataIn
00016e  1d2d              ADDS     r5,r5,#4              ;444
000170  6828              LDR      r0,[r5,#0]            ;445
000172  f7fffffe          BL       CRYP_DataIn
000176  1d2d              ADDS     r5,r5,#4              ;446
000178  f8cd8000          STR      r8,[sp,#0]            ;448
                  |L1.380|
00017c  2010              MOVS     r0,#0x10              ;451
00017e  f7fffffe          BL       CRYP_GetFlagStatus
000182  9900              LDR      r1,[sp,#0]            ;452
000184  1c49              ADDS     r1,r1,#1              ;452
000186  9100              STR      r1,[sp,#0]            ;452
000188  9900              LDR      r1,[sp,#0]            ;453
00018a  4551              CMP      r1,r10                ;453
00018c  d001              BEQ      |L1.402|
00018e  2800              CMP      r0,#0                 ;453
000190  d1f4              BNE      |L1.380|
                  |L1.402|
000192  b108              CBZ      r0,|L1.408|
000194  2700              MOVS     r7,#0                 ;457
000196  e00c              B        |L1.434|
                  |L1.408|
000198  f7fffffe          BL       CRYP_DataOut
00019c  6030              STR      r0,[r6,#0]            ;463
00019e  f7fffffe          BL       CRYP_DataOut
0001a2  6070              STR      r0,[r6,#4]            ;465
0001a4  f7fffffe          BL       CRYP_DataOut
0001a8  60b0              STR      r0,[r6,#8]            ;467
0001aa  f7fffffe          BL       CRYP_DataOut
0001ae  60f0              STR      r0,[r6,#0xc]          ;469
0001b0  3610              ADDS     r6,r6,#0x10           ;469
                  |L1.434|
0001b2  3410              ADDS     r4,r4,#0x10           ;435
                  |L1.436|
0001b4  454c              CMP      r4,r9                 ;435
0001b6  d201              BCS      |L1.444|
0001b8  2f00              CMP      r7,#0                 ;435
0001ba  d1cd              BNE      |L1.344|
                  |L1.444|
0001bc  2000              MOVS     r0,#0                 ;475
0001be  f7fffffe          BL       CRYP_Cmd
0001c2  4638              MOV      r0,r7                 ;477
0001c4  e7c5              B        |L1.338|
;;;479    
                          ENDP


                          AREA ||i.CRYP_AES_CCM||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CCM PROC
;;;1134     */
;;;1135   ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1136                            uint8_t* Nonce, uint32_t NonceSize,
;;;1137                            uint8_t *Key, uint16_t Keysize,
;;;1138                            uint8_t *Input, uint32_t ILength,
;;;1139                            uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
;;;1140                            uint8_t *Output,
;;;1141                            uint8_t *AuthTAG, uint32_t TAGSize)
;;;1142   {
000004  b09f              SUB      sp,sp,#0x7c
000006  469a              MOV      r10,r3
000008  e9dd692d          LDRD     r6,r9,[sp,#0xb4]
00000c  e9dd7132          LDRD     r7,r1,[sp,#0xc8]
000010  e9dd542f          LDRD     r5,r4,[sp,#0xbc]
000014  9831              LDR      r0,[sp,#0xc4]
;;;1143     CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;1144     CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;1145     CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;1146     __IO uint32_t counter = 0;
000016  f04f0b00          MOV      r11,#0
00001a  f8cdb038          STR      r11,[sp,#0x38]
;;;1147     uint32_t busystatus = 0;
;;;1148     ErrorStatus status = SUCCESS;
00001e  f04f0801          MOV      r8,#1
;;;1149     uint32_t keyaddr    = (uint32_t)Key;
;;;1150     uint32_t inputaddr  = (uint32_t)Input;
;;;1151     uint32_t outputaddr = (uint32_t)Output;
;;;1152     uint32_t headeraddr = (uint32_t)Header;
;;;1153     uint32_t tagaddr = (uint32_t)AuthTAG;
000022  910d              STR      r1,[sp,#0x34]
;;;1154     uint32_t headersize = HLength;
;;;1155     uint32_t loopcounter = 0;
000024  2100              MOVS     r1,#0
;;;1156     uint32_t bufferidx = 0;
;;;1157     uint8_t blockb0[16] = {0};/* Block B0 */
000026  f8cdb024          STR      r11,[sp,#0x24]
00002a  f8cdb028          STR      r11,[sp,#0x28]
00002e  f8cdb02c          STR      r11,[sp,#0x2c]
000032  f8cdb030          STR      r11,[sp,#0x30]
;;;1158     uint8_t ctr[16] = {0}; /* Counter */
000036  f8cdb014          STR      r11,[sp,#0x14]
00003a  f8cdb018          STR      r11,[sp,#0x18]
00003e  f8cdb01c          STR      r11,[sp,#0x1c]
000042  f8cdb020          STR      r11,[sp,#0x20]
;;;1159     uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
000046  f8cdb004          STR      r11,[sp,#4]
00004a  f8cdb008          STR      r11,[sp,#8]
00004e  f8cdb00c          STR      r11,[sp,#0xc]
000052  f8cdb010          STR      r11,[sp,#0x10]
;;;1160     uint32_t ctraddr = (uint32_t)ctr;
000056  ab05              ADD      r3,sp,#0x14
000058  9300              STR      r3,[sp,#0]
;;;1161     uint32_t b0addr = (uint32_t)blockb0;
;;;1162     
;;;1163     /************************ Formatting the header block ***********************/
;;;1164     if(headersize != 0)
00005a  2c00              CMP      r4,#0
00005c  d031              BEQ      |L2.194|
;;;1165     {
;;;1166       /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
;;;1167       if(headersize < 65280)
;;;1168       {
;;;1169         HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
;;;1170         HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
00005e  f0040cff          AND      r12,r4,#0xff
000062  f5b44f7f          CMP      r4,#0xff00            ;1167
000066  d206              BCS      |L2.118|
000068  0a23              LSRS     r3,r4,#8              ;1169
00006a  7003              STRB     r3,[r0,#0]            ;1169
00006c  2302              MOVS     r3,#2
00006e  f880c001          STRB     r12,[r0,#1]
;;;1171         headersize += 2;
000072  1ca4              ADDS     r4,r4,#2
000074  e015              B        |L2.162|
                  |L2.118|
;;;1172       }
;;;1173       else
;;;1174       {
;;;1175         /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
;;;1176         HBuffer[bufferidx++] = 0xFF;
000076  23ff              MOVS     r3,#0xff
000078  7003              STRB     r3,[r0,#0]
;;;1177         HBuffer[bufferidx++] = 0xFE;
00007a  23fe              MOVS     r3,#0xfe
00007c  7043              STRB     r3,[r0,#1]
;;;1178         HBuffer[bufferidx++] = headersize & 0xff000000;
00007e  f880b002          STRB     r11,[r0,#2]
;;;1179         HBuffer[bufferidx++] = headersize & 0x00ff0000;
000082  f880b003          STRB     r11,[r0,#3]
;;;1180         HBuffer[bufferidx++] = headersize & 0x0000ff00;
000086  f880b004          STRB     r11,[r0,#4]
;;;1181         HBuffer[bufferidx++] = headersize & 0x000000ff;
00008a  2306              MOVS     r3,#6
00008c  f880c005          STRB     r12,[r0,#5]
;;;1182         headersize += 6;
000090  1da4              ADDS     r4,r4,#6
000092  e006              B        |L2.162|
                  |L2.148|
;;;1183       }
;;;1184       /* Copy the header buffer in internal buffer "HBuffer" */
;;;1185       for(loopcounter = 0; loopcounter < headersize; loopcounter++)
;;;1186       {
;;;1187         HBuffer[bufferidx++] = Header[loopcounter];
000094  469e              MOV      lr,r3
000096  f815c001          LDRB     r12,[r5,r1]
00009a  1c5b              ADDS     r3,r3,#1
00009c  f800c00e          STRB     r12,[r0,lr]
0000a0  1c49              ADDS     r1,r1,#1              ;1185
                  |L2.162|
0000a2  42a1              CMP      r1,r4                 ;1185
0000a4  d3f6              BCC      |L2.148|
;;;1188       }
;;;1189       /* Check if the header size is modulo 16 */
;;;1190       if ((headersize % 16) != 0)
0000a6  0721              LSLS     r1,r4,#28
0000a8  d00a              BEQ      |L2.192|
0000aa  2101              MOVS     r1,#1                 ;1148
;;;1191       {
;;;1192         /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
;;;1193         for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
0000ac  eb011114          ADD      r1,r1,r4,LSR #4
0000b0  e002              B        |L2.184|
                  |L2.178|
;;;1194         {
;;;1195           HBuffer[loopcounter] = 0;
0000b2  f800b004          STRB     r11,[r0,r4]
0000b6  1c64              ADDS     r4,r4,#1              ;1193
                  |L2.184|
0000b8  ebb41f01          CMP      r4,r1,LSL #4          ;1193
0000bc  d9f9              BLS      |L2.178|
;;;1196         }
;;;1197         /* Set the header size to modulo 16 */
;;;1198         headersize = ((headersize/16) + 1) * 16;
0000be  010c              LSLS     r4,r1,#4
                  |L2.192|
;;;1199       }
;;;1200       /* set the pointer headeraddr to HBuffer */
;;;1201       headeraddr = (uint32_t)HBuffer;
0000c0  4605              MOV      r5,r0
                  |L2.194|
;;;1202     }
;;;1203     /************************* Formatting the block B0 **************************/
;;;1204     if(headersize != 0)
0000c2  b114              CBZ      r4,|L2.202|
;;;1205     {
;;;1206       blockb0[0] = 0x40;
0000c4  2040              MOVS     r0,#0x40
0000c6  f88d0024          STRB     r0,[sp,#0x24]
                  |L2.202|
;;;1207     }
;;;1208     /* Flags byte */
;;;1209     blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
0000ca  9834              LDR      r0,[sp,#0xd0]
0000cc  f1c2010e          RSB      r1,r2,#0xe
0000d0  b2c0              UXTB     r0,r0
0000d2  1e80              SUBS     r0,r0,#2
0000d4  eb0070d0          ADD      r0,r0,r0,LSR #31
0000d8  f3c00042          UBFX     r0,r0,#1,#3
0000dc  f0010107          AND      r1,r1,#7
0000e0  ea4100c0          ORR      r0,r1,r0,LSL #3
0000e4  f89d1024          LDRB     r1,[sp,#0x24]
0000e8  4308              ORRS     r0,r0,r1
0000ea  f88d0024          STRB     r0,[sp,#0x24]
;;;1210     
;;;1211     for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
0000ee  2000              MOVS     r0,#0
0000f0  a909              ADD      r1,sp,#0x24           ;1157
0000f2  e006              B        |L2.258|
                  |L2.244|
;;;1212     {
;;;1213       blockb0[loopcounter+1] = Nonce[loopcounter];
0000f4  9b20              LDR      r3,[sp,#0x80]
0000f6  eb010c00          ADD      r12,r1,r0
0000fa  5c1b              LDRB     r3,[r3,r0]
0000fc  f88c3001          STRB     r3,[r12,#1]
000100  1c40              ADDS     r0,r0,#1              ;1211
                  |L2.258|
000102  4290              CMP      r0,r2                 ;1211
000104  d3f6              BCC      |L2.244|
000106  e003              B        |L2.272|
                  |L2.264|
;;;1214     }
;;;1215     for ( ; loopcounter < 13; loopcounter++)
;;;1216     {
;;;1217       blockb0[loopcounter+1] = 0;
000108  180b              ADDS     r3,r1,r0
00010a  f883b001          STRB     r11,[r3,#1]
00010e  1c40              ADDS     r0,r0,#1              ;1215
                  |L2.272|
000110  280d              CMP      r0,#0xd               ;1215
000112  d3f9              BCC      |L2.264|
;;;1218     }
;;;1219     
;;;1220     blockb0[14] = ((ILength >> 8) & 0xFF);
000114  ea4f2019          LSR      r0,r9,#8
000118  f88d0032          STRB     r0,[sp,#0x32]
;;;1221     blockb0[15] = (ILength & 0xFF);
00011c  f88d9033          STRB     r9,[sp,#0x33]
;;;1222     
;;;1223     /************************* Formatting the initial counter *******************/
;;;1224     /* Byte 0:
;;;1225        Bits 7 and 6 are reserved and shall be set to 0
;;;1226        Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
;;;1227        are distinct from B0
;;;1228        Bits 0, 1, and 2 contain the same encoding of q as in B0
;;;1229     */
;;;1230     ctr[0] = blockb0[0] & 0x07;
000120  f89d0024          LDRB     r0,[sp,#0x24]
000124  f0000007          AND      r0,r0,#7
000128  f88d0014          STRB     r0,[sp,#0x14]
;;;1231     /* byte 1 to NonceSize is the IV (Nonce) */
;;;1232     for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
00012c  2001              MOVS     r0,#1
00012e  ab05              ADD      r3,sp,#0x14           ;1158
000130  1c52              ADDS     r2,r2,#1
000132  e004              B        |L2.318|
                  |L2.308|
;;;1233     {
;;;1234       ctr[loopcounter] = blockb0[loopcounter];
000134  f811c000          LDRB     r12,[r1,r0]
000138  f803c000          STRB     r12,[r3,r0]
00013c  1c40              ADDS     r0,r0,#1              ;1232
                  |L2.318|
00013e  4290              CMP      r0,r2                 ;1232
000140  d3f8              BCC      |L2.308|
;;;1235     }
;;;1236     /* Set the LSB to 1 */
;;;1237     ctr[15] |= 0x01;
000142  f89d0023          LDRB     r0,[sp,#0x23]
000146  f0400001          ORR      r0,r0,#1
00014a  f88d0023          STRB     r0,[sp,#0x23]
;;;1238     
;;;1239     /* Crypto structures initialisation*/
;;;1240     CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00014e  a813              ADD      r0,sp,#0x4c
000150  f7fffffe          BL       CRYP_KeyStructInit
;;;1241     
;;;1242     switch(Keysize)
000154  982c              LDR      r0,[sp,#0xb0]
000156  2880              CMP      r0,#0x80
000158  d073              BEQ      |L2.578|
00015a  f44f7180          MOV      r1,#0x100
00015e  28c0              CMP      r0,#0xc0
000160  d06e              BEQ      |L2.576|
000162  4288              CMP      r0,r1
000164  d121              BNE      |L2.426|
;;;1243     {
;;;1244       case 128:
;;;1245       AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;1246       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;1247       keyaddr+=4;
;;;1248       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;1249       keyaddr+=4;
;;;1250       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;1251       keyaddr+=4;
;;;1252       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;1253       break;
;;;1254       case 192:
;;;1255       AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;1256       AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;1257       keyaddr+=4;
;;;1258       AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;1259       keyaddr+=4;
;;;1260       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;1261       keyaddr+=4;
;;;1262       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;1263       keyaddr+=4;
;;;1264       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;1265       keyaddr+=4;
;;;1266       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;1267       break;
;;;1268       case 256:
;;;1269       AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000166  0040              LSLS     r0,r0,#1
000168  901e              STR      r0,[sp,#0x78]
;;;1270       AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00016a  f8da0000          LDR      r0,[r10,#0]
00016e  ba00              REV      r0,r0
000170  9013              STR      r0,[sp,#0x4c]
;;;1271       keyaddr+=4;
;;;1272       AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
000172  f8da0004          LDR      r0,[r10,#4]
000176  ba00              REV      r0,r0
000178  9014              STR      r0,[sp,#0x50]
;;;1273       keyaddr+=4;
;;;1274       AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
00017a  f8da0008          LDR      r0,[r10,#8]
00017e  ba00              REV      r0,r0
000180  9015              STR      r0,[sp,#0x54]
;;;1275       keyaddr+=4;
;;;1276       AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000182  f8da000c          LDR      r0,[r10,#0xc]
000186  ba00              REV      r0,r0
000188  9016              STR      r0,[sp,#0x58]
;;;1277       keyaddr+=4;
;;;1278       AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
00018a  f8da0010          LDR      r0,[r10,#0x10]
00018e  ba00              REV      r0,r0
000190  9017              STR      r0,[sp,#0x5c]
;;;1279       keyaddr+=4;
;;;1280       AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000192  f8da0014          LDR      r0,[r10,#0x14]
000196  ba00              REV      r0,r0
000198  9018              STR      r0,[sp,#0x60]
;;;1281       keyaddr+=4;
;;;1282       AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00019a  f8da0018          LDR      r0,[r10,#0x18]
00019e  ba00              REV      r0,r0
0001a0  9019              STR      r0,[sp,#0x64]
;;;1283       keyaddr+=4;
;;;1284       AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
0001a2  f8da001c          LDR      r0,[r10,#0x1c]
0001a6  ba00              REV      r0,r0
0001a8  901a              STR      r0,[sp,#0x68]
                  |L2.426|
;;;1285       break;
;;;1286       default:
;;;1287       break;
;;;1288     }
;;;1289     
;;;1290     /* CRYP Initialization Vectors */
;;;1291     AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
0001aa  9800              LDR      r0,[sp,#0]
0001ac  6800              LDR      r0,[r0,#0]
0001ae  ba00              REV      r0,r0
0001b0  900f              STR      r0,[sp,#0x3c]
;;;1292     ctraddr+=4;
0001b2  9800              LDR      r0,[sp,#0]
;;;1293     AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
0001b4  6841              LDR      r1,[r0,#4]
0001b6  ba09              REV      r1,r1
0001b8  9110              STR      r1,[sp,#0x40]
;;;1294     ctraddr+=4;
;;;1295     AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
0001ba  6881              LDR      r1,[r0,#8]
0001bc  ba09              REV      r1,r1
0001be  9111              STR      r1,[sp,#0x44]
;;;1296     ctraddr+=4;
;;;1297     AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
0001c0  68c0              LDR      r0,[r0,#0xc]
0001c2  ba00              REV      r0,r0
0001c4  9012              STR      r0,[sp,#0x48]
;;;1298     
;;;1299     /*------------------ AES Encryption ------------------*/
;;;1300     if(Mode == MODE_ENCRYPT) /* AES encryption */
0001c6  981f              LDR      r0,[sp,#0x7c]
;;;1301     {
;;;1302       /* Flush IN/OUT FIFOs */
;;;1303       CRYP_FIFOFlush();
;;;1304       
;;;1305       /* Key Initialisation */
;;;1306       CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;1307       
;;;1308       /* CRYP Initialization Vectors */
;;;1309       CRYP_IVInit(&AES_CRYP_IVInitStructure);
;;;1310       
;;;1311       /* Crypto Init for Key preparation for decryption process */
;;;1312       AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;1313       AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
0001c8  f04f1a08          MOV      r10,#0x80008
0001cc  2801              CMP      r0,#1                 ;1300
0001ce  d065              BEQ      |L2.668|
;;;1314       AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
;;;1315       CRYP_Init(&AES_CRYP_InitStructure);
;;;1316       
;;;1317       /***************************** Init phase *********************************/
;;;1318       /* Select init phase */
;;;1319       CRYP_PhaseConfig(CRYP_Phase_Init);
;;;1320       
;;;1321       b0addr = (uint32_t)blockb0;
;;;1322       /* Write the blockb0 block in the IN FIFO */
;;;1323       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1324       b0addr+=4;
;;;1325       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1326       b0addr+=4;
;;;1327       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1328       b0addr+=4;
;;;1329       CRYP_DataIn((*(uint32_t*)(b0addr)));
;;;1330       
;;;1331       /* Enable Crypto processor */
;;;1332       CRYP_Cmd(ENABLE);
;;;1333       
;;;1334       /* Wait for CRYPEN bit to be 0 */
;;;1335       while(CRYP_GetCmdStatus() == ENABLE)
;;;1336       {
;;;1337       }
;;;1338       /***************************** header phase *******************************/
;;;1339       if(headersize != 0)
;;;1340       {
;;;1341         /* Select header phase */
;;;1342         CRYP_PhaseConfig(CRYP_Phase_Header);
;;;1343         
;;;1344         /* Enable Crypto processor */
;;;1345         CRYP_Cmd(ENABLE);
;;;1346         
;;;1347         if(CRYP_GetCmdStatus() == DISABLE)
;;;1348         {
;;;1349            /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1350               the CRYP peripheral (please check the device sales type. */
;;;1351            return(ERROR);
;;;1352         }
;;;1353         
;;;1354         for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
;;;1355         {
;;;1356           /* Wait until the IFEM flag is reset */
;;;1357           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1358           {
;;;1359           }
;;;1360           
;;;1361           /* Write the Input block in the IN FIFO */
;;;1362           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1363           headeraddr+=4;
;;;1364           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1365           headeraddr+=4;
;;;1366           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1367           headeraddr+=4;
;;;1368           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1369           headeraddr+=4;
;;;1370         }
;;;1371         
;;;1372         /* Wait until the complete message has been processed */
;;;1373         counter = 0;
;;;1374         do
;;;1375         {
;;;1376           busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1377           counter++;
;;;1378         }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1379   
;;;1380         if (busystatus != RESET)
;;;1381         {
;;;1382           status = ERROR;
;;;1383         }
;;;1384       }
;;;1385       
;;;1386       /**************************** payload phase *******************************/
;;;1387       if(ILength != 0)
;;;1388       {
;;;1389         /* Select payload phase */
;;;1390         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1391         
;;;1392         /* Enable Crypto processor */
;;;1393         CRYP_Cmd(ENABLE);
;;;1394         
;;;1395         if(CRYP_GetCmdStatus() == DISABLE)
;;;1396         {
;;;1397           /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1398              the CRYP peripheral (please check the device sales type. */
;;;1399           return(ERROR);
;;;1400         }
;;;1401         
;;;1402         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1403         {
;;;1404           /* Wait until the IFEM flag is reset */
;;;1405           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1406           {
;;;1407           }
;;;1408           
;;;1409           /* Write the Input block in the IN FIFO */
;;;1410           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1411           inputaddr+=4;
;;;1412           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1413           inputaddr+=4;
;;;1414           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1415           inputaddr+=4;
;;;1416           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1417           inputaddr+=4;
;;;1418           
;;;1419           /* Wait until the complete message has been processed */
;;;1420           counter = 0;
;;;1421           do
;;;1422           {
;;;1423             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1424             counter++;
;;;1425           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1426   
;;;1427           if (busystatus != RESET)
;;;1428           {
;;;1429             status = ERROR;
;;;1430           }
;;;1431           else
;;;1432           {
;;;1433             /* Wait until the OFNE flag is reset */
;;;1434             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1435             {
;;;1436             }
;;;1437             
;;;1438             /* Read the Output block from the Output FIFO */
;;;1439             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1440             outputaddr+=4;
;;;1441             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1442             outputaddr+=4;
;;;1443             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1444             outputaddr+=4;
;;;1445             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1446             outputaddr+=4;
;;;1447           }
;;;1448         }
;;;1449       }
;;;1450       
;;;1451       /***************************** final phase ********************************/
;;;1452       /* Select final phase */
;;;1453       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1454       
;;;1455       /* Enable Crypto processor */
;;;1456       CRYP_Cmd(ENABLE);
;;;1457       
;;;1458       if(CRYP_GetCmdStatus() == DISABLE)
;;;1459       {
;;;1460         /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1461            the CRYP peripheral (please check the device sales type. */
;;;1462         return(ERROR);
;;;1463       }
;;;1464       
;;;1465       ctraddr = (uint32_t)ctr;
;;;1466       /* Write the counter block in the IN FIFO */
;;;1467       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1468       ctraddr+=4;
;;;1469       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1470       ctraddr+=4;
;;;1471       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1472       ctraddr+=4;
;;;1473       /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
;;;1474       CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
;;;1475       
;;;1476       /* Wait until the OFNE flag is reset */
;;;1477       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1478       {
;;;1479       }
;;;1480       
;;;1481       /* Read the Auth TAG in the IN FIFO */
;;;1482       temptag[0] = CRYP_DataOut();
;;;1483       temptag[1] = CRYP_DataOut();
;;;1484       temptag[2] = CRYP_DataOut();
;;;1485       temptag[3] = CRYP_DataOut();
;;;1486     }
;;;1487     /*------------------ AES Decryption ------------------*/
;;;1488     else /* AES decryption */
;;;1489     {
;;;1490       /* Flush IN/OUT FIFOs */
;;;1491       CRYP_FIFOFlush();
0001d0  f7fffffe          BL       CRYP_FIFOFlush
;;;1492       
;;;1493       /* Key Initialisation */
;;;1494       CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0001d4  a813              ADD      r0,sp,#0x4c
0001d6  f7fffffe          BL       CRYP_KeyInit
;;;1495       
;;;1496       /* CRYP Initialization Vectors */
;;;1497       CRYP_IVInit(&AES_CRYP_IVInitStructure);
0001da  a80f              ADD      r0,sp,#0x3c
0001dc  f7fffffe          BL       CRYP_IVInit
;;;1498       
;;;1499       /* Crypto Init for Key preparation for decryption process */
;;;1500       AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
0001e0  2004              MOVS     r0,#4
0001e2  901b              STR      r0,[sp,#0x6c]
;;;1501       AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
0001e4  f8cda070          STR      r10,[sp,#0x70]
;;;1502       AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
0001e8  2080              MOVS     r0,#0x80
0001ea  901d              STR      r0,[sp,#0x74]
;;;1503       CRYP_Init(&AES_CRYP_InitStructure);
0001ec  a81b              ADD      r0,sp,#0x6c
0001ee  f7fffffe          BL       CRYP_Init
;;;1504       
;;;1505       /***************************** Init phase *********************************/
;;;1506       /* Select init phase */
;;;1507       CRYP_PhaseConfig(CRYP_Phase_Init);
0001f2  2000              MOVS     r0,#0
0001f4  f7fffffe          BL       CRYP_PhaseConfig
;;;1508       
;;;1509       b0addr = (uint32_t)blockb0;
;;;1510       /* Write the blockb0 block in the IN FIFO */
;;;1511       CRYP_DataIn((*(uint32_t*)(b0addr)));
0001f8  9809              LDR      r0,[sp,#0x24]
0001fa  f7fffffe          BL       CRYP_DataIn
;;;1512       b0addr+=4;
;;;1513       CRYP_DataIn((*(uint32_t*)(b0addr)));
0001fe  980a              LDR      r0,[sp,#0x28]
000200  f7fffffe          BL       CRYP_DataIn
;;;1514       b0addr+=4;
;;;1515       CRYP_DataIn((*(uint32_t*)(b0addr)));
000204  980b              LDR      r0,[sp,#0x2c]
000206  f7fffffe          BL       CRYP_DataIn
;;;1516       b0addr+=4;
;;;1517       CRYP_DataIn((*(uint32_t*)(b0addr)));
00020a  980c              LDR      r0,[sp,#0x30]
00020c  f7fffffe          BL       CRYP_DataIn
;;;1518       
;;;1519       /* Enable Crypto processor */
;;;1520       CRYP_Cmd(ENABLE);
000210  2001              MOVS     r0,#1
000212  f7fffffe          BL       CRYP_Cmd
                  |L2.534|
;;;1521       
;;;1522       /* Wait for CRYPEN bit to be 0 */
;;;1523       while(CRYP_GetCmdStatus() == ENABLE)
000216  f7fffffe          BL       CRYP_GetCmdStatus
00021a  2801              CMP      r0,#1
00021c  d0fb              BEQ      |L2.534|
;;;1524       {
;;;1525       }
;;;1526       
;;;1527       /***************************** header phase *******************************/
;;;1528       if(headersize != 0)
00021e  2c00              CMP      r4,#0
000220  d071              BEQ      |L2.774|
;;;1529       {
;;;1530         /* Select header phase */
;;;1531         CRYP_PhaseConfig(CRYP_Phase_Header);
000222  f44f3080          MOV      r0,#0x10000
000226  f7fffffe          BL       CRYP_PhaseConfig
;;;1532         
;;;1533         /* Enable Crypto processor */
;;;1534         CRYP_Cmd(ENABLE);
00022a  2001              MOVS     r0,#1
00022c  f7fffffe          BL       CRYP_Cmd
;;;1535         
;;;1536         if(CRYP_GetCmdStatus() == DISABLE)
000230  f7fffffe          BL       CRYP_GetCmdStatus
000234  2800              CMP      r0,#0
000236  d067              BEQ      |L2.776|
;;;1537         {
;;;1538           /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1539              the CRYP peripheral (please check the device sales type. */
;;;1540           return(ERROR);
;;;1541         }
;;;1542         
;;;1543         for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
000238  f04f0a00          MOV      r10,#0
00023c  e12c              B        |L2.1176|
00023e  e000              B        |L2.578|
                  |L2.576|
000240  e012              B        |L2.616|
                  |L2.578|
000242  f8cdb078          STR      r11,[sp,#0x78]        ;1245
000246  f8da0000          LDR      r0,[r10,#0]           ;1246
00024a  ba00              REV      r0,r0                 ;1246
00024c  9017              STR      r0,[sp,#0x5c]         ;1246
00024e  f8da0004          LDR      r0,[r10,#4]           ;1248
000252  ba00              REV      r0,r0                 ;1248
000254  9018              STR      r0,[sp,#0x60]         ;1248
000256  f8da0008          LDR      r0,[r10,#8]           ;1250
00025a  ba00              REV      r0,r0                 ;1250
00025c  9019              STR      r0,[sp,#0x64]         ;1250
00025e  f8da000c          LDR      r0,[r10,#0xc]         ;1252
000262  ba00              REV      r0,r0                 ;1252
000264  901a              STR      r0,[sp,#0x68]         ;1252
000266  e7a0              B        |L2.426|
                  |L2.616|
000268  911e              STR      r1,[sp,#0x78]         ;1255
00026a  f8da0000          LDR      r0,[r10,#0]           ;1256
00026e  ba00              REV      r0,r0                 ;1256
000270  9015              STR      r0,[sp,#0x54]         ;1256
000272  f8da0004          LDR      r0,[r10,#4]           ;1258
000276  ba00              REV      r0,r0                 ;1258
000278  9016              STR      r0,[sp,#0x58]         ;1258
00027a  f8da0008          LDR      r0,[r10,#8]           ;1260
00027e  ba00              REV      r0,r0                 ;1260
000280  9017              STR      r0,[sp,#0x5c]         ;1260
000282  f8da000c          LDR      r0,[r10,#0xc]         ;1262
000286  ba00              REV      r0,r0                 ;1262
000288  9018              STR      r0,[sp,#0x60]         ;1262
00028a  f8da0010          LDR      r0,[r10,#0x10]        ;1264
00028e  ba00              REV      r0,r0                 ;1264
000290  9019              STR      r0,[sp,#0x64]         ;1264
000292  f8da0014          LDR      r0,[r10,#0x14]        ;1266
000296  ba00              REV      r0,r0                 ;1266
000298  901a              STR      r0,[sp,#0x68]         ;1266
00029a  e786              B        |L2.426|
                  |L2.668|
00029c  f7fffffe          BL       CRYP_FIFOFlush
0002a0  a813              ADD      r0,sp,#0x4c           ;1306
0002a2  f7fffffe          BL       CRYP_KeyInit
0002a6  a80f              ADD      r0,sp,#0x3c           ;1309
0002a8  f7fffffe          BL       CRYP_IVInit
0002ac  f8cdb06c          STR      r11,[sp,#0x6c]        ;1312
0002b0  f8cda070          STR      r10,[sp,#0x70]        ;1313
0002b4  2080              MOVS     r0,#0x80              ;1314
0002b6  901d              STR      r0,[sp,#0x74]         ;1314
0002b8  a81b              ADD      r0,sp,#0x6c           ;1315
0002ba  f7fffffe          BL       CRYP_Init
0002be  2000              MOVS     r0,#0                 ;1319
0002c0  f7fffffe          BL       CRYP_PhaseConfig
0002c4  9809              LDR      r0,[sp,#0x24]         ;1323
0002c6  f7fffffe          BL       CRYP_DataIn
0002ca  980a              LDR      r0,[sp,#0x28]         ;1325
0002cc  f7fffffe          BL       CRYP_DataIn
0002d0  980b              LDR      r0,[sp,#0x2c]         ;1327
0002d2  f7fffffe          BL       CRYP_DataIn
0002d6  980c              LDR      r0,[sp,#0x30]         ;1329
0002d8  f7fffffe          BL       CRYP_DataIn
0002dc  2001              MOVS     r0,#1                 ;1332
0002de  f7fffffe          BL       CRYP_Cmd
                  |L2.738|
0002e2  f7fffffe          BL       CRYP_GetCmdStatus
0002e6  2801              CMP      r0,#1                 ;1335
0002e8  d0fb              BEQ      |L2.738|
0002ea  b3e4              CBZ      r4,|L2.870|
0002ec  f44f3080          MOV      r0,#0x10000           ;1342
0002f0  f7fffffe          BL       CRYP_PhaseConfig
0002f4  2001              MOVS     r0,#1                 ;1345
0002f6  f7fffffe          BL       CRYP_Cmd
0002fa  f7fffffe          BL       CRYP_GetCmdStatus
0002fe  b120              CBZ      r0,|L2.778|
000300  f04f0a00          MOV      r10,#0                ;1354
000304  e01c              B        |L2.832|
                  |L2.774|
000306  e0db              B        |L2.1216|
                  |L2.776|
000308  e0ad              B        |L2.1126|
                  |L2.778|
00030a  2000              MOVS     r0,#0                 ;1351
                  |L2.780|
;;;1544         {
;;;1545           /* Wait until the IFEM flag is reset */
;;;1546           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1547           {
;;;1548           }
;;;1549           
;;;1550           /* Write the Input block in the IN FIFO */
;;;1551           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1552           headeraddr+=4;
;;;1553           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1554           headeraddr+=4;
;;;1555           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1556           headeraddr+=4;
;;;1557           CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;1558           headeraddr+=4;
;;;1559         }
;;;1560         
;;;1561         /* Wait until the complete message has been processed */
;;;1562         counter = 0;
;;;1563         do
;;;1564         {
;;;1565           busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1566           counter++;
;;;1567         }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1568   
;;;1569         if (busystatus != RESET)
;;;1570         {
;;;1571           status = ERROR;
;;;1572         }
;;;1573       }
;;;1574       
;;;1575       /**************************** payload phase *******************************/
;;;1576       if(ILength != 0)
;;;1577       {
;;;1578         /* Select payload phase */
;;;1579         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1580   
;;;1581         /* Enable Crypto processor */
;;;1582         CRYP_Cmd(ENABLE);
;;;1583         
;;;1584         if(CRYP_GetCmdStatus() == DISABLE)
;;;1585         {
;;;1586           /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1587              the CRYP peripheral (please check the device sales type. */
;;;1588           return(ERROR);
;;;1589         }
;;;1590         
;;;1591         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1592         {
;;;1593           /* Wait until the IFEM flag is reset */
;;;1594           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1595           {
;;;1596           }
;;;1597           
;;;1598           /* Write the Input block in the IN FIFO */
;;;1599           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1600           inputaddr+=4;
;;;1601           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1602           inputaddr+=4;
;;;1603           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1604           inputaddr+=4;
;;;1605           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1606           inputaddr+=4;
;;;1607           
;;;1608           /* Wait until the complete message has been processed */
;;;1609           counter = 0;
;;;1610           do
;;;1611           {
;;;1612             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1613             counter++;
;;;1614           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1615   
;;;1616           if (busystatus != RESET)
;;;1617           {
;;;1618             status = ERROR;
;;;1619           }
;;;1620           else
;;;1621           {
;;;1622             /* Wait until the OFNE flag is reset */
;;;1623             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1624             {
;;;1625             }
;;;1626             
;;;1627             /* Read the Output block from the Output FIFO */
;;;1628             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1629             outputaddr+=4;
;;;1630             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1631             outputaddr+=4;
;;;1632             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1633             outputaddr+=4;
;;;1634             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1635             outputaddr+=4;
;;;1636           }
;;;1637         }
;;;1638       }
;;;1639       
;;;1640       /***************************** final phase ********************************/
;;;1641       /* Select final phase */
;;;1642       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1643       
;;;1644       /* Enable Crypto processor */
;;;1645       CRYP_Cmd(ENABLE);
;;;1646       
;;;1647       if(CRYP_GetCmdStatus() == DISABLE)
;;;1648       {
;;;1649         /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1650            the CRYP peripheral (please check the device sales type. */
;;;1651         return(ERROR);
;;;1652       }
;;;1653       
;;;1654       ctraddr = (uint32_t)ctr;
;;;1655       /* Write the counter block in the IN FIFO */
;;;1656       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1657       ctraddr+=4;
;;;1658       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1659       ctraddr+=4;
;;;1660       CRYP_DataIn(*(uint32_t*)(ctraddr));
;;;1661       ctraddr+=4;
;;;1662       /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
;;;1663       CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
;;;1664       
;;;1665       /* Wait until the OFNE flag is reset */
;;;1666       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1667       {
;;;1668       }
;;;1669       
;;;1670       /* Read the Authentaication TAG (MAC) in the IN FIFO */
;;;1671       temptag[0] = CRYP_DataOut();
;;;1672       temptag[1] = CRYP_DataOut();
;;;1673       temptag[2] = CRYP_DataOut();
;;;1674       temptag[3] = CRYP_DataOut();
;;;1675     }
;;;1676     
;;;1677     /* Copy temporary authentication TAG in user TAG buffer */
;;;1678     for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
;;;1679     {
;;;1680       /* Set the authentication TAG buffer */
;;;1681       *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
;;;1682     }
;;;1683     
;;;1684     /* Disable Crypto */
;;;1685     CRYP_Cmd(DISABLE);
;;;1686   
;;;1687     return status;
;;;1688   }
00030c  b023              ADD      sp,sp,#0x8c
00030e  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.786|
000312  2001              MOVS     r0,#1                 ;1357
000314  f7fffffe          BL       CRYP_GetFlagStatus
000318  2800              CMP      r0,#0                 ;1357
00031a  d0fa              BEQ      |L2.786|
00031c  6828              LDR      r0,[r5,#0]            ;1362
00031e  f7fffffe          BL       CRYP_DataIn
000322  1d2d              ADDS     r5,r5,#4              ;1363
000324  6828              LDR      r0,[r5,#0]            ;1364
000326  f7fffffe          BL       CRYP_DataIn
00032a  1d2d              ADDS     r5,r5,#4              ;1365
00032c  6828              LDR      r0,[r5,#0]            ;1366
00032e  f7fffffe          BL       CRYP_DataIn
000332  1d2d              ADDS     r5,r5,#4              ;1367
000334  6828              LDR      r0,[r5,#0]            ;1368
000336  f7fffffe          BL       CRYP_DataIn
00033a  1d2d              ADDS     r5,r5,#4              ;1369
00033c  f10a0a10          ADD      r10,r10,#0x10         ;1354
                  |L2.832|
000340  45a2              CMP      r10,r4                ;1354
000342  d3e6              BCC      |L2.786|
000344  f8cdb038          STR      r11,[sp,#0x38]        ;1373
000348  f44f3480          MOV      r4,#0x10000           ;1342
                  |L2.844|
00034c  2010              MOVS     r0,#0x10              ;1376
00034e  f7fffffe          BL       CRYP_GetFlagStatus
000352  990e              LDR      r1,[sp,#0x38]         ;1377
000354  1c49              ADDS     r1,r1,#1              ;1377
000356  910e              STR      r1,[sp,#0x38]         ;1377
000358  990e              LDR      r1,[sp,#0x38]         ;1378
00035a  42a1              CMP      r1,r4                 ;1378
00035c  d001              BEQ      |L2.866|
00035e  2800              CMP      r0,#0                 ;1378
000360  d1f4              BNE      |L2.844|
                  |L2.866|
000362  b100              CBZ      r0,|L2.870|
000364  e000              B        |L2.872|
                  |L2.870|
000366  e001              B        |L2.876|
                  |L2.872|
000368  f04f0800          MOV      r8,#0                 ;1382
                  |L2.876|
00036c  f1b90f00          CMP      r9,#0                 ;1387
000370  d04d              BEQ      |L2.1038|
000372  f44f3000          MOV      r0,#0x20000           ;1390
000376  f7fffffe          BL       CRYP_PhaseConfig
00037a  2001              MOVS     r0,#1                 ;1393
00037c  f7fffffe          BL       CRYP_Cmd
000380  f7fffffe          BL       CRYP_GetCmdStatus
000384  b108              CBZ      r0,|L2.906|
000386  2400              MOVS     r4,#0                 ;1402
000388  e03c              B        |L2.1028|
                  |L2.906|
00038a  2000              MOVS     r0,#0                 ;1399
00038c  e7be              B        |L2.780|
                  |L2.910|
00038e  2001              MOVS     r0,#1                 ;1405
000390  f7fffffe          BL       CRYP_GetFlagStatus
000394  2800              CMP      r0,#0                 ;1405
000396  d0fa              BEQ      |L2.910|
000398  6830              LDR      r0,[r6,#0]            ;1410
00039a  f7fffffe          BL       CRYP_DataIn
00039e  1d36              ADDS     r6,r6,#4              ;1411
0003a0  6830              LDR      r0,[r6,#0]            ;1412
0003a2  f7fffffe          BL       CRYP_DataIn
0003a6  1d36              ADDS     r6,r6,#4              ;1413
0003a8  6830              LDR      r0,[r6,#0]            ;1414
0003aa  f7fffffe          BL       CRYP_DataIn
0003ae  1d36              ADDS     r6,r6,#4              ;1415
0003b0  6830              LDR      r0,[r6,#0]            ;1416
0003b2  f7fffffe          BL       CRYP_DataIn
0003b6  1d36              ADDS     r6,r6,#4              ;1417
0003b8  f8cdb038          STR      r11,[sp,#0x38]        ;1420
0003bc  f44f3580          MOV      r5,#0x10000           ;1342
                  |L2.960|
0003c0  2010              MOVS     r0,#0x10              ;1423
0003c2  f7fffffe          BL       CRYP_GetFlagStatus
0003c6  990e              LDR      r1,[sp,#0x38]         ;1424
0003c8  1c49              ADDS     r1,r1,#1              ;1424
0003ca  910e              STR      r1,[sp,#0x38]         ;1424
0003cc  990e              LDR      r1,[sp,#0x38]         ;1425
0003ce  42a9              CMP      r1,r5                 ;1425
0003d0  d001              BEQ      |L2.982|
0003d2  2800              CMP      r0,#0                 ;1425
0003d4  d1f4              BNE      |L2.960|
                  |L2.982|
0003d6  b110              CBZ      r0,|L2.990|
0003d8  f04f0800          MOV      r8,#0                 ;1429
0003dc  e011              B        |L2.1026|
                  |L2.990|
0003de  2004              MOVS     r0,#4                 ;1434
0003e0  f7fffffe          BL       CRYP_GetFlagStatus
0003e4  2800              CMP      r0,#0                 ;1434
0003e6  d0fa              BEQ      |L2.990|
0003e8  f7fffffe          BL       CRYP_DataOut
0003ec  6038              STR      r0,[r7,#0]            ;1439
0003ee  f7fffffe          BL       CRYP_DataOut
0003f2  6078              STR      r0,[r7,#4]            ;1441
0003f4  f7fffffe          BL       CRYP_DataOut
0003f8  60b8              STR      r0,[r7,#8]            ;1443
0003fa  f7fffffe          BL       CRYP_DataOut
0003fe  60f8              STR      r0,[r7,#0xc]          ;1445
000400  3710              ADDS     r7,r7,#0x10           ;1445
                  |L2.1026|
000402  3410              ADDS     r4,r4,#0x10           ;1402
                  |L2.1028|
000404  454c              CMP      r4,r9                 ;1402
000406  d202              BCS      |L2.1038|
000408  f1b80f00          CMP      r8,#0                 ;1402
00040c  d1bf              BNE      |L2.910|
                  |L2.1038|
00040e  f44f3040          MOV      r0,#0x30000           ;1453
000412  f7fffffe          BL       CRYP_PhaseConfig
000416  2001              MOVS     r0,#1                 ;1456
000418  f7fffffe          BL       CRYP_Cmd
00041c  f7fffffe          BL       CRYP_GetCmdStatus
000420  b1f8              CBZ      r0,|L2.1122|
000422  9805              LDR      r0,[sp,#0x14]         ;1467
000424  f7fffffe          BL       CRYP_DataIn
000428  9806              LDR      r0,[sp,#0x18]         ;1469
00042a  f7fffffe          BL       CRYP_DataIn
00042e  9807              LDR      r0,[sp,#0x1c]         ;1471
000430  f7fffffe          BL       CRYP_DataIn
000434  9808              LDR      r0,[sp,#0x20]         ;1474
000436  f0207080          BIC      r0,r0,#0x1000000      ;1474
00043a  f7fffffe          BL       CRYP_DataIn
                  |L2.1086|
00043e  2004              MOVS     r0,#4                 ;1477
000440  f7fffffe          BL       CRYP_GetFlagStatus
000444  2800              CMP      r0,#0                 ;1477
000446  d0fa              BEQ      |L2.1086|
000448  f7fffffe          BL       CRYP_DataOut
00044c  9001              STR      r0,[sp,#4]            ;1482
00044e  f7fffffe          BL       CRYP_DataOut
000452  9002              STR      r0,[sp,#8]            ;1483
000454  f7fffffe          BL       CRYP_DataOut
000458  9003              STR      r0,[sp,#0xc]          ;1484
00045a  f7fffffe          BL       CRYP_DataOut
00045e  9004              STR      r0,[sp,#0x10]         ;1485
000460  e0a8              B        |L2.1460|
                  |L2.1122|
000462  2000              MOVS     r0,#0                 ;1462
000464  e752              B        |L2.780|
                  |L2.1126|
000466  2000              MOVS     r0,#0                 ;1540
000468  e750              B        |L2.780|
                  |L2.1130|
00046a  2001              MOVS     r0,#1                 ;1546
00046c  f7fffffe          BL       CRYP_GetFlagStatus
000470  2800              CMP      r0,#0                 ;1546
000472  d0fa              BEQ      |L2.1130|
000474  6828              LDR      r0,[r5,#0]            ;1551
000476  f7fffffe          BL       CRYP_DataIn
00047a  1d2d              ADDS     r5,r5,#4              ;1552
00047c  6828              LDR      r0,[r5,#0]            ;1553
00047e  f7fffffe          BL       CRYP_DataIn
000482  1d2d              ADDS     r5,r5,#4              ;1554
000484  6828              LDR      r0,[r5,#0]            ;1555
000486  f7fffffe          BL       CRYP_DataIn
00048a  1d2d              ADDS     r5,r5,#4              ;1556
00048c  6828              LDR      r0,[r5,#0]            ;1557
00048e  f7fffffe          BL       CRYP_DataIn
000492  1d2d              ADDS     r5,r5,#4              ;1558
000494  f10a0a10          ADD      r10,r10,#0x10         ;1543
                  |L2.1176|
000498  45a2              CMP      r10,r4                ;1543
00049a  d3e6              BCC      |L2.1130|
00049c  f8cdb038          STR      r11,[sp,#0x38]        ;1562
0004a0  f44f3480          MOV      r4,#0x10000           ;1342
                  |L2.1188|
0004a4  2010              MOVS     r0,#0x10              ;1565
0004a6  f7fffffe          BL       CRYP_GetFlagStatus
0004aa  990e              LDR      r1,[sp,#0x38]         ;1566
0004ac  1c49              ADDS     r1,r1,#1              ;1566
0004ae  910e              STR      r1,[sp,#0x38]         ;1566
0004b0  990e              LDR      r1,[sp,#0x38]         ;1567
0004b2  42a1              CMP      r1,r4                 ;1567
0004b4  d001              BEQ      |L2.1210|
0004b6  2800              CMP      r0,#0                 ;1567
0004b8  d1f4              BNE      |L2.1188|
                  |L2.1210|
0004ba  b108              CBZ      r0,|L2.1216|
0004bc  f04f0800          MOV      r8,#0                 ;1571
                  |L2.1216|
0004c0  f1b90f00          CMP      r9,#0                 ;1576
0004c4  d04d              BEQ      |L2.1378|
0004c6  f44f3000          MOV      r0,#0x20000           ;1579
0004ca  f7fffffe          BL       CRYP_PhaseConfig
0004ce  2001              MOVS     r0,#1                 ;1582
0004d0  f7fffffe          BL       CRYP_Cmd
0004d4  f7fffffe          BL       CRYP_GetCmdStatus
0004d8  b108              CBZ      r0,|L2.1246|
0004da  2400              MOVS     r4,#0                 ;1591
0004dc  e03c              B        |L2.1368|
                  |L2.1246|
0004de  2000              MOVS     r0,#0                 ;1588
0004e0  e714              B        |L2.780|
                  |L2.1250|
0004e2  2001              MOVS     r0,#1                 ;1594
0004e4  f7fffffe          BL       CRYP_GetFlagStatus
0004e8  2800              CMP      r0,#0                 ;1594
0004ea  d0fa              BEQ      |L2.1250|
0004ec  6830              LDR      r0,[r6,#0]            ;1599
0004ee  f7fffffe          BL       CRYP_DataIn
0004f2  1d36              ADDS     r6,r6,#4              ;1600
0004f4  6830              LDR      r0,[r6,#0]            ;1601
0004f6  f7fffffe          BL       CRYP_DataIn
0004fa  1d36              ADDS     r6,r6,#4              ;1602
0004fc  6830              LDR      r0,[r6,#0]            ;1603
0004fe  f7fffffe          BL       CRYP_DataIn
000502  1d36              ADDS     r6,r6,#4              ;1604
000504  6830              LDR      r0,[r6,#0]            ;1605
000506  f7fffffe          BL       CRYP_DataIn
00050a  1d36              ADDS     r6,r6,#4              ;1606
00050c  f8cdb038          STR      r11,[sp,#0x38]        ;1609
000510  f44f3580          MOV      r5,#0x10000           ;1342
                  |L2.1300|
000514  2010              MOVS     r0,#0x10              ;1612
000516  f7fffffe          BL       CRYP_GetFlagStatus
00051a  990e              LDR      r1,[sp,#0x38]         ;1613
00051c  1c49              ADDS     r1,r1,#1              ;1613
00051e  910e              STR      r1,[sp,#0x38]         ;1613
000520  990e              LDR      r1,[sp,#0x38]         ;1614
000522  42a9              CMP      r1,r5                 ;1614
000524  d001              BEQ      |L2.1322|
000526  2800              CMP      r0,#0                 ;1614
000528  d1f4              BNE      |L2.1300|
                  |L2.1322|
00052a  b110              CBZ      r0,|L2.1330|
00052c  f04f0800          MOV      r8,#0                 ;1618
000530  e011              B        |L2.1366|
                  |L2.1330|
000532  2004              MOVS     r0,#4                 ;1623
000534  f7fffffe          BL       CRYP_GetFlagStatus
000538  2800              CMP      r0,#0                 ;1623
00053a  d0fa              BEQ      |L2.1330|
00053c  f7fffffe          BL       CRYP_DataOut
000540  6038              STR      r0,[r7,#0]            ;1628
000542  f7fffffe          BL       CRYP_DataOut
000546  6078              STR      r0,[r7,#4]            ;1630
000548  f7fffffe          BL       CRYP_DataOut
00054c  60b8              STR      r0,[r7,#8]            ;1632
00054e  f7fffffe          BL       CRYP_DataOut
000552  60f8              STR      r0,[r7,#0xc]          ;1634
000554  3710              ADDS     r7,r7,#0x10           ;1634
                  |L2.1366|
000556  3410              ADDS     r4,r4,#0x10           ;1591
                  |L2.1368|
000558  454c              CMP      r4,r9                 ;1591
00055a  d202              BCS      |L2.1378|
00055c  f1b80f00          CMP      r8,#0                 ;1591
000560  d1bf              BNE      |L2.1250|
                  |L2.1378|
000562  f44f3040          MOV      r0,#0x30000           ;1642
000566  f7fffffe          BL       CRYP_PhaseConfig
00056a  2001              MOVS     r0,#1                 ;1645
00056c  f7fffffe          BL       CRYP_Cmd
000570  f7fffffe          BL       CRYP_GetCmdStatus
000574  b308              CBZ      r0,|L2.1466|
000576  9805              LDR      r0,[sp,#0x14]         ;1656
000578  f7fffffe          BL       CRYP_DataIn
00057c  9806              LDR      r0,[sp,#0x18]         ;1658
00057e  f7fffffe          BL       CRYP_DataIn
000582  9807              LDR      r0,[sp,#0x1c]         ;1660
000584  f7fffffe          BL       CRYP_DataIn
000588  9808              LDR      r0,[sp,#0x20]         ;1663
00058a  f0207080          BIC      r0,r0,#0x1000000      ;1663
00058e  f7fffffe          BL       CRYP_DataIn
                  |L2.1426|
000592  2004              MOVS     r0,#4                 ;1666
000594  f7fffffe          BL       CRYP_GetFlagStatus
000598  2800              CMP      r0,#0                 ;1666
00059a  d0fa              BEQ      |L2.1426|
00059c  f7fffffe          BL       CRYP_DataOut
0005a0  9001              STR      r0,[sp,#4]            ;1671
0005a2  f7fffffe          BL       CRYP_DataOut
0005a6  9002              STR      r0,[sp,#8]            ;1672
0005a8  f7fffffe          BL       CRYP_DataOut
0005ac  9003              STR      r0,[sp,#0xc]          ;1673
0005ae  f7fffffe          BL       CRYP_DataOut
0005b2  9004              STR      r0,[sp,#0x10]         ;1674
                  |L2.1460|
0005b4  2000              MOVS     r0,#0                 ;1678
0005b6  a901              ADD      r1,sp,#4              ;1159
0005b8  e005              B        |L2.1478|
                  |L2.1466|
0005ba  2000              MOVS     r0,#0                 ;1651
0005bc  e6a6              B        |L2.780|
                  |L2.1470|
0005be  9a0d              LDR      r2,[sp,#0x34]         ;1681
0005c0  5c0b              LDRB     r3,[r1,r0]            ;1681
0005c2  5413              STRB     r3,[r2,r0]            ;1681
0005c4  1c40              ADDS     r0,r0,#1              ;1678
                  |L2.1478|
0005c6  9a34              LDR      r2,[sp,#0xd0]         ;1678
0005c8  4290              CMP      r0,r2                 ;1678
0005ca  d3f8              BCC      |L2.1470|
0005cc  2000              MOVS     r0,#0                 ;1685
0005ce  f7fffffe          BL       CRYP_Cmd
0005d2  4640              MOV      r0,r8                 ;1687
0005d4  e69a              B        |L2.780|
;;;1689   
                          ENDP


                          AREA ||i.CRYP_AES_CTR||, CODE, READONLY, ALIGN=1

                  CRYP_AES_CTR PROC
;;;495      */
;;;496    ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;497                             uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
;;;498                             uint8_t *Output)
;;;499    {
000004  b091              SUB      sp,sp,#0x44
000006  468b              MOV      r11,r1
000008  e9dda61f          LDRD     r10,r6,[sp,#0x7c]
00000c  9d1e              LDR      r5,[sp,#0x78]
00000e  4614              MOV      r4,r2
;;;500      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;501      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;502      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;503      __IO uint32_t counter = 0;
000010  f04f0900          MOV      r9,#0
000014  f8cd9000          STR      r9,[sp,#0]
;;;504      uint32_t busystatus = 0;
;;;505      ErrorStatus status = SUCCESS;
000018  f04f0801          MOV      r8,#1
;;;506      uint32_t keyaddr    = (uint32_t)Key;
;;;507      uint32_t inputaddr  = (uint32_t)Input;
;;;508      uint32_t outputaddr = (uint32_t)Output;
;;;509      uint32_t ivaddr     = (uint32_t)InitVectors;
;;;510      uint32_t i = 0;
00001c  2700              MOVS     r7,#0
;;;511    
;;;512      /* Crypto structures initialisation*/
;;;513      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00001e  a805              ADD      r0,sp,#0x14
000020  f7fffffe          BL       CRYP_KeyStructInit
;;;514    
;;;515      switch(Keysize)
000024  9814              LDR      r0,[sp,#0x50]
000026  2880              CMP      r0,#0x80
000028  d049              BEQ      |L3.190|
00002a  f44f7180          MOV      r1,#0x100
00002e  28c0              CMP      r0,#0xc0
000030  d054              BEQ      |L3.220|
000032  4288              CMP      r0,r1
000034  d119              BNE      |L3.106|
;;;516      {
;;;517        case 128:
;;;518        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;519        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;520        keyaddr+=4;
;;;521        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;522        keyaddr+=4;
;;;523        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;524        keyaddr+=4;
;;;525        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;526        break;
;;;527        case 192:
;;;528        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;529        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;530        keyaddr+=4;
;;;531        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;532        keyaddr+=4;
;;;533        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;534        keyaddr+=4;
;;;535        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;536        keyaddr+=4;
;;;537        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;538        keyaddr+=4;
;;;539        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;540        break;
;;;541        case 256:
;;;542        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000036  0040              LSLS     r0,r0,#1
000038  9010              STR      r0,[sp,#0x40]
;;;543        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
00003a  6820              LDR      r0,[r4,#0]
00003c  ba00              REV      r0,r0
00003e  9005              STR      r0,[sp,#0x14]
;;;544        keyaddr+=4;
;;;545        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
000040  6860              LDR      r0,[r4,#4]
000042  ba00              REV      r0,r0
000044  9006              STR      r0,[sp,#0x18]
;;;546        keyaddr+=4;
;;;547        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000046  68a0              LDR      r0,[r4,#8]
000048  ba00              REV      r0,r0
00004a  9007              STR      r0,[sp,#0x1c]
;;;548        keyaddr+=4;
;;;549        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  ba00              REV      r0,r0
000050  9008              STR      r0,[sp,#0x20]
;;;550        keyaddr+=4;
;;;551        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000052  6920              LDR      r0,[r4,#0x10]
000054  ba00              REV      r0,r0
000056  9009              STR      r0,[sp,#0x24]
;;;552        keyaddr+=4;
;;;553        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000058  6960              LDR      r0,[r4,#0x14]
00005a  ba00              REV      r0,r0
00005c  900a              STR      r0,[sp,#0x28]
;;;554        keyaddr+=4;
;;;555        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005e  69a0              LDR      r0,[r4,#0x18]
000060  ba00              REV      r0,r0
000062  900b              STR      r0,[sp,#0x2c]
;;;556        keyaddr+=4;
;;;557        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000064  69e0              LDR      r0,[r4,#0x1c]
000066  ba00              REV      r0,r0
000068  900c              STR      r0,[sp,#0x30]
                  |L3.106|
;;;558        break;
;;;559        default:
;;;560        break;
;;;561      }
;;;562      /* CRYP Initialization Vectors */
;;;563      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
00006a  f8db0000          LDR      r0,[r11,#0]
00006e  ba00              REV      r0,r0
000070  9001              STR      r0,[sp,#4]
;;;564      ivaddr+=4;
;;;565      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000072  f8db0004          LDR      r0,[r11,#4]
000076  ba00              REV      r0,r0
000078  9002              STR      r0,[sp,#8]
;;;566      ivaddr+=4;
;;;567      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
00007a  f8db0008          LDR      r0,[r11,#8]
00007e  ba00              REV      r0,r0
000080  9003              STR      r0,[sp,#0xc]
;;;568      ivaddr+=4;
;;;569      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
000082  f8db000c          LDR      r0,[r11,#0xc]
000086  ba00              REV      r0,r0
000088  9004              STR      r0,[sp,#0x10]
;;;570    
;;;571      /* Key Initialisation */
;;;572      CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
00008a  a805              ADD      r0,sp,#0x14
00008c  f7fffffe          BL       CRYP_KeyInit
000090  9811              LDR      r0,[sp,#0x44]         ;526
000092  b3b8              CBZ      r0,|L3.260|
;;;573    
;;;574      /*------------------ AES Decryption ------------------*/
;;;575      if(Mode == MODE_DECRYPT) /* AES decryption */
;;;576      {
;;;577        /* Crypto Init for decryption process */
;;;578        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;579      }
;;;580      /*------------------ AES Encryption ------------------*/
;;;581      else /* AES encryption */
;;;582      {
;;;583        /* Crypto Init for Encryption process */
;;;584        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
000094  f8cd9034          STR      r9,[sp,#0x34]
                  |L3.152|
;;;585      }
;;;586      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
000098  2030              MOVS     r0,#0x30
00009a  900e              STR      r0,[sp,#0x38]
;;;587      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00009c  2080              MOVS     r0,#0x80
00009e  900f              STR      r0,[sp,#0x3c]
;;;588      CRYP_Init(&AES_CRYP_InitStructure);
0000a0  a80d              ADD      r0,sp,#0x34
0000a2  f7fffffe          BL       CRYP_Init
;;;589    
;;;590      /* CRYP Initialization Vectors */
;;;591      CRYP_IVInit(&AES_CRYP_IVInitStructure);
0000a6  a801              ADD      r0,sp,#4
0000a8  f7fffffe          BL       CRYP_IVInit
;;;592    
;;;593      /* Flush IN/OUT FIFOs */
;;;594      CRYP_FIFOFlush();
0000ac  f7fffffe          BL       CRYP_FIFOFlush
;;;595    
;;;596      /* Enable Crypto processor */
;;;597      CRYP_Cmd(ENABLE);
0000b0  2001              MOVS     r0,#1
0000b2  f7fffffe          BL       CRYP_Cmd
;;;598    
;;;599      if(CRYP_GetCmdStatus() == DISABLE)
0000b6  f7fffffe          BL       CRYP_GetCmdStatus
0000ba  b338              CBZ      r0,|L3.268|
0000bc  e05b              B        |L3.374|
                  |L3.190|
0000be  f8cd9040          STR      r9,[sp,#0x40]         ;518
0000c2  6820              LDR      r0,[r4,#0]            ;519
0000c4  ba00              REV      r0,r0                 ;519
0000c6  9009              STR      r0,[sp,#0x24]         ;519
0000c8  6860              LDR      r0,[r4,#4]            ;521
0000ca  ba00              REV      r0,r0                 ;521
0000cc  900a              STR      r0,[sp,#0x28]         ;521
0000ce  68a0              LDR      r0,[r4,#8]            ;523
0000d0  ba00              REV      r0,r0                 ;523
0000d2  900b              STR      r0,[sp,#0x2c]         ;523
0000d4  68e0              LDR      r0,[r4,#0xc]          ;525
0000d6  ba00              REV      r0,r0                 ;525
0000d8  900c              STR      r0,[sp,#0x30]         ;525
0000da  e7c6              B        |L3.106|
                  |L3.220|
0000dc  9110              STR      r1,[sp,#0x40]         ;528
0000de  6820              LDR      r0,[r4,#0]            ;529
0000e0  ba00              REV      r0,r0                 ;529
0000e2  9007              STR      r0,[sp,#0x1c]         ;529
0000e4  6860              LDR      r0,[r4,#4]            ;531
0000e6  ba00              REV      r0,r0                 ;531
0000e8  9008              STR      r0,[sp,#0x20]         ;531
0000ea  68a0              LDR      r0,[r4,#8]            ;533
0000ec  ba00              REV      r0,r0                 ;533
0000ee  9009              STR      r0,[sp,#0x24]         ;533
0000f0  68e0              LDR      r0,[r4,#0xc]          ;535
0000f2  ba00              REV      r0,r0                 ;535
0000f4  900a              STR      r0,[sp,#0x28]         ;535
0000f6  6920              LDR      r0,[r4,#0x10]         ;537
0000f8  ba00              REV      r0,r0                 ;537
0000fa  900b              STR      r0,[sp,#0x2c]         ;537
0000fc  6960              LDR      r0,[r4,#0x14]         ;539
0000fe  ba00              REV      r0,r0                 ;539
000100  900c              STR      r0,[sp,#0x30]         ;539
000102  e7b2              B        |L3.106|
                  |L3.260|
000104  e7ff              B        |L3.262|
                  |L3.262|
000106  2004              MOVS     r0,#4                 ;578
000108  900d              STR      r0,[sp,#0x34]         ;578
00010a  e7c5              B        |L3.152|
                  |L3.268|
;;;600      {
;;;601        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;602           the CRYP peripheral (please check the device sales type. */
;;;603        return(ERROR);
00010c  2000              MOVS     r0,#0
                  |L3.270|
;;;604      }
;;;605      
;;;606      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
;;;607      {
;;;608    
;;;609        /* Write the Input block in the IN FIFO */
;;;610        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;611        inputaddr+=4;
;;;612        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;613        inputaddr+=4;
;;;614        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;615        inputaddr+=4;
;;;616        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;617        inputaddr+=4;
;;;618        /* Wait until the complete message has been processed */
;;;619        counter = 0;
;;;620        do
;;;621        {
;;;622          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;623          counter++;
;;;624        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;625    
;;;626        if (busystatus != RESET)
;;;627       {
;;;628           status = ERROR;
;;;629        }
;;;630        else
;;;631        {
;;;632    
;;;633          /* Read the Output block from the Output FIFO */
;;;634          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;635          outputaddr+=4;
;;;636          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;637          outputaddr+=4;
;;;638          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;639          outputaddr+=4;
;;;640          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;641          outputaddr+=4;
;;;642        }
;;;643      }
;;;644      /* Disable Crypto */
;;;645      CRYP_Cmd(DISABLE);
;;;646    
;;;647      return status;
;;;648    }
00010e  b015              ADD      sp,sp,#0x54
000110  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.276|
000114  6828              LDR      r0,[r5,#0]            ;610
000116  f7fffffe          BL       CRYP_DataIn
00011a  1d2d              ADDS     r5,r5,#4              ;611
00011c  6828              LDR      r0,[r5,#0]            ;612
00011e  f7fffffe          BL       CRYP_DataIn
000122  1d2d              ADDS     r5,r5,#4              ;613
000124  6828              LDR      r0,[r5,#0]            ;614
000126  f7fffffe          BL       CRYP_DataIn
00012a  1d2d              ADDS     r5,r5,#4              ;615
00012c  6828              LDR      r0,[r5,#0]            ;616
00012e  f7fffffe          BL       CRYP_DataIn
000132  1d2d              ADDS     r5,r5,#4              ;617
000134  f8cd9000          STR      r9,[sp,#0]            ;619
000138  f44f3480          MOV      r4,#0x10000           ;624
                  |L3.316|
00013c  2010              MOVS     r0,#0x10              ;622
00013e  f7fffffe          BL       CRYP_GetFlagStatus
000142  9900              LDR      r1,[sp,#0]            ;623
000144  1c49              ADDS     r1,r1,#1              ;623
000146  9100              STR      r1,[sp,#0]            ;623
000148  9900              LDR      r1,[sp,#0]            ;624
00014a  42a1              CMP      r1,r4                 ;624
00014c  d001              BEQ      |L3.338|
00014e  2800              CMP      r0,#0                 ;624
000150  d1f4              BNE      |L3.316|
                  |L3.338|
000152  b110              CBZ      r0,|L3.346|
000154  f04f0800          MOV      r8,#0                 ;628
000158  e00c              B        |L3.372|
                  |L3.346|
00015a  f7fffffe          BL       CRYP_DataOut
00015e  6030              STR      r0,[r6,#0]            ;634
000160  f7fffffe          BL       CRYP_DataOut
000164  6070              STR      r0,[r6,#4]            ;636
000166  f7fffffe          BL       CRYP_DataOut
00016a  60b0              STR      r0,[r6,#8]            ;638
00016c  f7fffffe          BL       CRYP_DataOut
000170  60f0              STR      r0,[r6,#0xc]          ;640
000172  3610              ADDS     r6,r6,#0x10           ;640
                  |L3.372|
000174  3710              ADDS     r7,r7,#0x10           ;606
                  |L3.374|
000176  4557              CMP      r7,r10                ;606
000178  d202              BCS      |L3.384|
00017a  f1b80f00          CMP      r8,#0                 ;606
00017e  d1c9              BNE      |L3.276|
                  |L3.384|
000180  2000              MOVS     r0,#0                 ;645
000182  f7fffffe          BL       CRYP_Cmd
000186  4640              MOV      r0,r8                 ;647
000188  e7c1              B        |L3.270|
;;;649    
                          ENDP


                          AREA ||i.CRYP_AES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_AES_ECB PROC
;;;105      */
;;;106    ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;107                             uint8_t* Input, uint32_t Ilength, uint8_t* Output)
;;;108    {
000004  b08d              SUB      sp,sp,#0x34
000006  4683              MOV      r11,r0
000008  e9dd9616          LDRD     r9,r6,[sp,#0x58]
00000c  460c              MOV      r4,r1
00000e  4692              MOV      r10,r2
000010  461d              MOV      r5,r3
;;;109      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;110      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;111      __IO uint32_t counter = 0;
000012  f04f0800          MOV      r8,#0
000016  f8cd8000          STR      r8,[sp,#0]
;;;112      uint32_t busystatus = 0;
;;;113      ErrorStatus status = SUCCESS;
00001a  2701              MOVS     r7,#1
;;;114      uint32_t keyaddr    = (uint32_t)Key;
;;;115      uint32_t inputaddr  = (uint32_t)Input;
;;;116      uint32_t outputaddr = (uint32_t)Output;
;;;117      uint32_t i = 0;
;;;118    
;;;119      /* Crypto structures initialisation*/
;;;120      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00001c  a801              ADD      r0,sp,#4
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;121    
;;;122      switch(Keysize)
000022  f1ba0f80          CMP      r10,#0x80
000026  d03a              BEQ      |L4.158|
000028  0238              LSLS     r0,r7,#8
00002a  f1ba0fc0          CMP      r10,#0xc0
00002e  d045              BEQ      |L4.188|
000030  4582              CMP      r10,r0
000032  d119              BNE      |L4.104|
;;;123      {
;;;124        case 128:
;;;125        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;126        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;127        keyaddr+=4;
;;;128        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;129        keyaddr+=4;
;;;130        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;131        keyaddr+=4;
;;;132        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;133        break;
;;;134        case 192:
;;;135        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;136        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;137        keyaddr+=4;
;;;138        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;139        keyaddr+=4;
;;;140        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;141        keyaddr+=4;
;;;142        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;143        keyaddr+=4;
;;;144        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;145        keyaddr+=4;
;;;146        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;147        break;
;;;148        case 256:
;;;149        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000034  0040              LSLS     r0,r0,#1
000036  900c              STR      r0,[sp,#0x30]
;;;150        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
000038  6820              LDR      r0,[r4,#0]
00003a  ba00              REV      r0,r0
00003c  9001              STR      r0,[sp,#4]
;;;151        keyaddr+=4;
;;;152        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
00003e  6860              LDR      r0,[r4,#4]
000040  ba00              REV      r0,r0
000042  9002              STR      r0,[sp,#8]
;;;153        keyaddr+=4;
;;;154        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000044  68a0              LDR      r0,[r4,#8]
000046  ba00              REV      r0,r0
000048  9003              STR      r0,[sp,#0xc]
;;;155        keyaddr+=4;
;;;156        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  ba00              REV      r0,r0
00004e  9004              STR      r0,[sp,#0x10]
;;;157        keyaddr+=4;
;;;158        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000050  6920              LDR      r0,[r4,#0x10]
000052  ba00              REV      r0,r0
000054  9005              STR      r0,[sp,#0x14]
;;;159        keyaddr+=4;
;;;160        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000056  6960              LDR      r0,[r4,#0x14]
000058  ba00              REV      r0,r0
00005a  9006              STR      r0,[sp,#0x18]
;;;161        keyaddr+=4;
;;;162        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00005c  69a0              LDR      r0,[r4,#0x18]
00005e  ba00              REV      r0,r0
000060  9007              STR      r0,[sp,#0x1c]
;;;163        keyaddr+=4;
;;;164        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000062  69e0              LDR      r0,[r4,#0x1c]
000064  ba00              REV      r0,r0
000066  9008              STR      r0,[sp,#0x20]
                  |L4.104|
;;;165        break;
;;;166        default:
;;;167        break;
;;;168      }
;;;169    
;;;170      /*------------------ AES Decryption ------------------*/
;;;171      if(Mode == MODE_DECRYPT) /* AES decryption */
;;;172      {
;;;173        /* Flush IN/OUT FIFOs */
;;;174        CRYP_FIFOFlush();
;;;175    
;;;176        /* Crypto Init for Key preparation for decryption process */
;;;177        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;178        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
;;;179        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
;;;180        CRYP_Init(&AES_CRYP_InitStructure);
;;;181    
;;;182        /* Key Initialisation */
;;;183        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;184    
;;;185        /* Enable Crypto processor */
;;;186        CRYP_Cmd(ENABLE);
;;;187    
;;;188        /* wait until the Busy flag is RESET */
;;;189        do
;;;190        {
;;;191          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;192          counter++;
;;;193        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
000068  f44f3a80          MOV      r10,#0x10000
00006c  f1bb0f00          CMP      r11,#0                ;171
000070  d038              BEQ      |L4.228|
;;;194    
;;;195        if (busystatus != RESET)
;;;196       {
;;;197           status = ERROR;
;;;198        }
;;;199        else
;;;200        {
;;;201          /* Crypto Init for decryption process */  
;;;202          AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
;;;203        }
;;;204      }
;;;205      /*------------------ AES Encryption ------------------*/
;;;206      else /* AES encryption */
;;;207      {
;;;208    
;;;209        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
000072  a801              ADD      r0,sp,#4
000074  f7fffffe          BL       CRYP_KeyInit
;;;210    
;;;211        /* Crypto Init for Encryption process */
;;;212        AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
000078  f8cd8024          STR      r8,[sp,#0x24]
                  |L4.124|
;;;213      }
;;;214    
;;;215      AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
00007c  2020              MOVS     r0,#0x20
00007e  900a              STR      r0,[sp,#0x28]
;;;216      AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
000080  2080              MOVS     r0,#0x80
000082  900b              STR      r0,[sp,#0x2c]
;;;217      CRYP_Init(&AES_CRYP_InitStructure);
000084  a809              ADD      r0,sp,#0x24
000086  f7fffffe          BL       CRYP_Init
;;;218    
;;;219      /* Flush IN/OUT FIFOs */
;;;220      CRYP_FIFOFlush();
00008a  f7fffffe          BL       CRYP_FIFOFlush
;;;221    
;;;222      /* Enable Crypto processor */
;;;223      CRYP_Cmd(ENABLE);
00008e  2001              MOVS     r0,#1
000090  f7fffffe          BL       CRYP_Cmd
;;;224    
;;;225      if(CRYP_GetCmdStatus() == DISABLE)
000094  f7fffffe          BL       CRYP_GetCmdStatus
000098  b3f0              CBZ      r0,|L4.280|
;;;226      {
;;;227        /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;228           the CRYP peripheral (please check the device sales type. */
;;;229        return(ERROR);
;;;230      }
;;;231      
;;;232      for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
00009a  2400              MOVS     r4,#0
00009c  e077              B        |L4.398|
                  |L4.158|
00009e  f8cd8030          STR      r8,[sp,#0x30]         ;125
0000a2  6820              LDR      r0,[r4,#0]            ;126
0000a4  ba00              REV      r0,r0                 ;126
0000a6  9005              STR      r0,[sp,#0x14]         ;126
0000a8  6860              LDR      r0,[r4,#4]            ;128
0000aa  ba00              REV      r0,r0                 ;128
0000ac  9006              STR      r0,[sp,#0x18]         ;128
0000ae  68a0              LDR      r0,[r4,#8]            ;130
0000b0  ba00              REV      r0,r0                 ;130
0000b2  9007              STR      r0,[sp,#0x1c]         ;130
0000b4  68e0              LDR      r0,[r4,#0xc]          ;132
0000b6  ba00              REV      r0,r0                 ;132
0000b8  9008              STR      r0,[sp,#0x20]         ;132
0000ba  e7d5              B        |L4.104|
                  |L4.188|
0000bc  900c              STR      r0,[sp,#0x30]         ;135
0000be  6820              LDR      r0,[r4,#0]            ;136
0000c0  ba00              REV      r0,r0                 ;136
0000c2  9003              STR      r0,[sp,#0xc]          ;136
0000c4  6860              LDR      r0,[r4,#4]            ;138
0000c6  ba00              REV      r0,r0                 ;138
0000c8  9004              STR      r0,[sp,#0x10]         ;138
0000ca  68a0              LDR      r0,[r4,#8]            ;140
0000cc  ba00              REV      r0,r0                 ;140
0000ce  9005              STR      r0,[sp,#0x14]         ;140
0000d0  68e0              LDR      r0,[r4,#0xc]          ;142
0000d2  ba00              REV      r0,r0                 ;142
0000d4  9006              STR      r0,[sp,#0x18]         ;142
0000d6  6920              LDR      r0,[r4,#0x10]         ;144
0000d8  ba00              REV      r0,r0                 ;144
0000da  9007              STR      r0,[sp,#0x1c]         ;144
0000dc  6960              LDR      r0,[r4,#0x14]         ;146
0000de  ba00              REV      r0,r0                 ;146
0000e0  9008              STR      r0,[sp,#0x20]         ;146
0000e2  e7c1              B        |L4.104|
                  |L4.228|
0000e4  f7fffffe          BL       CRYP_FIFOFlush
0000e8  2404              MOVS     r4,#4                 ;177
0000ea  9409              STR      r4,[sp,#0x24]         ;177
0000ec  2038              MOVS     r0,#0x38              ;178
0000ee  900a              STR      r0,[sp,#0x28]         ;178
0000f0  f8cd802c          STR      r8,[sp,#0x2c]         ;179
0000f4  a809              ADD      r0,sp,#0x24           ;180
0000f6  f7fffffe          BL       CRYP_Init
0000fa  a801              ADD      r0,sp,#4              ;183
0000fc  f7fffffe          BL       CRYP_KeyInit
000100  2001              MOVS     r0,#1                 ;186
000102  f7fffffe          BL       CRYP_Cmd
                  |L4.262|
000106  2010              MOVS     r0,#0x10              ;191
000108  f7fffffe          BL       CRYP_GetFlagStatus
00010c  9900              LDR      r1,[sp,#0]            ;192
00010e  1c49              ADDS     r1,r1,#1              ;192
000110  9100              STR      r1,[sp,#0]            ;192
000112  9900              LDR      r1,[sp,#0]            ;193
000114  4551              CMP      r1,r10                ;193
000116  e000              B        |L4.282|
                  |L4.280|
000118  e007              B        |L4.298|
                  |L4.282|
00011a  d001              BEQ      |L4.288|
00011c  2800              CMP      r0,#0                 ;193
00011e  d1f2              BNE      |L4.262|
                  |L4.288|
000120  b108              CBZ      r0,|L4.294|
000122  2700              MOVS     r7,#0                 ;197
000124  e7aa              B        |L4.124|
                  |L4.294|
000126  9409              STR      r4,[sp,#0x24]         ;202
000128  e7a8              B        |L4.124|
                  |L4.298|
00012a  2000              MOVS     r0,#0                 ;229
                  |L4.300|
;;;233      {
;;;234    
;;;235        /* Write the Input block in the IN FIFO */
;;;236        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;237        inputaddr+=4;
;;;238        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;239        inputaddr+=4;
;;;240        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;241        inputaddr+=4;
;;;242        CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;243        inputaddr+=4;
;;;244    
;;;245        /* Wait until the complete message has been processed */
;;;246        counter = 0;
;;;247        do
;;;248        {
;;;249          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;250          counter++;
;;;251        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;252    
;;;253        if (busystatus != RESET)
;;;254       {
;;;255           status = ERROR;
;;;256        }
;;;257        else
;;;258        {
;;;259    
;;;260          /* Read the Output block from the Output FIFO */
;;;261          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;262          outputaddr+=4;
;;;263          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;264          outputaddr+=4;
;;;265          *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;266          outputaddr+=4;
;;;267          *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
;;;268          outputaddr+=4;
;;;269        }
;;;270      }
;;;271    
;;;272      /* Disable Crypto */
;;;273      CRYP_Cmd(DISABLE);
;;;274    
;;;275      return status; 
;;;276    }
00012c  b00d              ADD      sp,sp,#0x34
00012e  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.306|
000132  6828              LDR      r0,[r5,#0]            ;236
000134  f7fffffe          BL       CRYP_DataIn
000138  1d2d              ADDS     r5,r5,#4              ;237
00013a  6828              LDR      r0,[r5,#0]            ;238
00013c  f7fffffe          BL       CRYP_DataIn
000140  1d2d              ADDS     r5,r5,#4              ;239
000142  6828              LDR      r0,[r5,#0]            ;240
000144  f7fffffe          BL       CRYP_DataIn
000148  1d2d              ADDS     r5,r5,#4              ;241
00014a  6828              LDR      r0,[r5,#0]            ;242
00014c  f7fffffe          BL       CRYP_DataIn
000150  1d2d              ADDS     r5,r5,#4              ;243
000152  f8cd8000          STR      r8,[sp,#0]            ;246
                  |L4.342|
000156  2010              MOVS     r0,#0x10              ;249
000158  f7fffffe          BL       CRYP_GetFlagStatus
00015c  9900              LDR      r1,[sp,#0]            ;250
00015e  1c49              ADDS     r1,r1,#1              ;250
000160  9100              STR      r1,[sp,#0]            ;250
000162  9900              LDR      r1,[sp,#0]            ;251
000164  4551              CMP      r1,r10                ;251
000166  d001              BEQ      |L4.364|
000168  2800              CMP      r0,#0                 ;251
00016a  d1f4              BNE      |L4.342|
                  |L4.364|
00016c  b108              CBZ      r0,|L4.370|
00016e  2700              MOVS     r7,#0                 ;255
000170  e00c              B        |L4.396|
                  |L4.370|
000172  f7fffffe          BL       CRYP_DataOut
000176  6030              STR      r0,[r6,#0]            ;261
000178  f7fffffe          BL       CRYP_DataOut
00017c  6070              STR      r0,[r6,#4]            ;263
00017e  f7fffffe          BL       CRYP_DataOut
000182  60b0              STR      r0,[r6,#8]            ;265
000184  f7fffffe          BL       CRYP_DataOut
000188  60f0              STR      r0,[r6,#0xc]          ;267
00018a  3610              ADDS     r6,r6,#0x10           ;267
                  |L4.396|
00018c  3410              ADDS     r4,r4,#0x10           ;232
                  |L4.398|
00018e  454c              CMP      r4,r9                 ;232
000190  d201              BCS      |L4.406|
000192  2f00              CMP      r7,#0                 ;232
000194  d1cd              BNE      |L4.306|
                  |L4.406|
000196  2000              MOVS     r0,#0                 ;273
000198  f7fffffe          BL       CRYP_Cmd
00019c  4638              MOV      r0,r7                 ;275
00019e  e7c5              B        |L4.300|
;;;277    
                          ENDP


                          AREA ||i.CRYP_AES_GCM||, CODE, READONLY, ALIGN=1

                  CRYP_AES_GCM PROC
;;;669      */
;;;670    ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;671                             uint8_t *Key, uint16_t Keysize,
;;;672                             uint8_t *Input, uint32_t ILength,
;;;673                             uint8_t *Header, uint32_t HLength,
;;;674                             uint8_t *Output, uint8_t *AuthTAG)
;;;675    {
000004  b095              SUB      sp,sp,#0x54
000006  f8dda090          LDR      r10,[sp,#0x90]
00000a  f8dd9098          LDR      r9,[sp,#0x98]
00000e  9c22              LDR      r4,[sp,#0x88]
;;;676      CRYP_InitTypeDef AES_CRYP_InitStructure;
;;;677      CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
;;;678      CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
;;;679      __IO uint32_t counter = 0;
000010  f04f0800          MOV      r8,#0
000014  f8cd8010          STR      r8,[sp,#0x10]
;;;680      uint32_t busystatus = 0;
;;;681      ErrorStatus status = SUCCESS;
000018  f04f0b01          MOV      r11,#1
;;;682      uint32_t keyaddr    = (uint32_t)Key;
00001c  9203              STR      r2,[sp,#0xc]
;;;683      uint32_t inputaddr  = (uint32_t)Input;
;;;684      uint32_t outputaddr = (uint32_t)Output;
;;;685      uint32_t ivaddr     = (uint32_t)InitVectors;
00001e  9102              STR      r1,[sp,#8]
;;;686      uint32_t headeraddr = (uint32_t)Header;
;;;687      uint32_t tagaddr = (uint32_t)AuthTAG;
;;;688      uint64_t headerlength = HLength * 8;/* header length in bits */
000020  9825              LDR      r0,[sp,#0x94]
000022  4646              MOV      r6,r8
000024  00c5              LSLS     r5,r0,#3
;;;689      uint64_t inputlength = ILength * 8;/* input length in bits */
000026  9823              LDR      r0,[sp,#0x8c]
000028  00c7              LSLS     r7,r0,#3
;;;690      uint32_t loopcounter = 0;
;;;691    
;;;692      /* Crypto structures initialisation*/
;;;693      CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
00002a  a809              ADD      r0,sp,#0x24
00002c  f7fffffe          BL       CRYP_KeyStructInit
;;;694    
;;;695      switch(Keysize)
000030  9818              LDR      r0,[sp,#0x60]
000032  2880              CMP      r0,#0x80
000034  d05e              BEQ      |L5.244|
000036  f44f7180          MOV      r1,#0x100
00003a  28c0              CMP      r0,#0xc0
00003c  d06b              BEQ      |L5.278|
00003e  4288              CMP      r0,r1
000040  d11b              BNE      |L5.122|
;;;696      {
;;;697        case 128:
;;;698        AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
;;;699        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;700        keyaddr+=4;
;;;701        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;702        keyaddr+=4;
;;;703        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;704        keyaddr+=4;
;;;705        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;706        break;
;;;707        case 192:
;;;708        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
;;;709        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
;;;710        keyaddr+=4;
;;;711        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
;;;712        keyaddr+=4;
;;;713        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
;;;714        keyaddr+=4;
;;;715        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
;;;716        keyaddr+=4;
;;;717        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
;;;718        keyaddr+=4;
;;;719        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
;;;720        break;
;;;721        case 256:
;;;722        AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
000042  0040              LSLS     r0,r0,#1
000044  9014              STR      r0,[sp,#0x50]
;;;723        AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
000046  9803              LDR      r0,[sp,#0xc]
000048  6800              LDR      r0,[r0,#0]
00004a  ba00              REV      r0,r0
00004c  9009              STR      r0,[sp,#0x24]
;;;724        keyaddr+=4;
00004e  9803              LDR      r0,[sp,#0xc]
;;;725        AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
000050  6841              LDR      r1,[r0,#4]
000052  ba09              REV      r1,r1
000054  910a              STR      r1,[sp,#0x28]
;;;726        keyaddr+=4;
;;;727        AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000056  6881              LDR      r1,[r0,#8]
000058  ba09              REV      r1,r1
00005a  910b              STR      r1,[sp,#0x2c]
;;;728        keyaddr+=4;
;;;729        AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00005c  68c1              LDR      r1,[r0,#0xc]
00005e  ba09              REV      r1,r1
000060  910c              STR      r1,[sp,#0x30]
;;;730        keyaddr+=4;
;;;731        AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000062  6901              LDR      r1,[r0,#0x10]
000064  ba09              REV      r1,r1
000066  910d              STR      r1,[sp,#0x34]
;;;732        keyaddr+=4;
;;;733        AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000068  6941              LDR      r1,[r0,#0x14]
00006a  ba09              REV      r1,r1
00006c  910e              STR      r1,[sp,#0x38]
;;;734        keyaddr+=4;
;;;735        AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
00006e  6981              LDR      r1,[r0,#0x18]
000070  ba09              REV      r1,r1
000072  910f              STR      r1,[sp,#0x3c]
;;;736        keyaddr+=4;
;;;737        AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000074  69c0              LDR      r0,[r0,#0x1c]
000076  ba00              REV      r0,r0
000078  9010              STR      r0,[sp,#0x40]
                  |L5.122|
;;;738        break;
;;;739        default:
;;;740        break;
;;;741      }
;;;742      
;;;743      /* CRYP Initialization Vectors */
;;;744      AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
00007a  9802              LDR      r0,[sp,#8]
00007c  6800              LDR      r0,[r0,#0]
00007e  ba00              REV      r0,r0
000080  9005              STR      r0,[sp,#0x14]
;;;745      ivaddr+=4;
000082  9802              LDR      r0,[sp,#8]
;;;746      AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000084  6841              LDR      r1,[r0,#4]
000086  ba09              REV      r1,r1
000088  9106              STR      r1,[sp,#0x18]
;;;747      ivaddr+=4;
;;;748      AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
00008a  6881              LDR      r1,[r0,#8]
00008c  ba09              REV      r1,r1
00008e  9107              STR      r1,[sp,#0x1c]
;;;749      ivaddr+=4;
;;;750      AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
000090  68c0              LDR      r0,[r0,#0xc]
000092  ba00              REV      r0,r0
000094  9008              STR      r0,[sp,#0x20]
;;;751      
;;;752      /*------------------ AES Encryption ------------------*/
;;;753      if(Mode == MODE_ENCRYPT) /* AES encryption */
000096  9815              LDR      r0,[sp,#0x54]
000098  2801              CMP      r0,#1
00009a  d052              BEQ      |L5.322|
;;;754      {
;;;755        /* Flush IN/OUT FIFOs */
;;;756        CRYP_FIFOFlush();
;;;757        
;;;758        /* Key Initialisation */
;;;759        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
;;;760        
;;;761        /* CRYP Initialization Vectors */
;;;762        CRYP_IVInit(&AES_CRYP_IVInitStructure);
;;;763        
;;;764        /* Crypto Init for Key preparation for decryption process */
;;;765        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;766        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
;;;767        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
;;;768        CRYP_Init(&AES_CRYP_InitStructure);
;;;769        
;;;770        /***************************** Init phase *********************************/
;;;771        /* Select init phase */
;;;772        CRYP_PhaseConfig(CRYP_Phase_Init);
;;;773        
;;;774        /* Enable Crypto processor */
;;;775        CRYP_Cmd(ENABLE);
;;;776        
;;;777        /* Wait for CRYPEN bit to be 0 */
;;;778        while(CRYP_GetCmdStatus() == ENABLE)
;;;779        {
;;;780        }
;;;781        
;;;782        /***************************** header phase *******************************/
;;;783        if(HLength != 0)
;;;784        {
;;;785          /* Select header phase */
;;;786          CRYP_PhaseConfig(CRYP_Phase_Header);
;;;787          
;;;788          /* Enable Crypto processor */
;;;789          CRYP_Cmd(ENABLE);
;;;790          
;;;791          if(CRYP_GetCmdStatus() == DISABLE)
;;;792          {
;;;793             /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;794                the CRYP peripheral (please check the device sales type. */
;;;795             return(ERROR);
;;;796          }
;;;797          
;;;798          for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
;;;799          {
;;;800            /* Wait until the IFEM flag is reset */
;;;801            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;802            {
;;;803            }
;;;804            
;;;805            /* Write the Input block in the IN FIFO */
;;;806            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;807            headeraddr+=4;
;;;808            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;809            headeraddr+=4;
;;;810            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;811            headeraddr+=4;
;;;812            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;813            headeraddr+=4;
;;;814          }
;;;815          
;;;816          /* Wait until the complete message has been processed */
;;;817          counter = 0;
;;;818          do
;;;819          {
;;;820            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;821            counter++;
;;;822          }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;823    
;;;824          if (busystatus != RESET)
;;;825          {
;;;826            status = ERROR;
;;;827          }
;;;828        }
;;;829        
;;;830        /**************************** payload phase *******************************/
;;;831        if(ILength != 0)
;;;832        {
;;;833          /* Select payload phase */
;;;834          CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;835          
;;;836          /* Enable Crypto processor */
;;;837          CRYP_Cmd(ENABLE);
;;;838          
;;;839          if(CRYP_GetCmdStatus() == DISABLE)
;;;840          {
;;;841            /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;842               the CRYP peripheral (please check the device sales type. */
;;;843            return(ERROR);
;;;844          }
;;;845          
;;;846          for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;847          {
;;;848            /* Wait until the IFEM flag is reset */
;;;849            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;850            {
;;;851            }
;;;852            /* Write the Input block in the IN FIFO */
;;;853            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;854            inputaddr+=4;
;;;855            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;856            inputaddr+=4;
;;;857            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;858            inputaddr+=4;
;;;859            CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;860            inputaddr+=4;
;;;861            
;;;862            /* Wait until the complete message has been processed */
;;;863            counter = 0;
;;;864            do
;;;865            {
;;;866              busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;867              counter++;
;;;868            }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;869    
;;;870            if (busystatus != RESET)
;;;871            {
;;;872              status = ERROR;
;;;873            }
;;;874            else
;;;875            {
;;;876              /* Wait until the OFNE flag is reset */
;;;877              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;878              {
;;;879              }
;;;880              
;;;881              /* Read the Output block from the Output FIFO */
;;;882              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;883              outputaddr+=4;
;;;884              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;885              outputaddr+=4;
;;;886              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;887              outputaddr+=4;
;;;888              *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;889              outputaddr+=4;
;;;890            }
;;;891          }
;;;892        }
;;;893        
;;;894        /***************************** final phase ********************************/
;;;895        /* Select final phase */
;;;896        CRYP_PhaseConfig(CRYP_Phase_Final);
;;;897        
;;;898        /* Enable Crypto processor */
;;;899        CRYP_Cmd(ENABLE);
;;;900        
;;;901        if(CRYP_GetCmdStatus() == DISABLE)
;;;902        {
;;;903          /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;904             the CRYP peripheral (please check the device sales type. */
;;;905          return(ERROR);
;;;906        }
;;;907        
;;;908        /* Write number of bits concatenated with header in the IN FIFO */
;;;909        CRYP_DataIn(__REV(headerlength>>32));
;;;910        CRYP_DataIn(__REV(headerlength));
;;;911        CRYP_DataIn(__REV(inputlength>>32));
;;;912        CRYP_DataIn(__REV(inputlength));
;;;913        /* Wait until the OFNE flag is reset */
;;;914        while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;915        {
;;;916        }
;;;917        
;;;918        tagaddr = (uint32_t)AuthTAG;
;;;919        /* Read the Auth TAG in the IN FIFO */
;;;920        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;921        tagaddr+=4;
;;;922        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;923        tagaddr+=4;
;;;924        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;925        tagaddr+=4;
;;;926        *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;927        tagaddr+=4;
;;;928      }
;;;929      /*------------------ AES Decryption ------------------*/
;;;930      else /* AES decryption */
;;;931      {
;;;932        /* Flush IN/OUT FIFOs */
;;;933        CRYP_FIFOFlush();
00009c  f7fffffe          BL       CRYP_FIFOFlush
;;;934        
;;;935        /* Key Initialisation */
;;;936        CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
0000a0  a809              ADD      r0,sp,#0x24
0000a2  f7fffffe          BL       CRYP_KeyInit
;;;937        
;;;938        /* CRYP Initialization Vectors */
;;;939        CRYP_IVInit(&AES_CRYP_IVInitStructure);
0000a6  a805              ADD      r0,sp,#0x14
0000a8  f7fffffe          BL       CRYP_IVInit
;;;940        
;;;941        /* Crypto Init for Key preparation for decryption process */
;;;942        AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
0000ac  2004              MOVS     r0,#4
0000ae  9011              STR      r0,[sp,#0x44]
;;;943        AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
0000b0  0440              LSLS     r0,r0,#17
0000b2  9012              STR      r0,[sp,#0x48]
;;;944        AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
0000b4  2080              MOVS     r0,#0x80
0000b6  9013              STR      r0,[sp,#0x4c]
;;;945        CRYP_Init(&AES_CRYP_InitStructure);
0000b8  a811              ADD      r0,sp,#0x44
0000ba  f7fffffe          BL       CRYP_Init
;;;946        
;;;947        /***************************** Init phase *********************************/
;;;948        /* Select init phase */
;;;949        CRYP_PhaseConfig(CRYP_Phase_Init);
0000be  2000              MOVS     r0,#0
0000c0  f7fffffe          BL       CRYP_PhaseConfig
;;;950        
;;;951        /* Enable Crypto processor */
;;;952        CRYP_Cmd(ENABLE);
0000c4  2001              MOVS     r0,#1
0000c6  f7fffffe          BL       CRYP_Cmd
                  |L5.202|
;;;953        
;;;954        /* Wait for CRYPEN bit to be 0 */
;;;955        while(CRYP_GetCmdStatus() == ENABLE)
0000ca  f7fffffe          BL       CRYP_GetCmdStatus
0000ce  2801              CMP      r0,#1
0000d0  d0fb              BEQ      |L5.202|
;;;956        {
;;;957        }
;;;958        
;;;959        /***************************** header phase *******************************/
;;;960        if(HLength != 0)
0000d2  9825              LDR      r0,[sp,#0x94]
0000d4  2800              CMP      r0,#0
0000d6  d07d              BEQ      |L5.468|
;;;961        {
;;;962          /* Select header phase */
;;;963          CRYP_PhaseConfig(CRYP_Phase_Header);
0000d8  f44f3080          MOV      r0,#0x10000
0000dc  f7fffffe          BL       CRYP_PhaseConfig
;;;964          
;;;965          /* Enable Crypto processor */
;;;966          CRYP_Cmd(ENABLE);
0000e0  2001              MOVS     r0,#1
0000e2  f7fffffe          BL       CRYP_Cmd
;;;967          
;;;968          if(CRYP_GetCmdStatus() == DISABLE)
0000e6  f7fffffe          BL       CRYP_GetCmdStatus
0000ea  2800              CMP      r0,#0
0000ec  d073              BEQ      |L5.470|
;;;969          {
;;;970            /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;971               the CRYP peripheral (please check the device sales type. */
;;;972            return(ERROR);
;;;973          }
;;;974          
;;;975          for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
0000ee  2000              MOVS     r0,#0
0000f0  9001              STR      r0,[sp,#4]
0000f2  e12f              B        |L5.852|
                  |L5.244|
0000f4  2000              MOVS     r0,#0                 ;698
0000f6  9014              STR      r0,[sp,#0x50]         ;698
0000f8  9803              LDR      r0,[sp,#0xc]          ;699
0000fa  6800              LDR      r0,[r0,#0]            ;699
0000fc  ba00              REV      r0,r0                 ;699
0000fe  900d              STR      r0,[sp,#0x34]         ;699
000100  9803              LDR      r0,[sp,#0xc]          ;700
000102  6841              LDR      r1,[r0,#4]            ;701
000104  ba09              REV      r1,r1                 ;701
000106  910e              STR      r1,[sp,#0x38]         ;701
000108  6881              LDR      r1,[r0,#8]            ;703
00010a  ba09              REV      r1,r1                 ;703
00010c  910f              STR      r1,[sp,#0x3c]         ;703
00010e  68c0              LDR      r0,[r0,#0xc]          ;705
000110  ba00              REV      r0,r0                 ;705
000112  9010              STR      r0,[sp,#0x40]         ;705
000114  e7b1              B        |L5.122|
                  |L5.278|
000116  9114              STR      r1,[sp,#0x50]         ;708
000118  9803              LDR      r0,[sp,#0xc]          ;709
00011a  6800              LDR      r0,[r0,#0]            ;709
00011c  ba00              REV      r0,r0                 ;709
00011e  900b              STR      r0,[sp,#0x2c]         ;709
000120  9803              LDR      r0,[sp,#0xc]          ;710
000122  6841              LDR      r1,[r0,#4]            ;711
000124  ba09              REV      r1,r1                 ;711
000126  910c              STR      r1,[sp,#0x30]         ;711
000128  6881              LDR      r1,[r0,#8]            ;713
00012a  ba09              REV      r1,r1                 ;713
00012c  910d              STR      r1,[sp,#0x34]         ;713
00012e  68c1              LDR      r1,[r0,#0xc]          ;715
000130  ba09              REV      r1,r1                 ;715
000132  910e              STR      r1,[sp,#0x38]         ;715
000134  6901              LDR      r1,[r0,#0x10]         ;717
000136  ba09              REV      r1,r1                 ;717
000138  910f              STR      r1,[sp,#0x3c]         ;717
00013a  6940              LDR      r0,[r0,#0x14]         ;719
00013c  ba00              REV      r0,r0                 ;719
00013e  9010              STR      r0,[sp,#0x40]         ;719
000140  e79b              B        |L5.122|
                  |L5.322|
000142  f7fffffe          BL       CRYP_FIFOFlush
000146  a809              ADD      r0,sp,#0x24           ;759
000148  f7fffffe          BL       CRYP_KeyInit
00014c  a805              ADD      r0,sp,#0x14           ;762
00014e  f7fffffe          BL       CRYP_IVInit
000152  2000              MOVS     r0,#0                 ;765
000154  9011              STR      r0,[sp,#0x44]         ;765
000156  f44f2000          MOV      r0,#0x80000           ;766
00015a  9012              STR      r0,[sp,#0x48]         ;766
00015c  2080              MOVS     r0,#0x80              ;767
00015e  9013              STR      r0,[sp,#0x4c]         ;767
000160  a811              ADD      r0,sp,#0x44           ;768
000162  f7fffffe          BL       CRYP_Init
000166  2000              MOVS     r0,#0                 ;772
000168  f7fffffe          BL       CRYP_PhaseConfig
00016c  2001              MOVS     r0,#1                 ;775
00016e  f7fffffe          BL       CRYP_Cmd
                  |L5.370|
000172  f7fffffe          BL       CRYP_GetCmdStatus
000176  2801              CMP      r0,#1                 ;778
000178  d0fb              BEQ      |L5.370|
00017a  9825              LDR      r0,[sp,#0x94]         ;783
00017c  b360              CBZ      r0,|L5.472|
00017e  f44f3080          MOV      r0,#0x10000           ;786
000182  f7fffffe          BL       CRYP_PhaseConfig
000186  2001              MOVS     r0,#1                 ;789
000188  f7fffffe          BL       CRYP_Cmd
00018c  f7fffffe          BL       CRYP_GetCmdStatus
000190  b110              CBZ      r0,|L5.408|
000192  2000              MOVS     r0,#0                 ;798
000194  9001              STR      r0,[sp,#4]            ;798
000196  e021              B        |L5.476|
                  |L5.408|
000198  2000              MOVS     r0,#0                 ;795
                  |L5.410|
;;;976          {
;;;977            /* Wait until the IFEM flag is reset */
;;;978            while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;979            {
;;;980            }
;;;981            
;;;982            /* Write the Input block in the IN FIFO */
;;;983            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;984            headeraddr+=4;
;;;985            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;986            headeraddr+=4;
;;;987            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;988            headeraddr+=4;
;;;989            CRYP_DataIn(*(uint32_t*)(headeraddr));
;;;990            headeraddr+=4;
;;;991          }
;;;992          
;;;993          /* Wait until the complete message has been processed */
;;;994          counter = 0;
;;;995          do
;;;996          {
;;;997            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;998            counter++;
;;;999          }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1000   
;;;1001         if (busystatus != RESET)
;;;1002         {
;;;1003           status = ERROR;
;;;1004         }
;;;1005       }
;;;1006       
;;;1007       /**************************** payload phase *******************************/
;;;1008       if(ILength != 0)
;;;1009       {
;;;1010         /* Select payload phase */
;;;1011         CRYP_PhaseConfig(CRYP_Phase_Payload);
;;;1012   
;;;1013         /* Enable Crypto processor */
;;;1014         CRYP_Cmd(ENABLE);
;;;1015         
;;;1016         if(CRYP_GetCmdStatus() == DISABLE)
;;;1017         {
;;;1018           /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1019              the CRYP peripheral (please check the device sales type. */
;;;1020           return(ERROR);
;;;1021         }
;;;1022         
;;;1023         for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
;;;1024         {
;;;1025           /* Wait until the IFEM flag is reset */
;;;1026           while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
;;;1027           {
;;;1028           }
;;;1029           /* Write the Input block in the IN FIFO */
;;;1030           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1031           inputaddr+=4;
;;;1032           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1033           inputaddr+=4;
;;;1034           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1035           inputaddr+=4;
;;;1036           CRYP_DataIn(*(uint32_t*)(inputaddr));
;;;1037           inputaddr+=4;
;;;1038           
;;;1039           /* Wait until the complete message has been processed */
;;;1040           counter = 0;
;;;1041           do
;;;1042           {
;;;1043             busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;1044             counter++;
;;;1045           }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
;;;1046   
;;;1047           if (busystatus != RESET)
;;;1048           {
;;;1049             status = ERROR;
;;;1050           }
;;;1051           else
;;;1052           {
;;;1053             /* Wait until the OFNE flag is reset */
;;;1054             while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1055             {
;;;1056             }
;;;1057             
;;;1058             /* Read the Output block from the Output FIFO */
;;;1059             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1060             outputaddr+=4;
;;;1061             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1062             outputaddr+=4;
;;;1063             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1064             outputaddr+=4;
;;;1065             *(uint32_t*)(outputaddr) = CRYP_DataOut();
;;;1066             outputaddr+=4;
;;;1067           }
;;;1068         }
;;;1069       }
;;;1070       
;;;1071       /***************************** final phase ********************************/
;;;1072       /* Select final phase */
;;;1073       CRYP_PhaseConfig(CRYP_Phase_Final);
;;;1074   
;;;1075       /* Enable Crypto processor */
;;;1076       CRYP_Cmd(ENABLE);
;;;1077       
;;;1078       if(CRYP_GetCmdStatus() == DISABLE)
;;;1079       {
;;;1080         /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
;;;1081            the CRYP peripheral (please check the device sales type. */
;;;1082         return(ERROR);
;;;1083       }
;;;1084       
;;;1085       /* Write number of bits concatenated with header in the IN FIFO */
;;;1086       CRYP_DataIn(__REV(headerlength>>32));
;;;1087       CRYP_DataIn(__REV(headerlength));
;;;1088       CRYP_DataIn(__REV(inputlength>>32));
;;;1089       CRYP_DataIn(__REV(inputlength));
;;;1090       /* Wait until the OFNE flag is reset */
;;;1091       while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
;;;1092       {
;;;1093       }
;;;1094       
;;;1095       tagaddr = (uint32_t)AuthTAG;
;;;1096       /* Read the Auth TAG in the IN FIFO */
;;;1097       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1098       tagaddr+=4;
;;;1099       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1100       tagaddr+=4;
;;;1101       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1102       tagaddr+=4;
;;;1103       *(uint32_t*)(tagaddr) = CRYP_DataOut();
;;;1104       tagaddr+=4;
;;;1105     }
;;;1106     /* Disable Crypto */
;;;1107     CRYP_Cmd(DISABLE);
;;;1108   
;;;1109     return status;
;;;1110   }
00019a  b019              ADD      sp,sp,#0x64
00019c  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.416|
0001a0  2001              MOVS     r0,#1                 ;801
0001a2  f7fffffe          BL       CRYP_GetFlagStatus
0001a6  2800              CMP      r0,#0                 ;801
0001a8  d0fa              BEQ      |L5.416|
0001aa  f8da0000          LDR      r0,[r10,#0]           ;806
0001ae  f7fffffe          BL       CRYP_DataIn
0001b2  f8da0004          LDR      r0,[r10,#4]           ;808
0001b6  f7fffffe          BL       CRYP_DataIn
0001ba  f8da0008          LDR      r0,[r10,#8]           ;810
0001be  f7fffffe          BL       CRYP_DataIn
0001c2  f85a0f0c          LDR      r0,[r10,#0xc]!        ;812
0001c6  f7fffffe          BL       CRYP_DataIn
0001ca  f10a0a04          ADD      r10,r10,#4            ;813
0001ce  9801              LDR      r0,[sp,#4]            ;798
0001d0  3010              ADDS     r0,r0,#0x10           ;798
0001d2  e002              B        |L5.474|
                  |L5.468|
0001d4  e0d4              B        |L5.896|
                  |L5.470|
0001d6  e0a1              B        |L5.796|
                  |L5.472|
0001d8  e016              B        |L5.520|
                  |L5.474|
0001da  9001              STR      r0,[sp,#4]            ;798
                  |L5.476|
0001dc  9925              LDR      r1,[sp,#0x94]         ;798
0001de  9801              LDR      r0,[sp,#4]            ;798
0001e0  4288              CMP      r0,r1                 ;798
0001e2  d3dd              BCC      |L5.416|
0001e4  2000              MOVS     r0,#0                 ;817
0001e6  9004              STR      r0,[sp,#0x10]         ;817
0001e8  f44f3a80          MOV      r10,#0x10000          ;786
                  |L5.492|
0001ec  2010              MOVS     r0,#0x10              ;820
0001ee  f7fffffe          BL       CRYP_GetFlagStatus
0001f2  9904              LDR      r1,[sp,#0x10]         ;821
0001f4  1c49              ADDS     r1,r1,#1              ;821
0001f6  9104              STR      r1,[sp,#0x10]         ;821
0001f8  9904              LDR      r1,[sp,#0x10]         ;822
0001fa  4551              CMP      r1,r10                ;822
0001fc  d001              BEQ      |L5.514|
0001fe  2800              CMP      r0,#0                 ;822
000200  d1f4              BNE      |L5.492|
                  |L5.514|
000202  b108              CBZ      r0,|L5.520|
000204  f04f0b00          MOV      r11,#0                ;826
                  |L5.520|
000208  9823              LDR      r0,[sp,#0x8c]         ;831
00020a  b3a8              CBZ      r0,|L5.632|
00020c  f44f3000          MOV      r0,#0x20000           ;834
000210  f7fffffe          BL       CRYP_PhaseConfig
000214  2001              MOVS     r0,#1                 ;837
000216  f7fffffe          BL       CRYP_Cmd
00021a  f7fffffe          BL       CRYP_GetCmdStatus
00021e  b110              CBZ      r0,|L5.550|
000220  f04f0a00          MOV      r10,#0                ;846
000224  e048              B        |L5.696|
                  |L5.550|
000226  2000              MOVS     r0,#0                 ;843
000228  e7b7              B        |L5.410|
                  |L5.554|
00022a  2001              MOVS     r0,#1                 ;849
00022c  f7fffffe          BL       CRYP_GetFlagStatus
000230  2800              CMP      r0,#0                 ;849
000232  d0fa              BEQ      |L5.554|
000234  6820              LDR      r0,[r4,#0]            ;853
000236  f7fffffe          BL       CRYP_DataIn
00023a  1d24              ADDS     r4,r4,#4              ;854
00023c  6820              LDR      r0,[r4,#0]            ;855
00023e  f7fffffe          BL       CRYP_DataIn
000242  1d24              ADDS     r4,r4,#4              ;856
000244  6820              LDR      r0,[r4,#0]            ;857
000246  f7fffffe          BL       CRYP_DataIn
00024a  1d24              ADDS     r4,r4,#4              ;858
00024c  6820              LDR      r0,[r4,#0]            ;859
00024e  f7fffffe          BL       CRYP_DataIn
000252  1d24              ADDS     r4,r4,#4              ;860
000254  2000              MOVS     r0,#0                 ;863
000256  9004              STR      r0,[sp,#0x10]         ;863
                  |L5.600|
000258  2010              MOVS     r0,#0x10              ;866
00025a  f7fffffe          BL       CRYP_GetFlagStatus
00025e  9904              LDR      r1,[sp,#0x10]         ;867
000260  1c49              ADDS     r1,r1,#1              ;867
000262  9104              STR      r1,[sp,#0x10]         ;867
000264  9904              LDR      r1,[sp,#0x10]         ;868
000266  f5b13f80          CMP      r1,#0x10000           ;868
00026a  d001              BEQ      |L5.624|
00026c  2800              CMP      r0,#0                 ;868
00026e  d1f3              BNE      |L5.600|
                  |L5.624|
000270  b118              CBZ      r0,|L5.634|
000272  f04f0b00          MOV      r11,#0                ;872
000276  e01d              B        |L5.692|
                  |L5.632|
000278  e024              B        |L5.708|
                  |L5.634|
00027a  2004              MOVS     r0,#4                 ;877
00027c  f7fffffe          BL       CRYP_GetFlagStatus
000280  2800              CMP      r0,#0                 ;877
000282  d0fa              BEQ      |L5.634|
000284  f7fffffe          BL       CRYP_DataOut
000288  f8c90000          STR      r0,[r9,#0]            ;882
00028c  f1090904          ADD      r9,r9,#4              ;883
000290  f7fffffe          BL       CRYP_DataOut
000294  f8c90000          STR      r0,[r9,#0]            ;884
000298  f1090904          ADD      r9,r9,#4              ;885
00029c  f7fffffe          BL       CRYP_DataOut
0002a0  f8c90000          STR      r0,[r9,#0]            ;886
0002a4  f1090904          ADD      r9,r9,#4              ;887
0002a8  f7fffffe          BL       CRYP_DataOut
0002ac  f8c90000          STR      r0,[r9,#0]            ;888
0002b0  f1090904          ADD      r9,r9,#4              ;889
                  |L5.692|
0002b4  f10a0a10          ADD      r10,r10,#0x10         ;846
                  |L5.696|
0002b8  9823              LDR      r0,[sp,#0x8c]         ;846
0002ba  4582              CMP      r10,r0                ;846
0002bc  d202              BCS      |L5.708|
0002be  f1bb0f00          CMP      r11,#0                ;846
0002c2  d1b2              BNE      |L5.554|
                  |L5.708|
0002c4  f44f3040          MOV      r0,#0x30000           ;896
0002c8  f7fffffe          BL       CRYP_PhaseConfig
0002cc  2001              MOVS     r0,#1                 ;899
0002ce  f7fffffe          BL       CRYP_Cmd
0002d2  f7fffffe          BL       CRYP_GetCmdStatus
0002d6  b1f8              CBZ      r0,|L5.792|
0002d8  ba30              REV      r0,r6                 ;909
0002da  f7fffffe          BL       CRYP_DataIn
0002de  ba28              REV      r0,r5                 ;910
0002e0  f7fffffe          BL       CRYP_DataIn
0002e4  fa98f088          REV      r0,r8                 ;911
0002e8  f7fffffe          BL       CRYP_DataIn
0002ec  ba38              REV      r0,r7                 ;912
0002ee  f7fffffe          BL       CRYP_DataIn
                  |L5.754|
0002f2  2004              MOVS     r0,#4                 ;914
0002f4  f7fffffe          BL       CRYP_GetFlagStatus
0002f8  2800              CMP      r0,#0                 ;914
0002fa  d0fa              BEQ      |L5.754|
0002fc  9c27              LDR      r4,[sp,#0x9c]         ;918
0002fe  f7fffffe          BL       CRYP_DataOut
000302  6020              STR      r0,[r4,#0]            ;920
000304  f7fffffe          BL       CRYP_DataOut
000308  6060              STR      r0,[r4,#4]            ;922
00030a  f7fffffe          BL       CRYP_DataOut
00030e  60a0              STR      r0,[r4,#8]            ;924
000310  f7fffffe          BL       CRYP_DataOut
000314  60e0              STR      r0,[r4,#0xc]          ;926
000316  e0ba              B        |L5.1166|
                  |L5.792|
000318  2000              MOVS     r0,#0                 ;905
00031a  e73e              B        |L5.410|
                  |L5.796|
00031c  2000              MOVS     r0,#0                 ;972
00031e  e73c              B        |L5.410|
                  |L5.800|
000320  2001              MOVS     r0,#1                 ;978
000322  f7fffffe          BL       CRYP_GetFlagStatus
000326  2800              CMP      r0,#0                 ;978
000328  d0fa              BEQ      |L5.800|
00032a  f8da0000          LDR      r0,[r10,#0]           ;983
00032e  f7fffffe          BL       CRYP_DataIn
000332  f8da0004          LDR      r0,[r10,#4]           ;985
000336  f7fffffe          BL       CRYP_DataIn
00033a  f8da0008          LDR      r0,[r10,#8]           ;987
00033e  f7fffffe          BL       CRYP_DataIn
000342  f85a0f0c          LDR      r0,[r10,#0xc]!        ;989
000346  f7fffffe          BL       CRYP_DataIn
00034a  f10a0a04          ADD      r10,r10,#4            ;990
00034e  9801              LDR      r0,[sp,#4]            ;975
000350  3010              ADDS     r0,r0,#0x10           ;975
000352  9001              STR      r0,[sp,#4]            ;975
                  |L5.852|
000354  9925              LDR      r1,[sp,#0x94]         ;975
000356  9801              LDR      r0,[sp,#4]            ;975
000358  4288              CMP      r0,r1                 ;975
00035a  d3e1              BCC      |L5.800|
00035c  2000              MOVS     r0,#0                 ;994
00035e  9004              STR      r0,[sp,#0x10]         ;994
000360  f44f3a80          MOV      r10,#0x10000          ;786
                  |L5.868|
000364  2010              MOVS     r0,#0x10              ;997
000366  f7fffffe          BL       CRYP_GetFlagStatus
00036a  9904              LDR      r1,[sp,#0x10]         ;998
00036c  1c49              ADDS     r1,r1,#1              ;998
00036e  9104              STR      r1,[sp,#0x10]         ;998
000370  9904              LDR      r1,[sp,#0x10]         ;999
000372  4551              CMP      r1,r10                ;999
000374  d001              BEQ      |L5.890|
000376  2800              CMP      r0,#0                 ;999
000378  d1f4              BNE      |L5.868|
                  |L5.890|
00037a  b108              CBZ      r0,|L5.896|
00037c  f04f0b00          MOV      r11,#0                ;1003
                  |L5.896|
000380  9823              LDR      r0,[sp,#0x8c]         ;1008
000382  b3a8              CBZ      r0,|L5.1008|
000384  f44f3000          MOV      r0,#0x20000           ;1011
000388  f7fffffe          BL       CRYP_PhaseConfig
00038c  2001              MOVS     r0,#1                 ;1014
00038e  f7fffffe          BL       CRYP_Cmd
000392  f7fffffe          BL       CRYP_GetCmdStatus
000396  b110              CBZ      r0,|L5.926|
000398  f04f0a00          MOV      r10,#0                ;1023
00039c  e048              B        |L5.1072|
                  |L5.926|
00039e  2000              MOVS     r0,#0                 ;1020
0003a0  e6fb              B        |L5.410|
                  |L5.930|
0003a2  2001              MOVS     r0,#1                 ;1026
0003a4  f7fffffe          BL       CRYP_GetFlagStatus
0003a8  2800              CMP      r0,#0                 ;1026
0003aa  d0fa              BEQ      |L5.930|
0003ac  6820              LDR      r0,[r4,#0]            ;1030
0003ae  f7fffffe          BL       CRYP_DataIn
0003b2  1d24              ADDS     r4,r4,#4              ;1031
0003b4  6820              LDR      r0,[r4,#0]            ;1032
0003b6  f7fffffe          BL       CRYP_DataIn
0003ba  1d24              ADDS     r4,r4,#4              ;1033
0003bc  6820              LDR      r0,[r4,#0]            ;1034
0003be  f7fffffe          BL       CRYP_DataIn
0003c2  1d24              ADDS     r4,r4,#4              ;1035
0003c4  6820              LDR      r0,[r4,#0]            ;1036
0003c6  f7fffffe          BL       CRYP_DataIn
0003ca  1d24              ADDS     r4,r4,#4              ;1037
0003cc  2000              MOVS     r0,#0                 ;1040
0003ce  9004              STR      r0,[sp,#0x10]         ;1040
                  |L5.976|
0003d0  2010              MOVS     r0,#0x10              ;1043
0003d2  f7fffffe          BL       CRYP_GetFlagStatus
0003d6  9904              LDR      r1,[sp,#0x10]         ;1044
0003d8  1c49              ADDS     r1,r1,#1              ;1044
0003da  9104              STR      r1,[sp,#0x10]         ;1044
0003dc  9904              LDR      r1,[sp,#0x10]         ;1045
0003de  f5b13f80          CMP      r1,#0x10000           ;1045
0003e2  d001              BEQ      |L5.1000|
0003e4  2800              CMP      r0,#0                 ;1045
0003e6  d1f3              BNE      |L5.976|
                  |L5.1000|
0003e8  b118              CBZ      r0,|L5.1010|
0003ea  f04f0b00          MOV      r11,#0                ;1049
0003ee  e01d              B        |L5.1068|
                  |L5.1008|
0003f0  e024              B        |L5.1084|
                  |L5.1010|
0003f2  2004              MOVS     r0,#4                 ;1054
0003f4  f7fffffe          BL       CRYP_GetFlagStatus
0003f8  2800              CMP      r0,#0                 ;1054
0003fa  d0fa              BEQ      |L5.1010|
0003fc  f7fffffe          BL       CRYP_DataOut
000400  f8c90000          STR      r0,[r9,#0]            ;1059
000404  f1090904          ADD      r9,r9,#4              ;1060
000408  f7fffffe          BL       CRYP_DataOut
00040c  f8c90000          STR      r0,[r9,#0]            ;1061
000410  f1090904          ADD      r9,r9,#4              ;1062
000414  f7fffffe          BL       CRYP_DataOut
000418  f8c90000          STR      r0,[r9,#0]            ;1063
00041c  f1090904          ADD      r9,r9,#4              ;1064
000420  f7fffffe          BL       CRYP_DataOut
000424  f8c90000          STR      r0,[r9,#0]            ;1065
000428  f1090904          ADD      r9,r9,#4              ;1066
                  |L5.1068|
00042c  f10a0a10          ADD      r10,r10,#0x10         ;1023
                  |L5.1072|
000430  9823              LDR      r0,[sp,#0x8c]         ;1023
000432  4582              CMP      r10,r0                ;1023
000434  d202              BCS      |L5.1084|
000436  f1bb0f00          CMP      r11,#0                ;1023
00043a  d1b2              BNE      |L5.930|
                  |L5.1084|
00043c  f44f3040          MOV      r0,#0x30000           ;1073
000440  f7fffffe          BL       CRYP_PhaseConfig
000444  2001              MOVS     r0,#1                 ;1076
000446  f7fffffe          BL       CRYP_Cmd
00044a  f7fffffe          BL       CRYP_GetCmdStatus
00044e  b318              CBZ      r0,|L5.1176|
000450  ba30              REV      r0,r6                 ;1086
000452  f7fffffe          BL       CRYP_DataIn
000456  ba28              REV      r0,r5                 ;1087
000458  f7fffffe          BL       CRYP_DataIn
00045c  fa98f088          REV      r0,r8                 ;1088
000460  f7fffffe          BL       CRYP_DataIn
000464  ba38              REV      r0,r7                 ;1089
000466  f7fffffe          BL       CRYP_DataIn
                  |L5.1130|
00046a  2004              MOVS     r0,#4                 ;1091
00046c  f7fffffe          BL       CRYP_GetFlagStatus
000470  2800              CMP      r0,#0                 ;1091
000472  d0fa              BEQ      |L5.1130|
000474  9c27              LDR      r4,[sp,#0x9c]         ;1095
000476  f7fffffe          BL       CRYP_DataOut
00047a  6020              STR      r0,[r4,#0]            ;1097
00047c  f7fffffe          BL       CRYP_DataOut
000480  6060              STR      r0,[r4,#4]            ;1099
000482  f7fffffe          BL       CRYP_DataOut
000486  60a0              STR      r0,[r4,#8]            ;1101
000488  f7fffffe          BL       CRYP_DataOut
00048c  60e0              STR      r0,[r4,#0xc]          ;1103
                  |L5.1166|
00048e  2000              MOVS     r0,#0                 ;1107
000490  f7fffffe          BL       CRYP_Cmd
000494  4658              MOV      r0,r11                ;1109
000496  e680              B        |L5.410|
                  |L5.1176|
000498  2000              MOVS     r0,#0                 ;1082
00049a  e67e              B        |L5.410|
;;;1111   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_cryp_aes.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH|
#line 144
|__asm___20_stm32f4xx_cryp_aes_c_c34cf6b8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
