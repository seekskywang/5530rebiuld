; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\stm32f4xx_hash_md5.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\stm32f4xx_hash_md5.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\stm32f4xx_hash_md5.crf ..\Libraries\FWlib\src\stm32f4xx_hash_md5.c]
                          THUMB

                          AREA ||i.HASH_MD5||, CODE, READONLY, ALIGN=1

                  HASH_MD5 PROC
;;;92       */
;;;93     ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;94     {
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4617              MOV      r7,r2
;;;95       HASH_InitTypeDef MD5_HASH_InitStructure;
;;;96       HASH_MsgDigest MD5_MessageDigest;
;;;97       __IO uint16_t nbvalidbitsdata = 0;
;;;98       uint32_t i = 0;
00000c  2500              MOVS     r5,#0
;;;99       __IO uint32_t counter = 0;
00000e  2600              MOVS     r6,#0
;;;100      uint32_t busystatus = 0;
;;;101      ErrorStatus status = SUCCESS;
000010  f04f0901          MOV      r9,#1
;;;102      uint32_t inputaddr  = (uint32_t)Input;
;;;103      uint32_t outputaddr = (uint32_t)Output;
;;;104    
;;;105    
;;;106      /* Number of valid bits in last word of the Input data */
;;;107      nbvalidbitsdata = 8 * (Ilen % 4);
000014  ea4f7088          LSL      r0,r8,#30
000018  ea4f6ad0          LSR      r10,r0,#27
;;;108    
;;;109      /* HASH peripheral initialization */
;;;110      HASH_DeInit();
00001c  f7fffffe          BL       HASH_DeInit
;;;111    
;;;112      /* HASH Configuration */
;;;113      MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
000020  2080              MOVS     r0,#0x80
000022  9008              STR      r0,[sp,#0x20]
;;;114      MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
000024  2000              MOVS     r0,#0
000026  9009              STR      r0,[sp,#0x24]
;;;115      MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000028  2020              MOVS     r0,#0x20
00002a  900a              STR      r0,[sp,#0x28]
;;;116      HASH_Init(&MD5_HASH_InitStructure);
00002c  a808              ADD      r0,sp,#0x20
00002e  f7fffffe          BL       HASH_Init
;;;117    
;;;118      /* Configure the number of valid bits in last word of the data */
;;;119      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000032  4650              MOV      r0,r10
000034  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;120    
;;;121      /* Write the Input block in the IN FIFO */
;;;122      for(i=0; i<Ilen; i+=4)
000038  e004              B        |L1.68|
                  |L1.58|
;;;123      {
;;;124        HASH_DataIn(*(uint32_t*)inputaddr);
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       HASH_DataIn
;;;125        inputaddr+=4;
000040  1d24              ADDS     r4,r4,#4
000042  1d2d              ADDS     r5,r5,#4              ;122
                  |L1.68|
000044  4545              CMP      r5,r8                 ;122
000046  d3f8              BCC      |L1.58|
;;;126      }
;;;127    
;;;128      /* Start the HASH processor */
;;;129      HASH_StartDigest();
000048  f7fffffe          BL       HASH_StartDigest
;;;130    
;;;131      /* wait until the Busy flag is RESET */
;;;132      do
;;;133      {
;;;134        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
;;;135        counter++;
;;;136      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
00004c  f44f3480          MOV      r4,#0x10000
                  |L1.80|
000050  2008              MOVS     r0,#8                 ;134
000052  f7fffffe          BL       HASH_GetFlagStatus
000056  1c76              ADDS     r6,r6,#1              ;135
000058  42a6              CMP      r6,r4
00005a  d001              BEQ      |L1.96|
00005c  2800              CMP      r0,#0
00005e  d1f7              BNE      |L1.80|
                  |L1.96|
;;;137    
;;;138      if (busystatus != RESET)
000060  b110              CBZ      r0,|L1.104|
;;;139      {
;;;140         status = ERROR;
000062  f04f0900          MOV      r9,#0
000066  e00e              B        |L1.134|
                  |L1.104|
;;;141      }
;;;142      else
;;;143      {
;;;144        /* Read the message digest */
;;;145        HASH_GetDigest(&MD5_MessageDigest);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       HASH_GetDigest
;;;146        *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
00006e  9800              LDR      r0,[sp,#0]
000070  ba00              REV      r0,r0
000072  6038              STR      r0,[r7,#0]
;;;147        outputaddr+=4;
;;;148        *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
000074  9801              LDR      r0,[sp,#4]
000076  ba00              REV      r0,r0
000078  6078              STR      r0,[r7,#4]
;;;149        outputaddr+=4;
;;;150        *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
00007a  9802              LDR      r0,[sp,#8]
00007c  ba00              REV      r0,r0
00007e  60b8              STR      r0,[r7,#8]
;;;151        outputaddr+=4;
;;;152        *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
000080  9803              LDR      r0,[sp,#0xc]
000082  ba00              REV      r0,r0
000084  60f8              STR      r0,[r7,#0xc]
                  |L1.134|
;;;153      }
;;;154      return status; 
;;;155    }
000086  b00c              ADD      sp,sp,#0x30
000088  4648              MOV      r0,r9                 ;154
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;156    
                          ENDP


                          AREA ||i.HMAC_MD5||, CODE, READONLY, ALIGN=1

                  HMAC_MD5 PROC
;;;167      */
;;;168    ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;169                         uint32_t Ilen, uint8_t Output[16])
;;;170    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4689              MOV      r9,r1
000008  f8ddb070          LDR      r11,[sp,#0x70]
00000c  4616              MOV      r6,r2
;;;171      HASH_InitTypeDef MD5_HASH_InitStructure;
;;;172      HASH_MsgDigest MD5_MessageDigest;
;;;173      __IO uint16_t nbvalidbitsdata = 0;
;;;174      __IO uint16_t nbvalidbitskey = 0;
;;;175      uint32_t i = 0;
00000e  2700              MOVS     r7,#0
;;;176      __IO uint32_t counter = 0;
000010  46b8              MOV      r8,r7
;;;177      uint32_t busystatus = 0;
;;;178      ErrorStatus status = SUCCESS;
000012  f04f0a01          MOV      r10,#1
;;;179      uint32_t keyaddr    = (uint32_t)Key;
000016  9d0f              LDR      r5,[sp,#0x3c]
;;;180      uint32_t inputaddr  = (uint32_t)Input;
;;;181      uint32_t outputaddr = (uint32_t)Output;
;;;182    
;;;183      /* Number of valid bits in last word of the Input data */
;;;184      nbvalidbitsdata = 8 * (Ilen % 4);
000018  9812              LDR      r0,[sp,#0x48]
00001a  0780              LSLS     r0,r0,#30
00001c  0ec0              LSRS     r0,r0,#27
00001e  9002              STR      r0,[sp,#8]
;;;185    
;;;186      /* Number of valid bits in last word of the Key */
;;;187      nbvalidbitskey = 8 * (Keylen % 4);
000020  ea4f7089          LSL      r0,r9,#30
000024  0ec0              LSRS     r0,r0,#27
000026  9001              STR      r0,[sp,#4]
;;;188       
;;;189      /* HASH peripheral initialization */
;;;190      HASH_DeInit();
000028  f7fffffe          BL       HASH_DeInit
;;;191    
;;;192      /* HASH Configuration */
;;;193      MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
00002c  2080              MOVS     r0,#0x80
00002e  900b              STR      r0,[sp,#0x2c]
;;;194      MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
000030  2040              MOVS     r0,#0x40
000032  900c              STR      r0,[sp,#0x30]
;;;195      MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000034  2020              MOVS     r0,#0x20
000036  900d              STR      r0,[sp,#0x34]
;;;196      if(Keylen > 64)
;;;197      {
;;;198        /* HMAC long Key */
;;;199        MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
000038  02c4              LSLS     r4,r0,#11
00003a  f1b90f40          CMP      r9,#0x40              ;196
00003e  d901              BLS      |L2.68|
000040  940e              STR      r4,[sp,#0x38]
000042  e001              B        |L2.72|
                  |L2.68|
;;;200      }
;;;201      else
;;;202      {
;;;203        /* HMAC short Key */
;;;204        MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000044  2000              MOVS     r0,#0
000046  900e              STR      r0,[sp,#0x38]
                  |L2.72|
;;;205      }
;;;206      HASH_Init(&MD5_HASH_InitStructure);
000048  a80b              ADD      r0,sp,#0x2c
00004a  f7fffffe          BL       HASH_Init
;;;207    
;;;208      /* Configure the number of valid bits in last word of the Key */
;;;209      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
00004e  9801              LDR      r0,[sp,#4]
000050  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;210    
;;;211      /* Write the Key */
;;;212      for(i=0; i<Keylen; i+=4)
000054  e004              B        |L2.96|
                  |L2.86|
;;;213      {
;;;214        HASH_DataIn(*(uint32_t*)keyaddr);
000056  6828              LDR      r0,[r5,#0]
000058  f7fffffe          BL       HASH_DataIn
;;;215        keyaddr+=4;
00005c  1d2d              ADDS     r5,r5,#4
00005e  1d3f              ADDS     r7,r7,#4              ;212
                  |L2.96|
000060  454f              CMP      r7,r9                 ;212
000062  d3f8              BCC      |L2.86|
;;;216      }
;;;217      
;;;218      /* Start the HASH processor */
;;;219      HASH_StartDigest();
000064  f7fffffe          BL       HASH_StartDigest
                  |L2.104|
;;;220    
;;;221      /* wait until the Busy flag is RESET */
;;;222      do
;;;223      {
;;;224        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000068  2008              MOVS     r0,#8
00006a  f7fffffe          BL       HASH_GetFlagStatus
;;;225        counter++;
00006e  f1080801          ADD      r8,r8,#1
;;;226      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
000072  45a0              CMP      r8,r4
000074  d001              BEQ      |L2.122|
000076  2800              CMP      r0,#0
000078  d1f6              BNE      |L2.104|
                  |L2.122|
;;;227    
;;;228      if (busystatus != RESET)
00007a  b110              CBZ      r0,|L2.130|
;;;229      {
;;;230         status = ERROR;
00007c  f04f0a00          MOV      r10,#0
000080  e04b              B        |L2.282|
                  |L2.130|
;;;231      }
;;;232      else
;;;233      {
;;;234        /* Configure the number of valid bits in last word of the Input data */
;;;235        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000082  9802              LDR      r0,[sp,#8]
000084  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;236    
;;;237        /* Write the Input block in the IN FIFO */
;;;238        for(i=0; i<Ilen; i+=4)
000088  2700              MOVS     r7,#0
00008a  e004              B        |L2.150|
                  |L2.140|
;;;239        {
;;;240          HASH_DataIn(*(uint32_t*)inputaddr);
00008c  6830              LDR      r0,[r6,#0]
00008e  f7fffffe          BL       HASH_DataIn
;;;241          inputaddr+=4;
000092  1d36              ADDS     r6,r6,#4
000094  1d3f              ADDS     r7,r7,#4              ;238
                  |L2.150|
000096  9812              LDR      r0,[sp,#0x48]         ;238
000098  4287              CMP      r7,r0                 ;238
00009a  d3f7              BCC      |L2.140|
;;;242        }
;;;243    
;;;244        /* Start the HASH processor */
;;;245        HASH_StartDigest();
00009c  f7fffffe          BL       HASH_StartDigest
;;;246    
;;;247        /* wait until the Busy flag is RESET */
;;;248        counter =0;
0000a0  2600              MOVS     r6,#0
                  |L2.162|
;;;249        do
;;;250        {
;;;251           busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000a2  2008              MOVS     r0,#8
0000a4  f7fffffe          BL       HASH_GetFlagStatus
;;;252           counter++;
0000a8  1c76              ADDS     r6,r6,#1
;;;253        }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
0000aa  4627              MOV      r7,r4
0000ac  42be              CMP      r6,r7
0000ae  d001              BEQ      |L2.180|
0000b0  2800              CMP      r0,#0
0000b2  d1f6              BNE      |L2.162|
                  |L2.180|
;;;254    
;;;255        if (busystatus != RESET)
0000b4  b110              CBZ      r0,|L2.188|
;;;256        {
;;;257          status = ERROR;
0000b6  f04f0a00          MOV      r10,#0
0000ba  e02e              B        |L2.282|
                  |L2.188|
;;;258        }
;;;259        else
;;;260        {  
;;;261          /* Configure the number of valid bits in last word of the Key */
;;;262          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0000bc  9801              LDR      r0,[sp,#4]
0000be  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;263    
;;;264          /* Write the Key */
;;;265          keyaddr = (uint32_t)Key;
0000c2  9c0f              LDR      r4,[sp,#0x3c]
;;;266          for(i=0; i<Keylen; i+=4)
0000c4  2500              MOVS     r5,#0
0000c6  e004              B        |L2.210|
                  |L2.200|
;;;267          {
;;;268            HASH_DataIn(*(uint32_t*)keyaddr);
0000c8  6820              LDR      r0,[r4,#0]
0000ca  f7fffffe          BL       HASH_DataIn
;;;269            keyaddr+=4;
0000ce  1d24              ADDS     r4,r4,#4
0000d0  1d2d              ADDS     r5,r5,#4              ;266
                  |L2.210|
0000d2  454d              CMP      r5,r9                 ;266
0000d4  d3f8              BCC      |L2.200|
;;;270          }
;;;271      
;;;272           /* Start the HASH processor */
;;;273           HASH_StartDigest();
0000d6  f7fffffe          BL       HASH_StartDigest
;;;274    
;;;275           /* wait until the Busy flag is RESET */
;;;276           counter =0;
0000da  2400              MOVS     r4,#0
                  |L2.220|
;;;277           do
;;;278           {
;;;279              busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000dc  2008              MOVS     r0,#8
0000de  f7fffffe          BL       HASH_GetFlagStatus
;;;280              counter++;
0000e2  1c64              ADDS     r4,r4,#1
;;;281          }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
0000e4  42bc              CMP      r4,r7
0000e6  d001              BEQ      |L2.236|
0000e8  2800              CMP      r0,#0
0000ea  d1f7              BNE      |L2.220|
                  |L2.236|
;;;282    
;;;283          if (busystatus != RESET)
0000ec  b110              CBZ      r0,|L2.244|
;;;284          {
;;;285             status = ERROR;
0000ee  f04f0a00          MOV      r10,#0
0000f2  e012              B        |L2.282|
                  |L2.244|
;;;286          }
;;;287          else
;;;288          {
;;;289             /* Read the message digest */
;;;290             HASH_GetDigest(&MD5_MessageDigest);
0000f4  a803              ADD      r0,sp,#0xc
0000f6  f7fffffe          BL       HASH_GetDigest
;;;291             *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
0000fa  9803              LDR      r0,[sp,#0xc]
0000fc  ba00              REV      r0,r0
0000fe  f8cb0000          STR      r0,[r11,#0]
;;;292             outputaddr+=4;
;;;293             *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
000102  9804              LDR      r0,[sp,#0x10]
000104  ba00              REV      r0,r0
000106  f8cb0004          STR      r0,[r11,#4]
;;;294             outputaddr+=4;
;;;295             *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
00010a  9805              LDR      r0,[sp,#0x14]
00010c  ba00              REV      r0,r0
00010e  f8cb0008          STR      r0,[r11,#8]
;;;296             outputaddr+=4;
;;;297             *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
000112  9806              LDR      r0,[sp,#0x18]
000114  ba00              REV      r0,r0
000116  f8cb000c          STR      r0,[r11,#0xc]
                  |L2.282|
;;;298          }
;;;299        }
;;;300      }
;;;301      return status;  
;;;302    }
00011a  b013              ADD      sp,sp,#0x4c
00011c  4650              MOV      r0,r10                ;301
00011e  e8bd8ff0          POP      {r4-r11,pc}
;;;303    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\FWlib\\src\\stm32f4xx_hash_md5.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___20_stm32f4xx_hash_md5_c_HASH_MD5____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_stm32f4xx_hash_md5_c_HASH_MD5____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___20_stm32f4xx_hash_md5_c_HASH_MD5____REVSH|
#line 128
|__asm___20_stm32f4xx_hash_md5_c_HASH_MD5____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
