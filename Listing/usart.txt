; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\usart.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\usart.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\usart.crf ..\drive\usart.c]
                          THUMB

                          AREA ||i.UART1_Send||, CODE, READONLY, ALIGN=2

                  UART1_Send PROC
;;;84     
;;;85     void UART1_Send(void)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
;;;87     	static vu8 UART_Buffer_Send_pointer=0;
;;;88     		if (UART_Buffer_Send_pointer < Transmit_BUFFERsize)
000002  4c11              LDR      r4,|L1.72|
000004  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Send_pointer
000006  7861              LDRB     r1,[r4,#1]  ; Transmit_BUFFERsize
000008  4288              CMP      r0,r1
00000a  d215              BCS      |L1.56|
;;;89              {
;;;90     					 if(UART_Buffer_Send[0]==ADDR)
00000c  480f              LDR      r0,|L1.76|
00000e  7801              LDRB     r1,[r0,#0]  ; UART_Buffer_Send
000010  4a0f              LDR      r2,|L1.80|
000012  7812              LDRB     r2,[r2,#0]  ; ADDR
000014  4291              CMP      r1,r2
000016  d10e              BNE      |L1.54|
;;;91     					 {
;;;92     						USART_SendData(USART1,UART_Buffer_Send[UART_Buffer_Send_pointer]);
000018  7821              LDRB     r1,[r4,#0]  ; UART_Buffer_Send_pointer
00001a  5c41              LDRB     r1,[r0,r1]
00001c  4d0d              LDR      r5,|L1.84|
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       USART_SendData
                  |L1.36|
;;;93     						while (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);//等待发送完成
000024  2180              MOVS     r1,#0x80
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USART_GetFlagStatus
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L1.36|
;;;94     						UART_Buffer_Send_pointer++;
000030  7820              LDRB     r0,[r4,#0]  ; UART_Buffer_Send_pointer
000032  1c40              ADDS     r0,r0,#1
000034  7020              STRB     r0,[r4,#0]
                  |L1.54|
;;;95     					}
;;;96              }
;;;97     		else 
;;;98     		{
;;;99     			UART_Buffer_Send_pointer=0;
;;;100    			UART_SEND_flag=0;//发送完成一帧数据
;;;101    		}
;;;102    }
000036  bd70              POP      {r4-r6,pc}
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;99
00003a  7020              STRB     r0,[r4,#0]            ;99
00003c  4806              LDR      r0,|L1.88|
00003e  6801              LDR      r1,[r0,#0]            ;100  ; flagA
000040  f0210110          BIC      r1,r1,#0x10           ;100
000044  6001              STR      r1,[r0,#0]            ;100  ; flagA
000046  bd70              POP      {r4-r6,pc}
;;;103    
                          ENDP

                  |L1.72|
                          DCD      ||.data||
                  |L1.76|
                          DCD      ||area_number.6||
                  |L1.80|
                          DCD      ADDR
                  |L1.84|
                          DCD      0x40011000
                  |L1.88|
                          DCD      flagA

                          AREA ||i.USART1_NVIC_Config||, CODE, READONLY, ALIGN=1

                  USART1_NVIC_Config PROC
;;;31     /*****************************************************************/
;;;32     static void USART1_NVIC_Config(void)//串口接收中断配置
000000  b508              PUSH     {r3,lr}
;;;33     {
;;;34     	NVIC_InitTypeDef NVIC_InitStructure; 
;;;35     	/* Configure the NVIC Preemption Priority Bits */  
;;;36     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;37     	
;;;38     	/* Enable the USARTy Interrupt */
;;;39     	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;	 
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;40     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;41     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000016  2001              MOVS     r0,#1
000018  f88d0002          STRB     r0,[sp,#2]
;;;42     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  f88d0003          STRB     r0,[sp,#3]
;;;43     	NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;44     }
000026  bd08              POP      {r3,pc}
;;;45     
                          ENDP


                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;45     
;;;46     void USART_Configuration(void)//串口初始化函数
000000  b570              PUSH     {r4-r6,lr}
;;;47     {  
000002  b086              SUB      sp,sp,#0x18
;;;48     	GPIO_InitTypeDef GPIO_InitStructure;
;;;49     	USART_InitTypeDef USART_InitStructure;
;;;50     	
;;;51     	/* config USART1 clock */
;;;52     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53     	GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_USART1);
00000c  4e22              LDR      r6,|L3.152|
00000e  2207              MOVS     r2,#7
000010  2109              MOVS     r1,#9
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GPIO_PinAFConfig
;;;54     	GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_USART1);
000018  2207              MOVS     r2,#7
00001a  210a              MOVS     r1,#0xa
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       GPIO_PinAFConfig
;;;55     	/* USART1 GPIO config */
;;;56     	/* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;57     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000022  1570              ASRS     r0,r6,#21
000024  9004              STR      r0,[sp,#0x10]
;;;58     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000026  2502              MOVS     r5,#2
000028  f88d5014          STRB     r5,[sp,#0x14]
;;;59     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002c  2400              MOVS     r4,#0
00002e  f88d4016          STRB     r4,[sp,#0x16]
;;;60     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000032  f88d5015          STRB     r5,[sp,#0x15]
;;;61     	GPIO_Init(GPIOA, &GPIO_InitStructure);    
000036  a904              ADD      r1,sp,#0x10
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       GPIO_Init
;;;62     	/* Configure USART1 Rx (PA.10) as input floating */
;;;63     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00003e  0269              LSLS     r1,r5,#9
000040  9104              STR      r1,[sp,#0x10]
;;;64     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000042  f88d5014          STRB     r5,[sp,#0x14]
;;;65     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000046  a904              ADD      r1,sp,#0x10
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       GPIO_Init
;;;66     	
;;;67     	/* USART1 mode config */
;;;68     	USART_InitStructure.USART_BaudRate = 19200;
00004e  f44f4096          MOV      r0,#0x4b00
000052  9000              STR      r0,[sp,#0]
;;;69     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000054  f8ad4004          STRH     r4,[sp,#4]
;;;70     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000058  f8ad4006          STRH     r4,[sp,#6]
;;;71     	USART_InitStructure.USART_Parity = USART_Parity_No ;
00005c  f8ad4008          STRH     r4,[sp,#8]
;;;72     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000060  f8ad400c          STRH     r4,[sp,#0xc]
;;;73     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000064  200c              MOVS     r0,#0xc
000066  f8ad000a          STRH     r0,[sp,#0xa]
;;;74     	USART_Init(USART1, &USART_InitStructure);
00006a  4c0c              LDR      r4,|L3.156|
00006c  4669              MOV      r1,sp
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       USART_Init
;;;75     	
;;;76     	/******使能串口接收中断******************/
;;;77     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	
000074  2201              MOVS     r2,#1
000076  f2405125          MOV      r1,#0x525
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       USART_ITConfig
;;;78     	USART_Cmd(USART1, ENABLE);//使能串口1
000080  2101              MOVS     r1,#1
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       USART_Cmd
;;;79       USART_ClearFlag(USART1, USART_FLAG_TC);
000088  2140              MOVS     r1,#0x40
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       USART_ClearFlag
;;;80       
;;;81       USART1_NVIC_Config();//串口中断配置
000090  f7fffffe          BL       USART1_NVIC_Config
;;;82     }			
000094  b006              ADD      sp,sp,#0x18
000096  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  |L3.152|
                          DCD      0x40020000
                  |L3.156|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART_Buffer_Rece
                          %        16

                          AREA ||area_number.6||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.bss||
                  UART_Buffer_Send
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  UART_Buffer_Send_pointer
000000  00                DCB      0x00
                  Transmit_BUFFERsize
000001  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.data||
                  UART_Buffer_Size
000000  00                DCB      0x00

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  t_USART
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\usart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_usart_c_3deb77c7____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_3deb77c7____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_usart_c_3deb77c7____REVSH|
#line 128
|__asm___7_usart_c_3deb77c7____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
