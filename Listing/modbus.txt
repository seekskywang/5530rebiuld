; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\modbus.crf ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;300    //-----------------------------CRC检测--------------------------------------------//
;;;301    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b530              PUSH     {r4,r5,lr}
;;;302    {
000002  4603              MOV      r3,r0
;;;303    	vu16 CRC_Result=0xffff;
000004  f64f70ff          MOV      r0,#0xffff
;;;304    	vu8 i;
;;;305    	if(count==0)
000008  b901              CBNZ     r1,|L1.12|
;;;306    	{
;;;307    		count=1;
00000a  2101              MOVS     r1,#1
                  |L1.12|
;;;308    	}
;;;309    	while(count--)
;;;310    	{
;;;311    		CRC_Result^=*p_buffer;
;;;312    		for(i=0;i<8;i++)
;;;313    		{
;;;314    			if(CRC_Result&1)
;;;315    			{
;;;316    				CRC_Result>>=1;
;;;317    				CRC_Result^=0xA001;
00000c  f24a0401          MOV      r4,#0xa001
;;;318    			}
;;;319    			else 
;;;320    			{
;;;321    				CRC_Result>>=1;
;;;322    			}
;;;323    		}
;;;324    		p_buffer++;
000010  e00e              B        |L1.48|
                  |L1.18|
000012  781a              LDRB     r2,[r3,#0]            ;311
000014  4050              EORS     r0,r0,r2              ;311
000016  2200              MOVS     r2,#0                 ;312
000018  e007              B        |L1.42|
                  |L1.26|
00001a  07c5              LSLS     r5,r0,#31             ;314
00001c  d002              BEQ      |L1.36|
00001e  0840              LSRS     r0,r0,#1              ;316
000020  4060              EORS     r0,r0,r4              ;317
000022  e000              B        |L1.38|
                  |L1.36|
000024  0840              LSRS     r0,r0,#1              ;321
                  |L1.38|
000026  1c52              ADDS     r2,r2,#1              ;312
000028  b2d2              UXTB     r2,r2                 ;312
                  |L1.42|
00002a  2a08              CMP      r2,#8                 ;312
00002c  d3f5              BCC      |L1.26|
00002e  1c5b              ADDS     r3,r3,#1
                  |L1.48|
000030  000a              MOVS     r2,r1                 ;309
000032  f1a10101          SUB      r1,r1,#1              ;309
000036  b2c9              UXTB     r1,r1                 ;309
000038  d1eb              BNE      |L1.18|
;;;325    	}
;;;326    	return CRC_Result;
;;;327    }
00003a  bd30              POP      {r4,r5,pc}
;;;328    
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;142    //===============================AD值转换成测量值============================================//
;;;143    void Transformation_ADC(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;144    {
;;;145    	vu32 var32;
;;;146    	vu32 var32a;
;;;147    /*****************************测量电压转换*******************************************/
;;;148    	var32 = Vmon_value;
000002  4874              LDR      r0,|L2.468|
000004  8800              LDRH     r0,[r0,#0]  ; Vmon_value
;;;149    	var32 = var32 * REG_CorrectionV;  
000006  4a74              LDR      r2,|L2.472|
000008  8811              LDRH     r1,[r2,#0]  ; Correct_Parametet
00000a  4341              MULS     r1,r0,r1
;;;150    	if ((Polar & 0x01) == 0x01)		  
00000c  8910              LDRH     r0,[r2,#8]  ; Correct_Parametet
00000e  07c3              LSLS     r3,r0,#31
;;;151    	{
;;;152    		if (var32 < REG_ReadV_Offset) 
000010  f102001c          ADD      r0,r2,#0x1c
000014  d007              BEQ      |L2.38|
000016  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000018  428b              CMP      r3,r1
00001a  d901              BLS      |L2.32|
;;;153    		{
;;;154    			var32 = 0;
00001c  2100              MOVS     r1,#0
00001e  e004              B        |L2.42|
                  |L2.32|
;;;155    		}
;;;156    		else var32 = var32 - REG_ReadV_Offset;
000020  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000022  1ac9              SUBS     r1,r1,r3
000024  e001              B        |L2.42|
                  |L2.38|
;;;157    	}
;;;158    	else var32 = var32 + REG_ReadV_Offset;
000026  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000028  4419              ADD      r1,r1,r3
                  |L2.42|
;;;159    	var32 = var32 >> 12;
00002a  0b09              LSRS     r1,r1,#12
;;;160    	if (var32 < 5) var32 = 0;				  //40mV以下清零
00002c  2905              CMP      r1,#5
00002e  d200              BCS      |L2.50|
000030  2100              MOVS     r1,#0
                  |L2.50|
;;;161    	Voltage = var32;
000032  4b69              LDR      r3,|L2.472|
000034  3340              ADDS     r3,r3,#0x40
000036  8299              STRH     r1,[r3,#0x14]
;;;162    	DISS_Voltage=Voltage;
000038  8a99              LDRH     r1,[r3,#0x14]  ; Run_Control
00003a  ee001a10          VMOV     s0,r1
00003e  4967              LDR      r1,|L2.476|
000040  eeb80a40          VCVT.F32.U32 s0,s0
;;;163    	DISS_Voltage=DISS_Voltage/100;//计算显示电压
000044  eddf0a66          VLDR     s1,|L2.480|
000048  ee801a20          VDIV.F32 s2,s0,s1
00004c  ed811a00          VSTR     s2,[r1,#0]
;;;164    	var32 = 0;
;;;165    /*****************************稳压电源测量电压转换*******************************************/
;;;166    	var32 = Vmon1_value;
000050  4964              LDR      r1,|L2.484|
000052  880c              LDRH     r4,[r1,#0]  ; Vmon1_value
;;;167    	var32 = var32 * REG_CorrectionV1;  
000054  8b11              LDRH     r1,[r2,#0x18]  ; Correct_Parametet
000056  4361              MULS     r1,r4,r1
;;;168    	if ((Polar3 & 0x01) == 0x01)		  
000058  8ad4              LDRH     r4,[r2,#0x16]  ; Correct_Parametet
00005a  07e4              LSLS     r4,r4,#31
00005c  d007              BEQ      |L2.110|
;;;169    	{
;;;170    		if (var32 < REG_ReadV1_Offset) 
00005e  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000060  428c              CMP      r4,r1
000062  d901              BLS      |L2.104|
;;;171    		{
;;;172    			var32 = 0;
000064  2100              MOVS     r1,#0
000066  e004              B        |L2.114|
                  |L2.104|
;;;173    		}
;;;174    		else var32 = var32 - REG_ReadV1_Offset;
000068  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
00006a  1b09              SUBS     r1,r1,r4
00006c  e001              B        |L2.114|
                  |L2.110|
;;;175    	}
;;;176    	else var32 = var32 + REG_ReadV1_Offset;
00006e  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000070  4421              ADD      r1,r1,r4
                  |L2.114|
;;;177    	var32 = var32 >> 14;
000072  0b89              LSRS     r1,r1,#14
;;;178    	if (var32 < 5) var32 = 0;				  //40mV以下清零
000074  2905              CMP      r1,#5
000076  d200              BCS      |L2.122|
000078  2100              MOVS     r1,#0
                  |L2.122|
;;;179    	POW_Voltage = var32;
00007a  8259              STRH     r1,[r3,#0x12]
;;;180    	DISS_POW_Voltage=POW_Voltage;
00007c  8a59              LDRH     r1,[r3,#0x12]  ; Run_Control
00007e  ee001a10          VMOV     s0,r1
000082  4959              LDR      r1,|L2.488|
000084  eeb80a40          VCVT.F32.U32 s0,s0
;;;181    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
000088  ee801a20          VDIV.F32 s2,s0,s1
00008c  ed811a00          VSTR     s2,[r1,#0]
;;;182    	var32 = 0;
;;;183    /*****************************内阻值转换*******************************************/
;;;184    	var32 = Rmon_value;
000090  4956              LDR      r1,|L2.492|
000092  8809              LDRH     r1,[r1,#0]  ; Rmon_value
;;;185    	var32 = var32 * 5844;  
000094  f24164d4          MOV      r4,#0x16d4
000098  4361              MULS     r1,r4,r1
;;;186    // 	if ((Polar1 & 0x04) == 0x04)		  
;;;187    // 	{
;;;188    		if (var32 < 28571) 
00009a  f646749b          MOV      r4,#0x6f9b
00009e  42a1              CMP      r1,r4
0000a0  d201              BCS      |L2.166|
;;;189    		{
;;;190    			var32 = 0;
0000a2  2100              MOVS     r1,#0
0000a4  e002              B        |L2.172|
                  |L2.166|
;;;191    		}
;;;192    		else {
;;;193                var32 = var32 - 28571;
0000a6  f5a141de          SUB      r1,r1,#0x6f00
0000aa  399b              SUBS     r1,r1,#0x9b
                  |L2.172|
;;;194            }
;;;195    // 	}
;;;196    // 	else var32 = var32 + REG_ReadR_Offset;
;;;197    // 	var32 = var32 >> 12;
;;;198    	if (var32 < 5) var32 = 0;				  //40mV以下清零
0000ac  2905              CMP      r1,#5
0000ae  d200              BCS      |L2.178|
0000b0  2100              MOVS     r1,#0
                  |L2.178|
;;;199    	R_VLUE = var32/10000;
0000b2  f2427410          MOV      r4,#0x2710
0000b6  fbb1f1f4          UDIV     r1,r1,r4
0000ba  8359              STRH     r1,[r3,#0x1a]
;;;200    	var32 = 0;	
;;;201    /*****************************稳压电源测量电流转换*******************************************/
;;;202    	var32 = Imon_value;
0000bc  494c              LDR      r1,|L2.496|
0000be  880c              LDRH     r4,[r1,#0]  ; Imon_value
;;;203    	var32 = var32 * CON_CorrectionA;	   
0000c0  8a11              LDRH     r1,[r2,#0x10]  ; Correct_Parametet
0000c2  4361              MULS     r1,r4,r1
;;;204    	if ((Polar2 & 0x01) == 0x01)			   
0000c4  8a94              LDRH     r4,[r2,#0x14]  ; Correct_Parametet
0000c6  07e4              LSLS     r4,r4,#31
0000c8  d007              BEQ      |L2.218|
;;;205    	{
;;;206    		if (var32 < CON_ReadA_Offset) var32 = 0;
0000ca  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000cc  428c              CMP      r4,r1
0000ce  d901              BLS      |L2.212|
0000d0  2100              MOVS     r1,#0
0000d2  e004              B        |L2.222|
                  |L2.212|
;;;207    		else var32 = var32 - CON_ReadA_Offset;
0000d4  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000d6  1b09              SUBS     r1,r1,r4
0000d8  e001              B        |L2.222|
                  |L2.218|
;;;208    	}
;;;209    	else
;;;210    	{
;;;211    		var32 = var32 + CON_ReadA_Offset;
0000da  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000dc  4421              ADD      r1,r1,r4
                  |L2.222|
;;;212    	}	
;;;213    	var32 = var32 >> 12;
0000de  0b09              LSRS     r1,r1,#12
;;;214    	Current = var32;;
0000e0  82d9              STRH     r1,[r3,#0x16]
;;;215    	DISS_POW_Current=Current;
0000e2  8ad9              LDRH     r1,[r3,#0x16]  ; Run_Control
0000e4  ee001a10          VMOV     s0,r1
0000e8  4942              LDR      r1,|L2.500|
0000ea  eeb80a40          VCVT.F32.U32 s0,s0
;;;216    	DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0000ee  ed9f1a42          VLDR     s2,|L2.504|
0000f2  eec01a01          VDIV.F32 s3,s0,s2
0000f6  edc11a00          VSTR     s3,[r1,#0]
;;;217    /**************************稳压电源设置电压转换******************************************/
;;;218    	var32 = SET_Voltage;
0000fa  8859              LDRH     r1,[r3,#2]  ; Run_Control
;;;219    	var32=var32<<14;   
0000fc  0389              LSLS     r1,r1,#14
;;;220    	if ((Polar1 & 0x01) == 0)			   
0000fe  8a54              LDRH     r4,[r2,#0x12]  ; Correct_Parametet
000100  07e4              LSLS     r4,r4,#31
000102  d00b              BEQ      |L2.284|
;;;221    	{
;;;222    		if (var32 < SET_ReadV_Offset) var32 = 0;
;;;223    		else var32 = var32 - SET_ReadV_Offset;
;;;224    	}
;;;225    	else var32 = var32 + SET_ReadV_Offset;
000104  6904              LDR      r4,[r0,#0x10]  ; Correct_Strong
000106  4421              ADD      r1,r1,r4
                  |L2.264|
;;;226    	var32 = var32/SET_CorrectionV;
000108  8954              LDRH     r4,[r2,#0xa]  ; Correct_Parametet
00010a  fbb1f1f4          UDIV     r1,r1,r4
;;;227    	var32=var32>>1;
00010e  0849              LSRS     r1,r1,#1
;;;228    	Contr_Voltage = var32;
000110  4d3a              LDR      r5,|L2.508|
000112  8029              STRH     r1,[r5,#0]
;;;229    	if(SET_Voltage==0)
000114  8859              LDRH     r1,[r3,#2]  ; Run_Control
000116  2400              MOVS     r4,#0                 ;154
000118  b141              CBZ      r1,|L2.300|
00011a  e008              B        |L2.302|
                  |L2.284|
00011c  6904              LDR      r4,[r0,#0x10]         ;222  ; Correct_Strong
00011e  428c              CMP      r4,r1                 ;222
000120  d901              BLS      |L2.294|
000122  2100              MOVS     r1,#0                 ;222
000124  e7f0              B        |L2.264|
                  |L2.294|
000126  6904              LDR      r4,[r0,#0x10]         ;223  ; Correct_Strong
000128  1b09              SUBS     r1,r1,r4              ;223
00012a  e7ed              B        |L2.264|
                  |L2.300|
;;;230    	{
;;;231    		Contr_Voltage=0;
00012c  802c              STRH     r4,[r5,#0]
                  |L2.302|
;;;232    	}
;;;233    	var32 = 0;
;;;234    /**************************稳压电源设置电流转换**************************************/
;;;235    	var32 = SET_Current;
00012e  8899              LDRH     r1,[r3,#4]  ; Run_Control
;;;236    	var32=var32<<14;   
000130  0389              LSLS     r1,r1,#14
;;;237    	if ((Polar1 & 0x08) == 0)			   
000132  8a55              LDRH     r5,[r2,#0x12]  ; Correct_Parametet
000134  072d              LSLS     r5,r5,#28
000136  d407              BMI      |L2.328|
;;;238    	{
;;;239    		if (var32 < SET_ReadA_Offset) var32 = 0;
000138  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
00013a  428d              CMP      r5,r1
00013c  d901              BLS      |L2.322|
00013e  2100              MOVS     r1,#0
000140  e004              B        |L2.332|
                  |L2.322|
;;;240    		else var32 = var32 - SET_ReadA_Offset;
000142  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
000144  1b49              SUBS     r1,r1,r5
000146  e001              B        |L2.332|
                  |L2.328|
;;;241    	}
;;;242    	else var32 = var32 + SET_ReadA_Offset;
000148  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
00014a  4429              ADD      r1,r1,r5
                  |L2.332|
;;;243    	var32 = var32/SET_CorrectionA;
00014c  8995              LDRH     r5,[r2,#0xc]  ; Correct_Parametet
00014e  fbb1f1f5          UDIV     r1,r1,r5
;;;244    	var32=var32>>1;
000152  0849              LSRS     r1,r1,#1
;;;245    	Contr_Current = var32;
000154  4d2a              LDR      r5,|L2.512|
000156  8029              STRH     r1,[r5,#0]
;;;246    	if(SET_Current==0)
000158  8899              LDRH     r1,[r3,#4]  ; Run_Control
00015a  b901              CBNZ     r1,|L2.350|
;;;247    	{
;;;248    		Contr_Current=0;
00015c  802c              STRH     r4,[r5,#0]
                  |L2.350|
;;;249    	}
;;;250    	
;;;251    	var32 = 0;
;;;252    
;;;253    /*************************负载电流控制转换**************************************/
;;;254    	var32 = SET_Current_Laod;
00015e  8919              LDRH     r1,[r3,#8]  ; Run_Control
;;;255    	var32=var32<<12;   
000160  0309              LSLS     r1,r1,#12
;;;256    	if ((Polar2 & 0x08) == 0)			   
000162  8a95              LDRH     r5,[r2,#0x14]  ; Correct_Parametet
000164  072d              LSLS     r5,r5,#28
000166  d407              BMI      |L2.376|
;;;257    	{
;;;258    		if (var32 < SET_ReadA1_Offset) var32 = 0;
000168  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
00016a  428d              CMP      r5,r1
00016c  d901              BLS      |L2.370|
00016e  2100              MOVS     r1,#0
000170  e004              B        |L2.380|
                  |L2.370|
;;;259    		else var32 = var32 - SET_ReadA1_Offset;
000172  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
000174  1b49              SUBS     r1,r1,r5
000176  e001              B        |L2.380|
                  |L2.376|
;;;260    	}
;;;261    	else var32 = var32 + SET_ReadA1_Offset;
000178  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
00017a  4429              ADD      r1,r1,r5
                  |L2.380|
;;;262    	var32 = var32/SET_CorrectionA1;
00017c  89d5              LDRH     r5,[r2,#0xe]  ; Correct_Parametet
00017e  fbb1f1f5          UDIV     r1,r1,r5
;;;263    	var32=var32>>1;
000182  0849              LSRS     r1,r1,#1
;;;264    	if(Flag_DAC_OFF==0)
000184  4d1f              LDR      r5,|L2.516|
000186  682d              LDR      r5,[r5,#0]  ; flagB
000188  072e              LSLS     r6,r5,#28
;;;265    	{
;;;266    		Contr_Laod = var32;
00018a  4d1f              LDR      r5,|L2.520|
00018c  d400              BMI      |L2.400|
00018e  8029              STRH     r1,[r5,#0]
                  |L2.400|
;;;267    	}
;;;268    	if(SET_Current_Laod==0)
000190  8919              LDRH     r1,[r3,#8]  ; Run_Control
000192  b901              CBNZ     r1,|L2.406|
;;;269    	{
;;;270    		Contr_Laod=0;
000194  802c              STRH     r4,[r5,#0]
                  |L2.406|
;;;271    	}
;;;272    	
;;;273    	var32 = 0;
;;;274    /*******************负载测量电流转换**************************************/
;;;275    	var32 = Imon1_value;
000196  491d              LDR      r1,|L2.524|
000198  880c              LDRH     r4,[r1,#0]  ; Imon1_value
;;;276    	var32 = var32 * REG_CorrectionA1;  
00019a  8891              LDRH     r1,[r2,#4]  ; Correct_Parametet
00019c  4361              MULS     r1,r4,r1
;;;277    	if ((Polar2 & 0x04) == 0x04)		  
00019e  8a92              LDRH     r2,[r2,#0x14]  ; Correct_Parametet
0001a0  0752              LSLS     r2,r2,#29
0001a2  d507              BPL      |L2.436|
;;;278    	{
;;;279    		if (var32 < REG_ReadA1_Offset) 
0001a4  6882              LDR      r2,[r0,#8]  ; Correct_Strong
0001a6  428a              CMP      r2,r1
0001a8  d901              BLS      |L2.430|
;;;280    		{
;;;281    			var32 = 0;
0001aa  2000              MOVS     r0,#0
0001ac  e004              B        |L2.440|
                  |L2.430|
;;;282    		}
;;;283    		else var32 = var32 - REG_ReadA1_Offset;
0001ae  6880              LDR      r0,[r0,#8]  ; Correct_Strong
0001b0  1a08              SUBS     r0,r1,r0
0001b2  e001              B        |L2.440|
                  |L2.436|
;;;284    	}
;;;285    	else var32 = var32 + REG_ReadA1_Offset;
0001b4  6880              LDR      r0,[r0,#8]  ; Correct_Strong
0001b6  4408              ADD      r0,r0,r1
                  |L2.440|
;;;286    	var32 = var32 >> 12;
0001b8  0b00              LSRS     r0,r0,#12
;;;287    	Laod_Current = var32;
0001ba  8318              STRH     r0,[r3,#0x18]
;;;288    	DISS_Current=Laod_Current;
0001bc  8b18              LDRH     r0,[r3,#0x18]  ; Run_Control
0001be  ee000a10          VMOV     s0,r0
0001c2  4813              LDR      r0,|L2.528|
0001c4  eeb80a40          VCVT.F32.U32 s0,s0
;;;289    	DISS_Current=DISS_Current/100;//计算显示电流
0001c8  ee801a20          VDIV.F32 s2,s0,s1
0001cc  ed801a00          VSTR     s2,[r0,#0]
;;;290    	var32 = 0;		
;;;291    	
;;;292    }
0001d0  bd70              POP      {r4-r6,pc}
;;;293    /********************************************************************************
                          ENDP

0001d2  0000              DCW      0x0000
                  |L2.468|
                          DCD      Vmon_value
                  |L2.472|
                          DCD      ||.bss||
                  |L2.476|
                          DCD      DISS_Voltage
                  |L2.480|
0001e0  42c80000          DCFS     0x42c80000 ; 100
                  |L2.484|
                          DCD      Vmon1_value
                  |L2.488|
                          DCD      DISS_POW_Voltage
                  |L2.492|
                          DCD      Rmon_value
                  |L2.496|
                          DCD      Imon_value
                  |L2.500|
                          DCD      DISS_POW_Current
                  |L2.504|
0001f8  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.508|
                          DCD      Contr_Voltage
                  |L2.512|
                          DCD      Contr_Current
                  |L2.516|
                          DCD      flagB
                  |L2.520|
                          DCD      Contr_Laod
                  |L2.524|
                          DCD      Imon1_value
                  |L2.528|
                          DCD      DISS_Current

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;43     //===========================MODBUS协议=============================//
;;;44     void UART_Action(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;45     {//RUT格式：
;;;46     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;47     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;48     	if (UART_Buffer_Rece[0] == ADDR)
000004  4e70              LDR      r6,|L3.456|
000006  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
000008  4c70              LDR      r4,|L3.460|
00000a  7821              LDRB     r1,[r4,#0]  ; ADDR
;;;49     	{
;;;50     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;51     		{																		 
;;;52     			vu8 i;
;;;53     			vu16 crc_result;
;;;54     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;55     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;56     			{
;;;57     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;58     				{
;;;59     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;60     					{							
;;;61     						UART_Buffer_Send[0] = ADDR;
00000c  4f70              LDR      r7,|L3.464|
;;;62     						UART_Buffer_Send[1] = 0x03;
;;;63     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;64     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;65     						{
;;;66     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;67     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;68     						}
;;;69     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;70     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;71     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;72     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
00000e  f8dfa1c4          LDR      r10,|L3.468|
;;;73     						UART_SEND_flag=1;
000012  f8df81c4          LDR      r8,|L3.472|
000016  f8df91c4          LDR      r9,|L3.476|
00001a  4288              CMP      r0,r1                 ;48
00001c  d145              BNE      |L3.170|
00001e  7870              LDRB     r0,[r6,#1]            ;50  ; UART_Buffer_Rece
000020  2803              CMP      r0,#3                 ;50
000022  d142              BNE      |L3.170|
000024  79f0              LDRB     r0,[r6,#7]            ;54  ; UART_Buffer_Rece
000026  79b1              LDRB     r1,[r6,#6]            ;54  ; UART_Buffer_Rece
000028  eb002001          ADD      r0,r0,r1,LSL #8       ;54
00002c  b285              UXTH     r5,r0                 ;54
00002e  2106              MOVS     r1,#6                 ;55
000030  4630              MOV      r0,r6                 ;55
000032  f7fffffe          BL       Hardware_CRC
000036  42a8              CMP      r0,r5                 ;55
000038  d000              BEQ      |L3.60|
00003a  bbb5              CBNZ     r5,|L3.170|
                  |L3.60|
00003c  78f0              LDRB     r0,[r6,#3]            ;57  ; UART_Buffer_Rece
00003e  2807              CMP      r0,#7                 ;57
000040  d233              BCS      |L3.170|
000042  78f0              LDRB     r0,[r6,#3]            ;59  ; UART_Buffer_Rece
000044  7971              LDRB     r1,[r6,#5]            ;59  ; UART_Buffer_Rece
000046  4408              ADD      r0,r0,r1              ;59
000048  280f              CMP      r0,#0xf               ;59
00004a  d22e              BCS      |L3.170|
00004c  7820              LDRB     r0,[r4,#0]            ;61  ; ADDR
00004e  7038              STRB     r0,[r7,#0]            ;61
000050  2003              MOVS     r0,#3                 ;62
000052  7078              STRB     r0,[r7,#1]            ;62
000054  7970              LDRB     r0,[r6,#5]            ;63  ; UART_Buffer_Rece
000056  0040              LSLS     r0,r0,#1              ;63
000058  70b8              STRB     r0,[r7,#2]            ;63
00005a  2000              MOVS     r0,#0                 ;64
00005c  e00a              B        |L3.116|
                  |L3.94|
00005e  07c1              LSLS     r1,r0,#31             ;66
000060  d03a              BEQ      |L3.216|
000062  78f1              LDRB     r1,[r6,#3]            ;67  ; UART_Buffer_Rece
000064  eb010150          ADD      r1,r1,r0,LSR #1       ;67
000068  f8391011          LDRH     r1,[r9,r1,LSL #1]     ;67
00006c  183a              ADDS     r2,r7,r0              ;67
00006e  70d1              STRB     r1,[r2,#3]            ;67
                  |L3.112|
000070  1c40              ADDS     r0,r0,#1              ;64
000072  b2c0              UXTB     r0,r0                 ;64
                  |L3.116|
000074  78b9              LDRB     r1,[r7,#2]            ;64  ; UART_Buffer_Send
000076  4281              CMP      r1,r0                 ;64
000078  d8f1              BHI      |L3.94|
00007a  78b8              LDRB     r0,[r7,#2]            ;69  ; UART_Buffer_Send
00007c  1cc0              ADDS     r0,r0,#3              ;69
00007e  b2c1              UXTB     r1,r0                 ;69
000080  4853              LDR      r0,|L3.464|
000082  f7fffffe          BL       Hardware_CRC
000086  78bb              LDRB     r3,[r7,#2]            ;70  ; UART_Buffer_Send
000088  0a02              LSRS     r2,r0,#8              ;70
00008a  4951              LDR      r1,|L3.464|
00008c  1cc9              ADDS     r1,r1,#3              ;70
00008e  545a              STRB     r2,[r3,r1]            ;70
000090  78ba              LDRB     r2,[r7,#2]            ;71  ; UART_Buffer_Send
000092  1c49              ADDS     r1,r1,#1              ;71
000094  5450              STRB     r0,[r2,r1]            ;71
000096  78b8              LDRB     r0,[r7,#2]            ;72  ; UART_Buffer_Send
000098  1d40              ADDS     r0,r0,#5              ;72
00009a  f88a0000          STRB     r0,[r10,#0]           ;72
00009e  f8d80000          LDR      r0,[r8,#0]  ; flagA
0000a2  f0400010          ORR      r0,r0,#0x10
0000a6  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.170|
;;;74     					}
;;;75     				}
;;;76     			}	
;;;77     		}
;;;78     	} 
;;;79     //===============================写寄存器=================================
;;;80     	if ((UART_Buffer_Rece[0] == 0) || (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000aa  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
0000ac  b170              CBZ      r0,|L3.204|
0000ae  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
0000b0  7821              LDRB     r1,[r4,#0]  ; ADDR
0000b2  4288              CMP      r0,r1
0000b4  d00a              BEQ      |L3.204|
0000b6  7820              LDRB     r0,[r4,#0]  ; ADDR
0000b8  1e40              SUBS     r0,r0,#1
0000ba  17c1              ASRS     r1,r0,#31
0000bc  eb007091          ADD      r0,r0,r1,LSR #30
0000c0  2164              MOVS     r1,#0x64
0000c2  eb0100a0          ADD      r0,r1,r0,ASR #2
0000c6  7831              LDRB     r1,[r6,#0]  ; UART_Buffer_Rece
0000c8  4288              CMP      r0,r1
0000ca  d17b              BNE      |L3.452|
                  |L3.204|
;;;81     	{
;;;82     		vu8 var8;
;;;83     		vu8 a=0;
;;;84     		vu16 var16;
;;;85     		vu16 crc_result;
;;;86     //=========================以下命令6 写单个寄存器===========================
;;;87     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
0000cc  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
;;;88     		{
;;;89     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;90     			{
;;;91     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;92     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;93     				{
;;;94     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;95     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;96     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;97     
;;;98     					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;99     					{
;;;100    						for (a=0;a<8;a++)
;;;101    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;102    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
0000ce  f04f0b08          MOV      r11,#8
0000d2  2806              CMP      r0,#6                 ;87
0000d4  d009              BEQ      |L3.234|
0000d6  e032              B        |L3.318|
                  |L3.216|
0000d8  78f1              LDRB     r1,[r6,#3]            ;66  ; UART_Buffer_Rece
0000da  eb010150          ADD      r1,r1,r0,LSR #1       ;66
0000de  f8391011          LDRH     r1,[r9,r1,LSL #1]     ;66
0000e2  0a09              LSRS     r1,r1,#8              ;66
0000e4  183a              ADDS     r2,r7,r0              ;66
0000e6  70d1              STRB     r1,[r2,#3]            ;66
0000e8  e7c2              B        |L3.112|
                  |L3.234|
0000ea  78f0              LDRB     r0,[r6,#3]            ;89  ; UART_Buffer_Rece
0000ec  2805              CMP      r0,#5                 ;89
0000ee  d226              BCS      |L3.318|
0000f0  79f0              LDRB     r0,[r6,#7]            ;91  ; UART_Buffer_Rece
0000f2  79b1              LDRB     r1,[r6,#6]            ;91  ; UART_Buffer_Rece
0000f4  eb002001          ADD      r0,r0,r1,LSL #8       ;91
0000f8  b285              UXTH     r5,r0                 ;91
0000fa  2106              MOVS     r1,#6                 ;92
0000fc  4832              LDR      r0,|L3.456|
0000fe  f7fffffe          BL       Hardware_CRC
000102  42a8              CMP      r0,r5                 ;92
000104  d000              BEQ      |L3.264|
000106  b9d5              CBNZ     r5,|L3.318|
                  |L3.264|
000108  7970              LDRB     r0,[r6,#5]            ;94  ; UART_Buffer_Rece
00010a  7931              LDRB     r1,[r6,#4]            ;94  ; UART_Buffer_Rece
00010c  eb002001          ADD      r0,r0,r1,LSL #8       ;94
000110  78f1              LDRB     r1,[r6,#3]            ;95  ; UART_Buffer_Rece
000112  f8290011          STRH     r0,[r9,r1,LSL #1]     ;96
000116  7830              LDRB     r0,[r6,#0]            ;98  ; UART_Buffer_Rece
000118  7821              LDRB     r1,[r4,#0]            ;98  ; ADDR
00011a  4288              CMP      r0,r1                 ;98
00011c  d10f              BNE      |L3.318|
00011e  2000              MOVS     r0,#0                 ;100
000120  e003              B        |L3.298|
                  |L3.290|
000122  5c31              LDRB     r1,[r6,r0]            ;101
000124  5439              STRB     r1,[r7,r0]            ;101
000126  1c40              ADDS     r0,r0,#1              ;100
000128  b2c0              UXTB     r0,r0                 ;100
                  |L3.298|
00012a  2808              CMP      r0,#8                 ;100
00012c  d3f9              BCC      |L3.290|
00012e  f88ab000          STRB     r11,[r10,#0]
;;;103    						UART_SEND_flag=1;
000132  f8d80000          LDR      r0,[r8,#0]  ; flagA
000136  f0400010          ORR      r0,r0,#0x10
00013a  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.318|
;;;104    					}
;;;105    				}
;;;106    			}
;;;107    		}
;;;108    //=======================================以下是命令16，连写寄存器===========================================
;;;109    //功能码16格式:
;;;110    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;111    //返回数据格式:
;;;112    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;113    		if (UART_Buffer_Rece[1] == 16)										  
00013e  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
000140  2810              CMP      r0,#0x10
000142  d13f              BNE      |L3.452|
;;;114    		{	
;;;115    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
000144  79b0              LDRB     r0,[r6,#6]  ; UART_Buffer_Rece
000146  2806              CMP      r0,#6
000148  d13c              BNE      |L3.452|
00014a  78f0              LDRB     r0,[r6,#3]  ; UART_Buffer_Rece
00014c  2800              CMP      r0,#0
00014e  d139              BNE      |L3.452|
;;;116    			{
;;;117    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
000150  7bb0              LDRB     r0,[r6,#0xe]  ; UART_Buffer_Rece
000152  7b71              LDRB     r1,[r6,#0xd]  ; UART_Buffer_Rece
000154  eb002001          ADD      r0,r0,r1,LSL #8
000158  b285              UXTH     r5,r0
;;;118    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
00015a  210d              MOVS     r1,#0xd
00015c  481a              LDR      r0,|L3.456|
00015e  f7fffffe          BL       Hardware_CRC
000162  42a8              CMP      r0,r5
000164  d001              BEQ      |L3.362|
000166  2d00              CMP      r5,#0
000168  d12c              BNE      |L3.452|
                  |L3.362|
;;;119    				{												
;;;120    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
00016a  2000              MOVS     r0,#0
00016c  e009              B        |L3.386|
                  |L3.366|
00016e  eb060140          ADD      r1,r6,r0,LSL #1
000172  7a0a              LDRB     r2,[r1,#8]
000174  79c9              LDRB     r1,[r1,#7]
000176  eb022101          ADD      r1,r2,r1,LSL #8
00017a  f8291010          STRH     r1,[r9,r0,LSL #1]
00017e  1c40              ADDS     r0,r0,#1
000180  b2c0              UXTB     r0,r0
                  |L3.386|
000182  2803              CMP      r0,#3
000184  d3f3              BCC      |L3.366|
;;;121    
;;;122    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000186  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
000188  7821              LDRB     r1,[r4,#0]  ; ADDR
00018a  4288              CMP      r0,r1
00018c  d11a              BNE      |L3.452|
;;;123    					{
;;;124    						UART_Buffer_Send[0] = ADDR;
00018e  7820              LDRB     r0,[r4,#0]  ; ADDR
000190  7038              STRB     r0,[r7,#0]
;;;125    						UART_Buffer_Send[1] = 16;
000192  2010              MOVS     r0,#0x10
000194  7078              STRB     r0,[r7,#1]
;;;126    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000196  78b0              LDRB     r0,[r6,#2]  ; UART_Buffer_Rece
000198  70b8              STRB     r0,[r7,#2]
;;;127    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
00019a  78f0              LDRB     r0,[r6,#3]  ; UART_Buffer_Rece
00019c  70f8              STRB     r0,[r7,#3]
;;;128    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
00019e  7930              LDRB     r0,[r6,#4]  ; UART_Buffer_Rece
0001a0  7138              STRB     r0,[r7,#4]
;;;129    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
0001a2  7970              LDRB     r0,[r6,#5]  ; UART_Buffer_Rece
0001a4  7178              STRB     r0,[r7,#5]
;;;130    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
0001a6  2106              MOVS     r1,#6
0001a8  4809              LDR      r0,|L3.464|
0001aa  f7fffffe          BL       Hardware_CRC
;;;131    						UART_Buffer_Send[6] = crc_result>>8;
0001ae  0a01              LSRS     r1,r0,#8
0001b0  71b9              STRB     r1,[r7,#6]
;;;132    						UART_Buffer_Send[7] = crc_result;				 
0001b2  71f8              STRB     r0,[r7,#7]
;;;133    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
0001b4  f88ab000          STRB     r11,[r10,#0]
;;;134    						UART_SEND_flag=1;
0001b8  f8d80000          LDR      r0,[r8,#0]  ; flagA
0001bc  f0400010          ORR      r0,r0,#0x10
0001c0  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.452|
;;;135    					}
;;;136    				}
;;;137    			}			 
;;;138    		}
;;;139    	}
;;;140    //===================================================================================
;;;141    }
0001c4  e8bd8ff0          POP      {r4-r11,pc}
;;;142    //===============================AD值转换成测量值============================================//
                          ENDP

                  |L3.456|
                          DCD      UART_Buffer_Rece
                  |L3.460|
                          DCD      ||area_number.15||
                  |L3.464|
                          DCD      UART_Buffer_Send
                  |L3.468|
                          DCD      Transmit_BUFFERsize
                  |L3.472|
                          DCD      flagA
                  |L3.476|
                          DCD      ||.bss||+0x40

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        28
                  Correct_Strong
                          %        36
                  Run_Control
                          %        86

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.data||
                  Modify_A_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.10||, DATA, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.data||
                  Modify_C_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.11||, DATA, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.data||
                  Modify_A_ACT
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.12||, DATA, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.data||
                  Modify_B_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.13||, DATA, ALIGN=1

                          EXPORTAS ||area_number.13||, ||.data||
                  Modify_D_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  Modify_B_ACT
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.15||, DATA, ALIGN=0

                          EXPORTAS ||area_number.15||, ||.data||
                  ADDR
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 128
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
