; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=9931,870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=525 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\modbus.crf --no_multibyte_chars ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;731    //-----------------------------CRC检测--------------------------------------------//
;;;732    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b503              PUSH     {r0,r1,lr}
;;;733    {
000002  b082              SUB      sp,sp,#8
;;;734    	vu16 CRC_Result=0xffff;
000004  f64f71ff          MOV      r1,#0xffff
000008  9101              STR      r1,[sp,#4]
;;;735    	vu8 i;
;;;736    	if(count==0)
00000a  f89d100c          LDRB     r1,[sp,#0xc]
00000e  2900              CMP      r1,#0
000010  d126              BNE      |L1.96|
;;;737    	{
;;;738    		count=1;
000012  2101              MOVS     r1,#1
000014  9103              STR      r1,[sp,#0xc]
000016  e023              B        |L1.96|
                  |L1.24|
;;;739    	}
;;;740    	while(count--)
;;;741    	{
;;;742    		CRC_Result^=*p_buffer;
000018  7801              LDRB     r1,[r0,#0]
00001a  f8bd2004          LDRH     r2,[sp,#4]
00001e  4051              EORS     r1,r1,r2
000020  9101              STR      r1,[sp,#4]
;;;743    		for(i=0;i<8;i++)
000022  2100              MOVS     r1,#0
000024  9100              STR      r1,[sp,#0]
;;;744    		{
;;;745    			if(CRC_Result&1)
;;;746    			{
;;;747    				CRC_Result>>=1;
;;;748    				CRC_Result^=0xA001;
000026  f24a0201          MOV      r2,#0xa001
00002a  e014              B        |L1.86|
                  |L1.44|
00002c  f8bd1004          LDRH     r1,[sp,#4]            ;745
000030  07c9              LSLS     r1,r1,#31             ;745
000032  d008              BEQ      |L1.70|
000034  f8bd1004          LDRH     r1,[sp,#4]            ;747
000038  0849              LSRS     r1,r1,#1              ;747
00003a  9101              STR      r1,[sp,#4]            ;747
00003c  f8bd1004          LDRH     r1,[sp,#4]
000040  4051              EORS     r1,r1,r2
000042  9101              STR      r1,[sp,#4]
000044  e003              B        |L1.78|
                  |L1.70|
;;;749    			}
;;;750    			else 
;;;751    			{
;;;752    				CRC_Result>>=1;
000046  f8bd1004          LDRH     r1,[sp,#4]
00004a  0849              LSRS     r1,r1,#1
00004c  9101              STR      r1,[sp,#4]
                  |L1.78|
00004e  f89d1000          LDRB     r1,[sp,#0]            ;743
000052  1c49              ADDS     r1,r1,#1              ;743
000054  9100              STR      r1,[sp,#0]            ;743
                  |L1.86|
000056  f89d1000          LDRB     r1,[sp,#0]            ;743
00005a  2908              CMP      r1,#8                 ;743
00005c  d3e6              BCC      |L1.44|
;;;753    			}
;;;754    		}
;;;755    		p_buffer++;
00005e  1c40              ADDS     r0,r0,#1
                  |L1.96|
000060  f89d100c          LDRB     r1,[sp,#0xc]          ;740
000064  1e4a              SUBS     r2,r1,#1              ;740
000066  9203              STR      r2,[sp,#0xc]          ;740
000068  d2d6              BCS      |L1.24|
;;;756    	}
;;;757    	return CRC_Result;
00006a  f8bd0004          LDRH     r0,[sp,#4]
;;;758    }
00006e  b004              ADD      sp,sp,#0x10
000070  bd00              POP      {pc}
;;;759    
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;501    //===============================AD值转换成测量值============================================//
;;;502    void Transformation_ADC(void)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;503    {
000004  ed2d8b02          VPUSH    {d8}
000008  b082              SUB      sp,sp,#8
;;;504    	vu32 var32;
;;;505    	vu32 var32a;
;;;506    	float temp;
;;;507    /*****************************测量电压转换*******************************************/
;;;508    	var32 = Vmon_value;
00000a  48bf              LDR      r0,|L2.776|
00000c  8800              LDRH     r0,[r0,#0]  ; Vmon_value
00000e  9001              STR      r0,[sp,#4]
;;;509    	var32 = var32 * REG_CorrectionV;  
000010  4fbe              LDR      r7,|L2.780|
000012  8838              LDRH     r0,[r7,#0]  ; Correct_Parametet
000014  9901              LDR      r1,[sp,#4]
000016  4348              MULS     r0,r1,r0
000018  9001              STR      r0,[sp,#4]
;;;510    	if ((Polar & 0x01) == 0x01)		  
00001a  8938              LDRH     r0,[r7,#8]  ; Correct_Parametet
;;;511    	{
;;;512    		if (var32 < REG_ReadV_Offset) 
00001c  f107041c          ADD      r4,r7,#0x1c
000020  07c0              LSLS     r0,r0,#31             ;510
000022  f04f0500          MOV      r5,#0
000026  d00a              BEQ      |L2.62|
000028  6820              LDR      r0,[r4,#0]  ; Correct_Strong
00002a  9901              LDR      r1,[sp,#4]
00002c  4288              CMP      r0,r1
00002e  d901              BLS      |L2.52|
;;;513    		{
;;;514    			var32 = 0;
000030  9501              STR      r5,[sp,#4]
000032  e008              B        |L2.70|
                  |L2.52|
;;;515    		}
;;;516    		else var32 = var32 - REG_ReadV_Offset;
000034  6820              LDR      r0,[r4,#0]  ; Correct_Strong
000036  9901              LDR      r1,[sp,#4]
000038  1a08              SUBS     r0,r1,r0
00003a  9001              STR      r0,[sp,#4]
00003c  e003              B        |L2.70|
                  |L2.62|
;;;517    	}
;;;518    	else var32 = var32 + REG_ReadV_Offset;
00003e  6821              LDR      r1,[r4,#0]  ; Correct_Strong
000040  9801              LDR      r0,[sp,#4]
000042  4408              ADD      r0,r0,r1
000044  9001              STR      r0,[sp,#4]
                  |L2.70|
;;;519    	var32 = var32 >> 12;
000046  9801              LDR      r0,[sp,#4]
000048  0b00              LSRS     r0,r0,#12
00004a  9001              STR      r0,[sp,#4]
;;;520    	if (var32 < 5) var32 = 0;				  //40mV以下清零
00004c  9801              LDR      r0,[sp,#4]
00004e  2805              CMP      r0,#5
000050  d200              BCS      |L2.84|
000052  9501              STR      r5,[sp,#4]
                  |L2.84|
;;;521    	Voltage = var32;
000054  4ead              LDR      r6,|L2.780|
000056  9801              LDR      r0,[sp,#4]
000058  3644              ADDS     r6,r6,#0x44
00005a  82b0              STRH     r0,[r6,#0x14]
;;;522    	DISS_Voltage=Voltage;
00005c  8ab0              LDRH     r0,[r6,#0x14]  ; Run_Control
00005e  f8df82b0          LDR      r8,|L2.784|
000062  ee000a10          VMOV     s0,r0
000066  eef80a40          VCVT.F32.U32 s1,s0
;;;523    	DISS_Voltage=DISS_Voltage/100;//计算显示电压
00006a  ed9f8aaa          VLDR     s16,|L2.788|
00006e  ee800a88          VDIV.F32 s0,s1,s16
000072  ed880a00          VSTR     s0,[r8,#0]
;;;524    	if(DISS_Voltage < 10)
000076  ee100a10          VMOV     r0,s0
00007a  49a7              LDR      r1,|L2.792|
00007c  4288              CMP      r0,r1
00007e  da0e              BGE      |L2.158|
;;;525    	{
;;;526    		DISS_Voltage +=0.04;
000080  ee100a10          VMOV     r0,s0
000084  f7fffffe          BL       __aeabi_f2d
000088  ed9f1ba4          VLDR     d1,|L2.796|
00008c  ec532b11          VMOV     r2,r3,d1
000090  f7fffffe          BL       __aeabi_dadd
000094  f7fffffe          BL       __aeabi_d2f
000098  f8c80000          STR      r0,[r8,#0]  ; DISS_Voltage
00009c  e015              B        |L2.202|
                  |L2.158|
;;;527    	}else if(DISS_Voltage >= 10 && DISS_Voltage < 22){
00009e  ee100a10          VMOV     r0,s0
0000a2  499d              LDR      r1,|L2.792|
0000a4  4249              RSBS     r1,r1,#0
0000a6  4408              ADD      r0,r0,r1
0000a8  f5b00f10          CMP      r0,#0x900000
0000ac  d20d              BCS      |L2.202|
;;;528    		DISS_Voltage +=0.02;
0000ae  ee100a10          VMOV     r0,s0
0000b2  f7fffffe          BL       __aeabi_f2d
0000b6  ed9f1b9b          VLDR     d1,|L2.804|
0000ba  ec532b11          VMOV     r2,r3,d1
0000be  f7fffffe          BL       __aeabi_dadd
0000c2  f7fffffe          BL       __aeabi_d2f
0000c6  f8c80000          STR      r0,[r8,#0]  ; DISS_Voltage
                  |L2.202|
;;;529    	}
;;;530    	var32 = 0;
;;;531    /*****************************稳压电源测量电压转换*******************************************/
;;;532    	var32 = Vmon1_value;
0000ca  4898              LDR      r0,|L2.812|
0000cc  8800              LDRH     r0,[r0,#0]  ; Vmon1_value
0000ce  9001              STR      r0,[sp,#4]
;;;533    	var32 = var32 * REG_CorrectionV1;  
0000d0  8b38              LDRH     r0,[r7,#0x18]  ; Correct_Parametet
0000d2  9901              LDR      r1,[sp,#4]
0000d4  4348              MULS     r0,r1,r0
0000d6  9001              STR      r0,[sp,#4]
;;;534    //	if ((Polar2 & 0x01) == 0x01)		  
;;;535    //	{
;;;536    //		if (var32 < REG_ReadV1_Offset) 
;;;537    //		{
;;;538    //			var32 = 0;
;;;539    //		}
;;;540    //		else var32 = var32 + REG_ReadV1_Offset;
;;;541    //	}
;;;542    //	else 
;;;543    		var32 = var32 - REG_ReadV1_Offset;
0000d8  6a20              LDR      r0,[r4,#0x20]  ; Correct_Strong
0000da  9901              LDR      r1,[sp,#4]
0000dc  1a08              SUBS     r0,r1,r0
0000de  9001              STR      r0,[sp,#4]
;;;544    //	temp = temp * 0.8191;  
;;;545    //	temp = temp - 5.2066;
;;;546    	var32 = var32 >> 14;
0000e0  9801              LDR      r0,[sp,#4]
0000e2  0b80              LSRS     r0,r0,#14
0000e4  9001              STR      r0,[sp,#4]
;;;547    	if (temp < 5) temp = 0;				  //40mV以下清零
0000e6  eddf0a92          VLDR     s1,|L2.816|
;;;548    	POW_Voltage = var32;
0000ea  9801              LDR      r0,[sp,#4]
0000ec  8270              STRH     r0,[r6,#0x12]
;;;549    //	if(POW_Voltage >= 1600)
;;;550    //	{
;;;551    //		DISS_POW_Voltage=POW_Voltage - (vu16)((float)SET_Voltage*0.359);
;;;552    //	}else if(POW_Voltage >= 300 && POW_Voltage < 1600){
;;;553    //		DISS_POW_Voltage=POW_Voltage - (vu16)((float)SET_Voltage*0.359);
;;;554    //	}else{
;;;555    //		DISS_POW_Voltage=POW_Voltage - (vu16)((float)SET_Voltage*0.36);
;;;556    //	}
;;;557    	DISS_POW_Voltage=POW_Voltage;
0000ee  8a70              LDRH     r0,[r6,#0x12]  ; Run_Control
0000f0  ee000a10          VMOV     s0,r0
0000f4  488f              LDR      r0,|L2.820|
0000f6  eeb80a40          VCVT.F32.U32 s0,s0
0000fa  ed800a00          VSTR     s0,[r0,#0]
;;;558    	if(DISS_POW_Voltage < 0)
0000fe  eeb50ac0          VCMPE.F32 s0,#0.0
000102  eef1fa10          VMRS     APSR_nzcv,FPSCR
000106  d201              BCS      |L2.268|
;;;559    	{
;;;560    		DISS_POW_Voltage = 0;
000108  edc00a00          VSTR     s1,[r0,#0]
                  |L2.268|
;;;561    	}
;;;562    	if(DISS_POW_Voltage > SET_Voltage - 50 && DISS_POW_Voltage < SET_Voltage + 50)
00010c  8871              LDRH     r1,[r6,#2]  ; Run_Control
00010e  3932              SUBS     r1,r1,#0x32
000110  ee001a10          VMOV     s0,r1
000114  eeb81ac0          VCVT.F32.S32 s2,s0
000118  ed900a00          VLDR     s0,[r0,#0]
00011c  eeb41ac0          VCMPE.F32 s2,s0
000120  eef1fa10          VMRS     APSR_nzcv,FPSCR
000124  d211              BCS      |L2.330|
000126  8871              LDRH     r1,[r6,#2]  ; Run_Control
000128  3132              ADDS     r1,r1,#0x32
00012a  ee011a10          VMOV     s2,r1
00012e  eeb81a41          VCVT.F32.U32 s2,s2
000132  eeb41ac0          VCMPE.F32 s2,s0
000136  eef1fa10          VMRS     APSR_nzcv,FPSCR
00013a  dd06              BLE      |L2.330|
;;;563    	{
;;;564    		DISS_POW_Voltage = SET_Voltage;
00013c  8871              LDRH     r1,[r6,#2]  ; Run_Control
00013e  ee001a10          VMOV     s0,r1
000142  eeb80a40          VCVT.F32.U32 s0,s0
000146  ed800a00          VSTR     s0,[r0,#0]
                  |L2.330|
;;;565    	}
;;;566    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
00014a  ed900a00          VLDR     s0,[r0,#0]
00014e  ee801a08          VDIV.F32 s2,s0,s16
000152  ed801a00          VSTR     s2,[r0,#0]
;;;567    	var32 = 0;
;;;568    /*****************************内阻值转换*******************************************/
;;;569    // 	var32 = Rmon_value;
;;;570    // 	var32 = var32 * 6040;  
;;;571    // // 	if ((Polar1 & 0x04) == 0x04)		  
;;;572    // // 	{
;;;573    // 		if (var32 < 38926) 
;;;574    // 		{
;;;575    // 			var32 = 0;
;;;576    // 		}
;;;577    // 		else {
;;;578    //             var32 = var32 - 38926;
;;;579    //         }
;;;580    // // 	}
;;;581    // // 	else var32 = var32 + REG_ReadR_Offset;
;;;582    // // 	var32 = var32 >> 12;
;;;583    // 	if (var32 < 5) var32 = 0;				  //40mV以下清零
;;;584    // 	R_VLUE = var32/10000;
;;;585    // 	var32 = 0;	
;;;586        var32 = Rmon_value;
000156  4878              LDR      r0,|L2.824|
000158  8801              LDRH     r1,[r0,#0]  ; Rmon_value
00015a  9101              STR      r1,[sp,#4]
;;;587    	var32 = var32 * REG_CorrectionR;  
00015c  88f9              LDRH     r1,[r7,#6]  ; Correct_Parametet
00015e  9a01              LDR      r2,[sp,#4]
000160  4351              MULS     r1,r2,r1
000162  9101              STR      r1,[sp,#4]
;;;588    //	if ((Polar1 & 0x04) == 0x04)		  
;;;589    //	{
;;;590    //		if (var32 < REG_ReadR_Offset) 
;;;591    //		{
;;;592    //			var32 = 0;
;;;593    //		}
;;;594    //		else var32 = var32 - REG_ReadR_Offset;
;;;595    //	}
;;;596    //	else 
;;;597    		var32 = var32 - REG_ReadR_Offset;
000164  68e1              LDR      r1,[r4,#0xc]  ; Correct_Strong
000166  9a01              LDR      r2,[sp,#4]
000168  1a51              SUBS     r1,r2,r1
00016a  9101              STR      r1,[sp,#4]
;;;598    	var32 = var32 >> 12;
00016c  9901              LDR      r1,[sp,#4]
00016e  0b09              LSRS     r1,r1,#12
000170  9101              STR      r1,[sp,#4]
;;;599    	if (var32 < 5) var32 = 0;				  //40mV以下清零
000172  9901              LDR      r1,[sp,#4]
000174  2905              CMP      r1,#5
000176  d200              BCS      |L2.378|
000178  9501              STR      r5,[sp,#4]
                  |L2.378|
;;;600    	R_VLUE = var32;
00017a  9901              LDR      r1,[sp,#4]
00017c  8371              STRH     r1,[r6,#0x1a]
;;;601        if(R_VLUE > 100)
00017e  8b71              LDRH     r1,[r6,#0x1a]  ; Run_Control
000180  2964              CMP      r1,#0x64
000182  d912              BLS      |L2.426|
;;;602        {
;;;603            var32 = Rmon_value;
000184  8800              LDRH     r0,[r0,#0]  ; Rmon_value
000186  9001              STR      r0,[sp,#4]
;;;604            var32 = var32 * REG_CorrectionRH;  
000188  8b78              LDRH     r0,[r7,#0x1a]  ; Correct_Parametet
00018a  9901              LDR      r1,[sp,#4]
00018c  4348              MULS     r0,r1,r0
00018e  9001              STR      r0,[sp,#4]
;;;605    //        if ((Polar1 & 0x04) == 0x04)		  
;;;606    //        {
;;;607    //            if (var32 < REG_ReadRH_Offset) 
;;;608    //            {
;;;609    //                var32 = 0;
;;;610    //            }
;;;611    //            else var32 = var32 - REG_ReadRH_Offset;
;;;612    //        }
;;;613    //        else 
;;;614    			var32 = var32 - REG_ReadRH_Offset;
000190  6a60              LDR      r0,[r4,#0x24]  ; Correct_Strong
000192  9901              LDR      r1,[sp,#4]
000194  1a08              SUBS     r0,r1,r0
000196  9001              STR      r0,[sp,#4]
;;;615            var32 = var32 >> 12;
000198  9801              LDR      r0,[sp,#4]
00019a  0b00              LSRS     r0,r0,#12
00019c  9001              STR      r0,[sp,#4]
;;;616            if (var32 < 5) var32 = 0;				  //40mV去拢
00019e  9801              LDR      r0,[sp,#4]
0001a0  2805              CMP      r0,#5
0001a2  d200              BCS      |L2.422|
0001a4  9501              STR      r5,[sp,#4]
                  |L2.422|
;;;617            R_VLUE = var32;
0001a6  9801              LDR      r0,[sp,#4]
0001a8  8370              STRH     r0,[r6,#0x1a]
                  |L2.426|
;;;618        }
;;;619    	var32 = 0;	
;;;620        
;;;621    /*****************************稳压电源测量电流转换*******************************************/
;;;622    	var32 = Imon_value;
0001aa  4864              LDR      r0,|L2.828|
0001ac  8800              LDRH     r0,[r0,#0]  ; Imon_value
0001ae  9001              STR      r0,[sp,#4]
;;;623    	var32 = var32 * CON_CorrectionA;	   
0001b0  8a38              LDRH     r0,[r7,#0x10]  ; Correct_Parametet
0001b2  9901              LDR      r1,[sp,#4]
0001b4  4348              MULS     r0,r1,r0
0001b6  9001              STR      r0,[sp,#4]
;;;624    //	if ((Polar2 & 0x01) == 0x01)			   
;;;625    //	{
;;;626    //		if (var32 < CON_ReadA_Offset) var32 = 0;
;;;627    //		else var32 = var32 - CON_ReadA_Offset;
;;;628    //	}
;;;629    //	else
;;;630    //	{
;;;631    //		var32 = var32 + CON_ReadA_Offset;
;;;632    //	}	
;;;633    	var32 = var32 - CON_ReadA_Offset;
0001b8  69e0              LDR      r0,[r4,#0x1c]  ; Correct_Strong
0001ba  9901              LDR      r1,[sp,#4]
0001bc  1a08              SUBS     r0,r1,r0
0001be  9001              STR      r0,[sp,#4]
;;;634    	var32 = var32 >> 12;
0001c0  9801              LDR      r0,[sp,#4]
0001c2  0b00              LSRS     r0,r0,#12
0001c4  9001              STR      r0,[sp,#4]
;;;635    	Current = var32;;
0001c6  9801              LDR      r0,[sp,#4]
0001c8  82f0              STRH     r0,[r6,#0x16]
;;;636    	DISS_POW_Current=Current;
0001ca  8af0              LDRH     r0,[r6,#0x16]  ; Run_Control
0001cc  ee000a10          VMOV     s0,r0
0001d0  485b              LDR      r0,|L2.832|
0001d2  eeb81a40          VCVT.F32.U32 s2,s0
;;;637    	DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0001d6  eddf1a5b          VLDR     s3,|L2.836|
0001da  ee810a21          VDIV.F32 s0,s2,s3
0001de  ed800a00          VSTR     s0,[r0,#0]
;;;638    	if(DISS_POW_Current > 6)
0001e2  ee101a10          VMOV     r1,s0
0001e6  4a58              LDR      r2,|L2.840|
0001e8  4291              CMP      r1,r2
0001ea  dd01              BLE      |L2.496|
;;;639    	{
;;;640    		DISS_POW_Current = 0;
0001ec  edc00a00          VSTR     s1,[r0,#0]
                  |L2.496|
;;;641    	}
;;;642    /**************************稳压电源设置电压转换******************************************/
;;;643    	var32 = SET_Voltage;
0001f0  8870              LDRH     r0,[r6,#2]  ; Run_Control
0001f2  9001              STR      r0,[sp,#4]
;;;644    	var32=var32<<14;   
0001f4  9801              LDR      r0,[sp,#4]
0001f6  0380              LSLS     r0,r0,#14
0001f8  9001              STR      r0,[sp,#4]
;;;645    //	if ((Polar1 & 0x01) == 0)			   
;;;646    //	{
;;;647    //		if (var32 < SET_ReadV_Offset) var32 = 0;
;;;648    //		else var32 = var32 - SET_ReadV_Offset;
;;;649    //	}
;;;650    //	else 
;;;651    		var32 = var32 + SET_ReadV_Offset;
0001fa  6920              LDR      r0,[r4,#0x10]  ; Correct_Strong
0001fc  9901              LDR      r1,[sp,#4]
0001fe  4408              ADD      r0,r0,r1
000200  9001              STR      r0,[sp,#4]
;;;652    	var32 = var32/SET_CorrectionV;
000202  8978              LDRH     r0,[r7,#0xa]  ; Correct_Parametet
000204  9901              LDR      r1,[sp,#4]
000206  fbb1f0f0          UDIV     r0,r1,r0
00020a  9001              STR      r0,[sp,#4]
;;;653    	var32=var32>>1;
00020c  9801              LDR      r0,[sp,#4]
00020e  0840              LSRS     r0,r0,#1
000210  9001              STR      r0,[sp,#4]
;;;654    	Contr_Voltage = var32;
000212  484e              LDR      r0,|L2.844|
000214  9901              LDR      r1,[sp,#4]
000216  8001              STRH     r1,[r0,#0]
;;;655    	if(SET_Voltage==0)
000218  8871              LDRH     r1,[r6,#2]  ; Run_Control
00021a  b901              CBNZ     r1,|L2.542|
;;;656    	{
;;;657    		Contr_Voltage=0;
00021c  8005              STRH     r5,[r0,#0]
                  |L2.542|
;;;658    	}
;;;659    	var32 = 0;
;;;660    /**************************稳压电源设置电流转换**************************************/
;;;661    	var32 = SET_Current;
00021e  88b0              LDRH     r0,[r6,#4]  ; Run_Control
000220  9001              STR      r0,[sp,#4]
;;;662    	var32=var32<<14;   
000222  9801              LDR      r0,[sp,#4]
000224  0380              LSLS     r0,r0,#14
000226  9001              STR      r0,[sp,#4]
;;;663    	if ((Polar1 & 0x08) == 0)			   
000228  8a78              LDRH     r0,[r7,#0x12]  ; Correct_Parametet
00022a  0700              LSLS     r0,r0,#28
00022c  d40a              BMI      |L2.580|
;;;664    	{
;;;665    		if (var32 < SET_ReadA_Offset) var32 = 0;
00022e  6960              LDR      r0,[r4,#0x14]  ; Correct_Strong
000230  9901              LDR      r1,[sp,#4]
000232  4288              CMP      r0,r1
000234  d901              BLS      |L2.570|
000236  9501              STR      r5,[sp,#4]
000238  e008              B        |L2.588|
                  |L2.570|
;;;666    		else var32 = var32 - SET_ReadA_Offset;
00023a  6960              LDR      r0,[r4,#0x14]  ; Correct_Strong
00023c  9901              LDR      r1,[sp,#4]
00023e  1a08              SUBS     r0,r1,r0
000240  9001              STR      r0,[sp,#4]
000242  e003              B        |L2.588|
                  |L2.580|
;;;667    	}
;;;668    	else var32 = var32 + SET_ReadA_Offset;
000244  6960              LDR      r0,[r4,#0x14]  ; Correct_Strong
000246  9901              LDR      r1,[sp,#4]
000248  4408              ADD      r0,r0,r1
00024a  9001              STR      r0,[sp,#4]
                  |L2.588|
;;;669    	var32 = var32/SET_CorrectionA;
00024c  89b8              LDRH     r0,[r7,#0xc]  ; Correct_Parametet
00024e  9901              LDR      r1,[sp,#4]
000250  fbb1f0f0          UDIV     r0,r1,r0
000254  9001              STR      r0,[sp,#4]
;;;670    	var32=var32>>1;
000256  9801              LDR      r0,[sp,#4]
000258  0840              LSRS     r0,r0,#1
00025a  9001              STR      r0,[sp,#4]
;;;671    	Contr_Current = var32;
00025c  493c              LDR      r1,|L2.848|
00025e  9801              LDR      r0,[sp,#4]
000260  8008              STRH     r0,[r1,#0]
;;;672    	if(SET_Current==0)
000262  88b0              LDRH     r0,[r6,#4]  ; Run_Control
000264  b900              CBNZ     r0,|L2.616|
;;;673    	{
;;;674    		Contr_Current=0;
000266  800d              STRH     r5,[r1,#0]
                  |L2.616|
;;;675    	}
;;;676    	
;;;677    	var32 = 0;
;;;678    
;;;679    /*************************负载电流控制转换**************************************/
;;;680    	var32 = SET_Current_Laod;
000268  8930              LDRH     r0,[r6,#8]  ; Run_Control
00026a  9001              STR      r0,[sp,#4]
;;;681    	var32=var32<<12;   
00026c  9801              LDR      r0,[sp,#4]
00026e  0300              LSLS     r0,r0,#12
000270  9001              STR      r0,[sp,#4]
;;;682    	if ((Polar2 & 0x08) == 0)			   
000272  8ab8              LDRH     r0,[r7,#0x14]  ; Correct_Parametet
000274  0700              LSLS     r0,r0,#28
000276  d40a              BMI      |L2.654|
;;;683    	{
;;;684    		if (var32 < SET_ReadA1_Offset) var32 = 0;
000278  69a0              LDR      r0,[r4,#0x18]  ; Correct_Strong
00027a  9901              LDR      r1,[sp,#4]
00027c  4288              CMP      r0,r1
00027e  d901              BLS      |L2.644|
000280  9501              STR      r5,[sp,#4]
000282  e008              B        |L2.662|
                  |L2.644|
;;;685    		else var32 = var32 - SET_ReadA1_Offset;
000284  69a0              LDR      r0,[r4,#0x18]  ; Correct_Strong
000286  9901              LDR      r1,[sp,#4]
000288  1a08              SUBS     r0,r1,r0
00028a  9001              STR      r0,[sp,#4]
00028c  e003              B        |L2.662|
                  |L2.654|
;;;686    	}
;;;687    	else var32 = var32 + SET_ReadA1_Offset;
00028e  69a0              LDR      r0,[r4,#0x18]  ; Correct_Strong
000290  9901              LDR      r1,[sp,#4]
000292  4408              ADD      r0,r0,r1
000294  9001              STR      r0,[sp,#4]
                  |L2.662|
;;;688    	var32 = var32/SET_CorrectionA1;
000296  89f8              LDRH     r0,[r7,#0xe]  ; Correct_Parametet
000298  9901              LDR      r1,[sp,#4]
00029a  fbb1f0f0          UDIV     r0,r1,r0
00029e  9001              STR      r0,[sp,#4]
;;;689    	var32=var32>>1;
0002a0  9801              LDR      r0,[sp,#4]
0002a2  0840              LSRS     r0,r0,#1
0002a4  9001              STR      r0,[sp,#4]
;;;690    	if(Flag_DAC_OFF==0)
0002a6  482b              LDR      r0,|L2.852|
0002a8  7800              LDRB     r0,[r0,#0]  ; flagB
0002aa  0701              LSLS     r1,r0,#28
;;;691    	{
;;;692    		Contr_Laod = var32;
0002ac  482a              LDR      r0,|L2.856|
0002ae  d401              BMI      |L2.692|
0002b0  9901              LDR      r1,[sp,#4]
0002b2  8001              STRH     r1,[r0,#0]
                  |L2.692|
;;;693    	}
;;;694    	if(SET_Current_Laod==0)
0002b4  8931              LDRH     r1,[r6,#8]  ; Run_Control
0002b6  b901              CBNZ     r1,|L2.698|
;;;695    	{
;;;696    		Contr_Laod=0;
0002b8  8005              STRH     r5,[r0,#0]
                  |L2.698|
;;;697    	}
;;;698    	
;;;699    	var32 = 0;
;;;700    /*******************负载测量电流转换**************************************/
;;;701    	var32 = Imon1_value;
0002ba  4828              LDR      r0,|L2.860|
0002bc  8800              LDRH     r0,[r0,#0]  ; Imon1_value
0002be  9001              STR      r0,[sp,#4]
;;;702    	var32 = var32 * REG_CorrectionA1;  
0002c0  88b8              LDRH     r0,[r7,#4]  ; Correct_Parametet
0002c2  9901              LDR      r1,[sp,#4]
0002c4  4348              MULS     r0,r1,r0
0002c6  9001              STR      r0,[sp,#4]
;;;703    //	if ((Polar2 & 0x04) == 0x04)		  
;;;704    //	{
;;;705    //		if (var32 < REG_ReadA1_Offset) 
;;;706    //		{
;;;707    //			var32 = 0;
;;;708    //		}
;;;709    //		else 
;;;710    			var32 = var32 - REG_ReadA1_Offset;
0002c8  68a0              LDR      r0,[r4,#8]  ; Correct_Strong
0002ca  9901              LDR      r1,[sp,#4]
0002cc  1a08              SUBS     r0,r1,r0
0002ce  9001              STR      r0,[sp,#4]
;;;711    //	}
;;;712    //	else var32 = var32 + REG_ReadA1_Offset;
;;;713    	var32 = var32 >> 12;
0002d0  9801              LDR      r0,[sp,#4]
0002d2  0b00              LSRS     r0,r0,#12
0002d4  9001              STR      r0,[sp,#4]
;;;714    	Laod_Current = var32;
0002d6  9801              LDR      r0,[sp,#4]
0002d8  8330              STRH     r0,[r6,#0x18]
;;;715    	DISS_Current=Laod_Current;
0002da  8b30              LDRH     r0,[r6,#0x18]  ; Run_Control
0002dc  ee000a10          VMOV     s0,r0
0002e0  481f              LDR      r0,|L2.864|
0002e2  eeb81a40          VCVT.F32.U32 s2,s0
;;;716    	DISS_Current=DISS_Current/100;//计算显示电流
0002e6  ee810a08          VDIV.F32 s0,s2,s16
0002ea  ed800a00          VSTR     s0,[r0,#0]
;;;717    	if(DISS_Current > 20)
0002ee  ee101a10          VMOV     r1,s0
0002f2  4a1c              LDR      r2,|L2.868|
0002f4  4291              CMP      r1,r2
0002f6  dd01              BLE      |L2.764|
;;;718    	{
;;;719    		DISS_Current = 0;
0002f8  edc00a00          VSTR     s1,[r0,#0]
                  |L2.764|
;;;720    	}
;;;721    	var32 = 0;		
0002fc  9501              STR      r5,[sp,#4]
;;;722    	
;;;723    }
0002fe  b002              ADD      sp,sp,#8
000300  ecbd8b02          VPOP     {d8}
000304  e8bd81f0          POP      {r4-r8,pc}
;;;724    /********************************************************************************
                          ENDP

                  |L2.776|
                          DCD      Vmon_value
                  |L2.780|
                          DCD      ||.bss||
                  |L2.784|
                          DCD      DISS_Voltage
                  |L2.788|
000314  42c80000          DCFS     0x42c80000 ; 100
                  |L2.792|
                          DCD      0x41200000
                  |L2.796|
00031c  47ae147b          DCFD     0x3fa47ae147ae147b ; 0.040000000000000001
000320  3fa47ae1
                  |L2.804|
000324  47ae147b          DCFD     0x3f947ae147ae147b ; 0.02
000328  3f947ae1
                  |L2.812|
                          DCD      Vmon1_value
                  |L2.816|
000330  00000000          DCFS     0x00000000 ; 0
                  |L2.820|
                          DCD      DISS_POW_Voltage
                  |L2.824|
                          DCD      Rmon_value
                  |L2.828|
                          DCD      Imon_value
                  |L2.832|
                          DCD      DISS_POW_Current
                  |L2.836|
000344  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.840|
                          DCD      0x40c00000
                  |L2.844|
                          DCD      Contr_Voltage
                  |L2.848|
                          DCD      Contr_Current
                  |L2.852|
                          DCD      flagB
                  |L2.856|
                          DCD      Contr_Laod
                  |L2.860|
                          DCD      Imon1_value
                  |L2.864|
                          DCD      DISS_Current
                  |L2.868|
                          DCD      0x41a00000

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;44     //===========================MODBUS协议=============================//
;;;45     void UART_Action(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;46     {//RUT格式：
000004  b087              SUB      sp,sp,#0x1c
;;;47     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;48     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;49     	if (g_tModS.RxBuf[0] == ADDR)
000006  f8dfb3f8          LDR      r11,|L3.1024|
00000a  4dfe              LDR      r5,|L3.1028|
00000c  f89b0000          LDRB     r0,[r11,#0]  ; g_tModS
000010  7829              LDRB     r1,[r5,#0]  ; ADDR
;;;50     	{
;;;51     		if (g_tModS.RxBuf[1] == (0x03))	//命令3 读数据   
;;;52     		{																		 
;;;53     			vu8 i;
;;;54     			vu16 crc_result;
;;;55     			crc_result = (g_tModS.RxBuf[6] << 8) + g_tModS.RxBuf[7];
;;;56     			if ((crc_result == Hardware_CRC(g_tModS.RxBuf,6)) ||(crc_result == 0) )
;;;57     			{
;;;58     				if (g_tModS.RxBuf[3] < 0x07)    								//如果寄存器在可读范围内
;;;59     				{
;;;60     					if ((g_tModS.RxBuf[3] + g_tModS.RxBuf[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;61     					{							
;;;62     						UART_Buffer_Send[0] = ADDR;
000012  4bfd              LDR      r3,|L3.1032|
;;;63     						UART_Buffer_Send[1] = 0x03;
;;;64     						UART_Buffer_Send[2] = g_tModS.RxBuf[5]*2;
;;;65     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;66     						{
;;;67     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[g_tModS.RxBuf[3] + i / 2] >> 8;
;;;68     							else UART_Buffer_Send[3 + i] = Run_Control[g_tModS.RxBuf[3] + i / 2];														
;;;69     						}
;;;70     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;71     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;72     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;73     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
000014  4ffd              LDR      r7,|L3.1036|
;;;74     						UART_SEND_flag=1;
000016  4cfe              LDR      r4,|L3.1040|
000018  4efe              LDR      r6,|L3.1044|
00001a  f04f0800          MOV      r8,#0                 ;67
00001e  4288              CMP      r0,r1                 ;49
000020  d15b              BNE      |L3.218|
000022  f89b0001          LDRB     r0,[r11,#1]           ;51  ; g_tModS
000026  2803              CMP      r0,#3                 ;51
000028  d157              BNE      |L3.218|
00002a  f89b0007          LDRB     r0,[r11,#7]           ;55  ; g_tModS
00002e  f89b1006          LDRB     r1,[r11,#6]           ;55  ; g_tModS
000032  eb002001          ADD      r0,r0,r1,LSL #8       ;55
000036  9005              STR      r0,[sp,#0x14]         ;55
000038  2106              MOVS     r1,#6                 ;56
00003a  4658              MOV      r0,r11                ;56
00003c  f7fffffe          BL       Hardware_CRC
000040  f8bd1014          LDRH     r1,[sp,#0x14]         ;56
000044  4288              CMP      r0,r1                 ;56
000046  d002              BEQ      |L3.78|
000048  f8bd0014          LDRH     r0,[sp,#0x14]         ;56
00004c  bbf0              CBNZ     r0,|L3.204|
                  |L3.78|
00004e  f89b0003          LDRB     r0,[r11,#3]           ;58  ; g_tModS
000052  2807              CMP      r0,#7                 ;58
000054  d241              BCS      |L3.218|
000056  f89b1005          LDRB     r1,[r11,#5]           ;60  ; g_tModS
00005a  1842              ADDS     r2,r0,r1              ;60
00005c  2a0f              CMP      r2,#0xf               ;60
00005e  d23c              BCS      |L3.218|
000060  782a              LDRB     r2,[r5,#0]            ;62  ; ADDR
000062  701a              STRB     r2,[r3,#0]            ;62
000064  2203              MOVS     r2,#3                 ;63
000066  705a              STRB     r2,[r3,#1]            ;63
000068  0049              LSLS     r1,r1,#1              ;64
00006a  7099              STRB     r1,[r3,#2]            ;64
00006c  f8cd8018          STR      r8,[sp,#0x18]         ;65
000070  e011              B        |L3.150|
                  |L3.114|
000072  f89d1018          LDRB     r1,[sp,#0x18]         ;67
000076  07c9              LSLS     r1,r1,#31             ;67
000078  d048              BEQ      |L3.268|
00007a  f89d1018          LDRB     r1,[sp,#0x18]         ;68
00007e  eb000151          ADD      r1,r0,r1,LSR #1       ;68
000082  f8361011          LDRH     r1,[r6,r1,LSL #1]     ;68
000086  f89d2018          LDRB     r2,[sp,#0x18]         ;68
00008a  441a              ADD      r2,r2,r3              ;68
00008c  70d1              STRB     r1,[r2,#3]            ;68
                  |L3.142|
00008e  f89d1018          LDRB     r1,[sp,#0x18]         ;65
000092  1c49              ADDS     r1,r1,#1              ;65
000094  9106              STR      r1,[sp,#0x18]         ;65
                  |L3.150|
000096  7899              LDRB     r1,[r3,#2]            ;65  ; UART_Buffer_Send
000098  f89d2018          LDRB     r2,[sp,#0x18]         ;65
00009c  4291              CMP      r1,r2                 ;65
00009e  d8e8              BHI      |L3.114|
0000a0  7898              LDRB     r0,[r3,#2]            ;70  ; UART_Buffer_Send
0000a2  1cc0              ADDS     r0,r0,#3              ;70
0000a4  b2c1              UXTB     r1,r0                 ;70
0000a6  48d8              LDR      r0,|L3.1032|
0000a8  f7fffffe          BL       Hardware_CRC
0000ac  9005              STR      r0,[sp,#0x14]         ;70
0000ae  f8bd0014          LDRH     r0,[sp,#0x14]         ;71
0000b2  789a              LDRB     r2,[r3,#2]            ;71  ; UART_Buffer_Send
0000b4  0a01              LSRS     r1,r0,#8              ;71
0000b6  48d4              LDR      r0,|L3.1032|
0000b8  1cc0              ADDS     r0,r0,#3              ;71
0000ba  5411              STRB     r1,[r2,r0]            ;71
0000bc  f8bd0014          LDRH     r0,[sp,#0x14]         ;72
0000c0  789a              LDRB     r2,[r3,#2]            ;72  ; UART_Buffer_Send
0000c2  49d1              LDR      r1,|L3.1032|
0000c4  1d09              ADDS     r1,r1,#4              ;72
0000c6  5450              STRB     r0,[r2,r1]            ;72
0000c8  7898              LDRB     r0,[r3,#2]            ;73  ; UART_Buffer_Send
0000ca  e000              B        |L3.206|
                  |L3.204|
0000cc  e005              B        |L3.218|
                  |L3.206|
0000ce  1d40              ADDS     r0,r0,#5              ;73
0000d0  7038              STRB     r0,[r7,#0]            ;73
0000d2  6820              LDR      r0,[r4,#0]  ; flagA
0000d4  f0400010          ORR      r0,r0,#0x10
0000d8  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.218|
;;;75     					}
;;;76     				}
;;;77     			}	
;;;78     		}
;;;79     	} 
;;;80     //===============================写寄存器=================================
;;;81     	if ((g_tModS.RxBuf[0] == 0) || (g_tModS.RxBuf[0] == ADDR) || (g_tModS.RxBuf[0] == ((ADDR-1)/4+100)))	 
0000da  f89b1000          LDRB     r1,[r11,#0]  ; g_tModS
0000de  b161              CBZ      r1,|L3.250|
0000e0  7828              LDRB     r0,[r5,#0]  ; ADDR
0000e2  4281              CMP      r1,r0
0000e4  d009              BEQ      |L3.250|
0000e6  7828              LDRB     r0,[r5,#0]  ; ADDR
0000e8  1e40              SUBS     r0,r0,#1
0000ea  17c2              ASRS     r2,r0,#31
0000ec  eb007092          ADD      r0,r0,r2,LSR #30
0000f0  2264              MOVS     r2,#0x64
0000f2  eb0200a0          ADD      r0,r2,r0,ASR #2
0000f6  4288              CMP      r0,r1
0000f8  d177              BNE      |L3.490|
                  |L3.250|
;;;82     	{
;;;83     		vu8 var8;
;;;84     		vu8 a=0;
0000fa  f8cd8014          STR      r8,[sp,#0x14]
;;;85     		vu16 var16;
;;;86     		vu16 crc_result;
;;;87     //=========================以下命令6 写单个寄存器===========================
;;;88     		if (g_tModS.RxBuf[1] == 6)                                 //判断第二个字节是否为命令6
0000fe  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
;;;89     		{
;;;90     			if (g_tModS.RxBuf[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;91     			{
;;;92     				crc_result = (g_tModS.RxBuf[6] << 8) + g_tModS.RxBuf[7];
;;;93     				if ((crc_result == Hardware_CRC(g_tModS.RxBuf,6)) ||(crc_result == 0) )		  //检查CRC
;;;94     				{
;;;95     					var16 = (g_tModS.RxBuf[4] << 8) + g_tModS.RxBuf[5];	//第5 6个字节为要写入的数据
;;;96     					var8 = g_tModS.RxBuf[3];	        						//第3 4个字节为要写入的地址
;;;97     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;98     
;;;99     					if (g_tModS.RxBuf[0] == ADDR)							//广播模式下不返回数据
;;;100    					{
;;;101    						for (a=0;a<8;a++)
;;;102    						{UART_Buffer_Send[a] = g_tModS.RxBuf[a];}
;;;103    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
000102  f04f0908          MOV      r9,#8
000106  2806              CMP      r0,#6                 ;88
000108  d00c              BEQ      |L3.292|
00010a  e04e              B        |L3.426|
                  |L3.268|
00010c  f89d1018          LDRB     r1,[sp,#0x18]         ;67
000110  eb000151          ADD      r1,r0,r1,LSR #1       ;67
000114  f8361011          LDRH     r1,[r6,r1,LSL #1]     ;67
000118  f89d2018          LDRB     r2,[sp,#0x18]         ;67
00011c  0a09              LSRS     r1,r1,#8              ;67
00011e  441a              ADD      r2,r2,r3              ;67
000120  70d1              STRB     r1,[r2,#3]            ;67
000122  e7b4              B        |L3.142|
                  |L3.292|
000124  f89b0003          LDRB     r0,[r11,#3]           ;90  ; g_tModS
000128  2805              CMP      r0,#5                 ;90
00012a  d23e              BCS      |L3.426|
00012c  f89b0007          LDRB     r0,[r11,#7]           ;92  ; g_tModS
000130  f89b1006          LDRB     r1,[r11,#6]           ;92  ; g_tModS
000134  eb002001          ADD      r0,r0,r1,LSL #8       ;92
000138  9003              STR      r0,[sp,#0xc]          ;92
00013a  2106              MOVS     r1,#6                 ;93
00013c  48b0              LDR      r0,|L3.1024|
00013e  f7fffffe          BL       Hardware_CRC
000142  f8bd100c          LDRH     r1,[sp,#0xc]          ;93
000146  4288              CMP      r0,r1                 ;93
000148  d002              BEQ      |L3.336|
00014a  f8bd000c          LDRH     r0,[sp,#0xc]          ;93
00014e  bb60              CBNZ     r0,|L3.426|
                  |L3.336|
000150  f89b0005          LDRB     r0,[r11,#5]           ;95  ; g_tModS
000154  f89b1004          LDRB     r1,[r11,#4]           ;95  ; g_tModS
000158  eb002001          ADD      r0,r0,r1,LSL #8       ;95
00015c  9004              STR      r0,[sp,#0x10]         ;95
00015e  f89b0003          LDRB     r0,[r11,#3]           ;96  ; g_tModS
000162  9006              STR      r0,[sp,#0x18]         ;96
000164  f8bd0010          LDRH     r0,[sp,#0x10]         ;97
000168  f89d1018          LDRB     r1,[sp,#0x18]         ;97
00016c  f8260011          STRH     r0,[r6,r1,LSL #1]     ;97
000170  f89b0000          LDRB     r0,[r11,#0]           ;99  ; g_tModS
000174  7829              LDRB     r1,[r5,#0]            ;99  ; ADDR
000176  4288              CMP      r0,r1                 ;99
000178  d117              BNE      |L3.426|
00017a  f8cd8014          STR      r8,[sp,#0x14]         ;101
00017e  e00a              B        |L3.406|
                  |L3.384|
000180  f89d0014          LDRB     r0,[sp,#0x14]         ;102
000184  f89d1014          LDRB     r1,[sp,#0x14]         ;102
000188  f81b0000          LDRB     r0,[r11,r0]           ;102
00018c  5458              STRB     r0,[r3,r1]            ;102
00018e  f89d0014          LDRB     r0,[sp,#0x14]         ;101
000192  1c40              ADDS     r0,r0,#1              ;101
000194  9005              STR      r0,[sp,#0x14]         ;101
                  |L3.406|
000196  f89d0014          LDRB     r0,[sp,#0x14]         ;101
00019a  2808              CMP      r0,#8                 ;101
00019c  d3f0              BCC      |L3.384|
00019e  f8879000          STRB     r9,[r7,#0]
;;;104    						UART_SEND_flag=1;
0001a2  6820              LDR      r0,[r4,#0]  ; flagA
0001a4  f0400010          ORR      r0,r0,#0x10
0001a8  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.426|
;;;105    					}
;;;106    				}
;;;107    			}
;;;108    		}
;;;109    //=======================================以下是命令16，连写寄存器===========================================
;;;110    //功能码16格式:
;;;111    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;112    //返回数据格式:
;;;113    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;114    		if (g_tModS.RxBuf[1] == 16)										  
0001aa  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
0001ae  2810              CMP      r0,#0x10
0001b0  d15b              BNE      |L3.618|
;;;115    		{	
;;;116    			if ((g_tModS.RxBuf[6] == 6) && (g_tModS.RxBuf[3] == 0x00))	//规定连写寄存器的个数
0001b2  f89b0006          LDRB     r0,[r11,#6]  ; g_tModS
0001b6  2806              CMP      r0,#6
0001b8  d157              BNE      |L3.618|
0001ba  f89b0003          LDRB     r0,[r11,#3]  ; g_tModS
0001be  b9a0              CBNZ     r0,|L3.490|
;;;117    			{
;;;118    				crc_result = (g_tModS.RxBuf[13] << 8) + g_tModS.RxBuf[14];
0001c0  f89b100e          LDRB     r1,[r11,#0xe]  ; g_tModS
0001c4  f89b000d          LDRB     r0,[r11,#0xd]  ; g_tModS
0001c8  eb012000          ADD      r0,r1,r0,LSL #8
0001cc  9003              STR      r0,[sp,#0xc]
;;;119    				if ((crc_result == Hardware_CRC(g_tModS.RxBuf,13)) ||(crc_result == 0) )	   //检查CRC
0001ce  210d              MOVS     r1,#0xd
0001d0  488b              LDR      r0,|L3.1024|
0001d2  f7fffffe          BL       Hardware_CRC
0001d6  f8bd100c          LDRH     r1,[sp,#0xc]
0001da  4288              CMP      r0,r1
0001dc  d002              BEQ      |L3.484|
0001de  f8bd000c          LDRH     r0,[sp,#0xc]
0001e2  b910              CBNZ     r0,|L3.490|
                  |L3.484|
;;;120    				{												
;;;121    					for (var8=0;var8<3;var8++) Run_Control[var8] = (g_tModS.RxBuf[var8*2+7] << 8) + g_tModS.RxBuf[var8*2+8];
0001e4  f8cd8018          STR      r8,[sp,#0x18]
0001e8  e014              B        |L3.532|
                  |L3.490|
0001ea  e03e              B        |L3.618|
                  |L3.492|
0001ec  f89d0018          LDRB     r0,[sp,#0x18]
0001f0  f89d1018          LDRB     r1,[sp,#0x18]
0001f4  eb0b0040          ADD      r0,r11,r0,LSL #1
0001f8  7a00              LDRB     r0,[r0,#8]
0001fa  eb0b0141          ADD      r1,r11,r1,LSL #1
0001fe  79c9              LDRB     r1,[r1,#7]
000200  eb002001          ADD      r0,r0,r1,LSL #8
000204  f89d1018          LDRB     r1,[sp,#0x18]
000208  f8260011          STRH     r0,[r6,r1,LSL #1]
00020c  f89d0018          LDRB     r0,[sp,#0x18]
000210  1c40              ADDS     r0,r0,#1
000212  9006              STR      r0,[sp,#0x18]
                  |L3.532|
000214  f89d0018          LDRB     r0,[sp,#0x18]
000218  2803              CMP      r0,#3
00021a  d3e7              BCC      |L3.492|
;;;122    
;;;123    					if (g_tModS.RxBuf[0] == ADDR)					  //广播模式不返回数据
00021c  f89b0000          LDRB     r0,[r11,#0]  ; g_tModS
000220  7829              LDRB     r1,[r5,#0]  ; ADDR
000222  4288              CMP      r0,r1
000224  d121              BNE      |L3.618|
;;;124    					{
;;;125    						UART_Buffer_Send[0] = ADDR;
000226  7828              LDRB     r0,[r5,#0]  ; ADDR
000228  7018              STRB     r0,[r3,#0]
;;;126    						UART_Buffer_Send[1] = 16;
00022a  2010              MOVS     r0,#0x10
00022c  7058              STRB     r0,[r3,#1]
;;;127    						UART_Buffer_Send[2] = g_tModS.RxBuf[2];
00022e  f89b0002          LDRB     r0,[r11,#2]  ; g_tModS
000232  7098              STRB     r0,[r3,#2]
;;;128    						UART_Buffer_Send[3] = g_tModS.RxBuf[3];
000234  f89b0003          LDRB     r0,[r11,#3]  ; g_tModS
000238  70d8              STRB     r0,[r3,#3]
;;;129    						UART_Buffer_Send[4] = g_tModS.RxBuf[4];
00023a  f89b0004          LDRB     r0,[r11,#4]  ; g_tModS
00023e  7118              STRB     r0,[r3,#4]
;;;130    						UART_Buffer_Send[5] = g_tModS.RxBuf[5];
000240  f89b0005          LDRB     r0,[r11,#5]  ; g_tModS
000244  7158              STRB     r0,[r3,#5]
;;;131    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
000246  2106              MOVS     r1,#6
000248  486f              LDR      r0,|L3.1032|
00024a  f7fffffe          BL       Hardware_CRC
00024e  9003              STR      r0,[sp,#0xc]
;;;132    						UART_Buffer_Send[6] = crc_result>>8;
000250  f8bd000c          LDRH     r0,[sp,#0xc]
000254  0a00              LSRS     r0,r0,#8
000256  7198              STRB     r0,[r3,#6]
;;;133    						UART_Buffer_Send[7] = crc_result;				 
000258  f8bd000c          LDRH     r0,[sp,#0xc]
00025c  71d8              STRB     r0,[r3,#7]
;;;134    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
00025e  f8879000          STRB     r9,[r7,#0]
;;;135    						UART_SEND_flag=1;
000262  6820              LDR      r0,[r4,#0]  ; flagA
000264  f0400010          ORR      r0,r0,#0x10
000268  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.618|
;;;136    					}
;;;137    				}
;;;138    			}			 
;;;139    		}
;;;140    	}
;;;141    //===================================================================================
;;;142        if (((g_tModS.RxBuf[0] == 0x01)&&(g_tModS.RxBuf[2] == 0xA5))||(flag_ADJ_ON==1))			   //电压校准
00026a  f89b0000          LDRB     r0,[r11,#0]  ; g_tModS
00026e  4f6a              LDR      r7,|L3.1048|
000270  2801              CMP      r0,#1
000272  d103              BNE      |L3.636|
000274  f89b0002          LDRB     r0,[r11,#2]  ; g_tModS
000278  28a5              CMP      r0,#0xa5
00027a  d002              BEQ      |L3.642|
                  |L3.636|
00027c  7838              LDRB     r0,[r7,#0]  ; flagF
00027e  0780              LSLS     r0,r0,#30
000280  d57e              BPL      |L3.896|
                  |L3.642|
;;;143    	{
;;;144    		if(g_tModS.RxBuf[1] == 0x01)
000282  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
;;;145    			{
;;;146    				flag_ADJ_VL=0;
;;;147    				Modify_A_READ = Vmon_value;//测量电压值
000286  4965              LDR      r1,|L3.1052|
000288  2801              CMP      r0,#1                 ;144
00028a  d10c              BNE      |L3.678|
00028c  683a              LDR      r2,[r7,#0]            ;146  ; flagF
00028e  f0220204          BIC      r2,r2,#4              ;146
000292  603a              STR      r2,[r7,#0]            ;146  ; flagF
000294  880a              LDRH     r2,[r1,#0]  ; Vmon_value
000296  806a              STRH     r2,[r5,#2]
;;;148    				Modify_A_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];//读取低段
000298  f89b2004          LDRB     r2,[r11,#4]  ; g_tModS
00029c  f89b3003          LDRB     r3,[r11,#3]  ; g_tModS
0002a0  eb022203          ADD      r2,r2,r3,LSL #8
0002a4  80ea              STRH     r2,[r5,#6]
                  |L3.678|
;;;149    			}
;;;150    			if (g_tModS.RxBuf[1] == 0x02)			   //电压测量校准完成
;;;151    			{
;;;152    				vu32 var16;
;;;153    				vu32 var32a;
;;;154    				vu32 var32b;
;;;155    				
;;;156    				vu32 var16a;
;;;157    				vu32 var32c;
;;;158    				vu32 var32d;
;;;159    				Modify_B_READ =Vmon_value;//测量电压值
;;;160    				Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];//读取高段
;;;161    				var32a = Modify_B_ACT;
;;;162    				var32a = var32a - Modify_A_ACT;
;;;163    				var32a = var32a << 12;
;;;164    				var16 = Modify_B_READ - Modify_A_READ;
;;;165    				var32a = var32a / var16;
;;;166    				REG_CorrectionV = var32a;
;;;167    				var32a=0;
;;;168    				var32a = Modify_B_ACT;
;;;169    				var32a = var32a << 12;
;;;170    				var32b = Modify_B_READ;
;;;171    				var32b = var32b * REG_CorrectionV;
;;;172    				if (var32a < var32b)
;;;173    				{
;;;174    					var32b = var32b - var32a;
;;;175    					REG_ReadV_Offset = var32b;
0002a6  4c5b              LDR      r4,|L3.1044|
;;;176    					Polar |= 0x01;
;;;177    				}
;;;178    				else 
;;;179    				{
;;;180    					var32a = var32a - var32b;
;;;181    					REG_ReadV_Offset = var32a;
;;;182    					Polar &= ~0x01;
;;;183    				}			
;;;184    				Flash_Write_all();	//参数写进FLASH
;;;185    				Flag_DAC_OFF=0;
0002a8  4e5d              LDR      r6,|L3.1056|
0002aa  3c28              SUBS     r4,r4,#0x28           ;175
0002ac  f1a4081c          SUB      r8,r4,#0x1c           ;166
0002b0  2802              CMP      r0,#2                 ;150
0002b2  d14c              BNE      |L3.846|
0002b4  8808              LDRH     r0,[r1,#0]            ;159  ; Vmon_value
0002b6  8128              STRH     r0,[r5,#8]            ;159
0002b8  f89b0004          LDRB     r0,[r11,#4]           ;160  ; g_tModS
0002bc  f89b1003          LDRB     r1,[r11,#3]           ;160  ; g_tModS
0002c0  eb002001          ADD      r0,r0,r1,LSL #8       ;160
0002c4  81a8              STRH     r0,[r5,#0xc]          ;160
0002c6  89a8              LDRH     r0,[r5,#0xc]          ;161  ; Modify_B_ACT
0002c8  9005              STR      r0,[sp,#0x14]         ;161
0002ca  88e9              LDRH     r1,[r5,#6]            ;162  ; Modify_A_ACT
0002cc  9805              LDR      r0,[sp,#0x14]         ;162
0002ce  1a40              SUBS     r0,r0,r1              ;162
0002d0  9005              STR      r0,[sp,#0x14]         ;162
0002d2  9805              LDR      r0,[sp,#0x14]         ;163
0002d4  0300              LSLS     r0,r0,#12             ;163
0002d6  9005              STR      r0,[sp,#0x14]         ;163
0002d8  8928              LDRH     r0,[r5,#8]            ;164  ; Modify_B_READ
0002da  8869              LDRH     r1,[r5,#2]            ;164  ; Modify_A_READ
0002dc  1a40              SUBS     r0,r0,r1              ;164
0002de  9006              STR      r0,[sp,#0x18]         ;164
0002e0  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;165
0002e4  fbb0f0f1          UDIV     r0,r0,r1              ;165
0002e8  9005              STR      r0,[sp,#0x14]         ;165
0002ea  9805              LDR      r0,[sp,#0x14]         ;166
0002ec  f8a80000          STRH     r0,[r8,#0]            ;166
0002f0  89a8              LDRH     r0,[r5,#0xc]          ;168  ; Modify_B_ACT
0002f2  9005              STR      r0,[sp,#0x14]         ;168
0002f4  9805              LDR      r0,[sp,#0x14]         ;169
0002f6  0300              LSLS     r0,r0,#12             ;169
0002f8  9005              STR      r0,[sp,#0x14]         ;169
0002fa  8928              LDRH     r0,[r5,#8]            ;170  ; Modify_B_READ
0002fc  9004              STR      r0,[sp,#0x10]         ;170
0002fe  f8b80000          LDRH     r0,[r8,#0]            ;171  ; Correct_Parametet
000302  9904              LDR      r1,[sp,#0x10]         ;171
000304  4348              MULS     r0,r1,r0              ;171
000306  9004              STR      r0,[sp,#0x10]         ;171
000308  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;172
00030c  4288              CMP      r0,r1                 ;172
00030e  d20c              BCS      |L3.810|
000310  e9dd0104          LDRD     r0,r1,[sp,#0x10]      ;174
000314  1a40              SUBS     r0,r0,r1              ;174
000316  9004              STR      r0,[sp,#0x10]         ;174
000318  9804              LDR      r0,[sp,#0x10]         ;175
00031a  6020              STR      r0,[r4,#0]            ;175  ; Correct_Strong
00031c  f8b80008          LDRH     r0,[r8,#8]            ;176  ; Correct_Parametet
000320  f0400001          ORR      r0,r0,#1              ;176
000324  f8a80008          STRH     r0,[r8,#8]            ;176
000328  e00b              B        |L3.834|
                  |L3.810|
00032a  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;180
00032e  1a40              SUBS     r0,r0,r1              ;180
000330  9005              STR      r0,[sp,#0x14]         ;180
000332  9805              LDR      r0,[sp,#0x14]         ;181
000334  6020              STR      r0,[r4,#0]            ;181  ; Correct_Strong
000336  f8b80008          LDRH     r0,[r8,#8]            ;182  ; Correct_Parametet
00033a  f0200001          BIC      r0,r0,#1              ;182
00033e  f8a80008          STRH     r0,[r8,#8]            ;182
                  |L3.834|
000342  f7fffffe          BL       Flash_Write_all
000346  6830              LDR      r0,[r6,#0]  ; flagB
000348  f0200008          BIC      r0,r0,#8
00034c  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.846|
;;;186    			}
;;;187    /************************************???・????У?*****************************************************************/
;;;188    		if (g_tModS.RxBuf[1] == 0x03)			   //CC??У?
00034e  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
;;;189    		{
;;;190    			Modify_A_READ = Imon1_value;//
000352  4934              LDR      r1,|L3.1060|
;;;191    			Modify_C_READ = Contr_Laod;//
000354  f8df90d0          LDR      r9,|L3.1064|
000358  2803              CMP      r0,#3                 ;188
00035a  d10f              BNE      |L3.892|
00035c  880a              LDRH     r2,[r1,#0]            ;190  ; Imon1_value
00035e  806a              STRH     r2,[r5,#2]            ;190
000360  f8b92000          LDRH     r2,[r9,#0]  ; Contr_Laod
000364  80aa              STRH     r2,[r5,#4]
;;;192    			Modify_A_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
000366  f89b2004          LDRB     r2,[r11,#4]  ; g_tModS
00036a  f89b3003          LDRB     r3,[r11,#3]  ; g_tModS
00036e  eb022203          ADD      r2,r2,r3,LSL #8
000372  80ea              STRH     r2,[r5,#6]
;;;193    			Flag_DAC_OFF=1;//
000374  6832              LDR      r2,[r6,#0]  ; flagB
000376  f0420208          ORR      r2,r2,#8
00037a  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.892|
;;;194    		}
;;;195    
;;;196    		if (g_tModS.RxBuf[1] == 0x04)			   //
00037c  2804              CMP      r0,#4
00037e  e000              B        |L3.898|
                  |L3.896|
000380  e29f              B        |L3.2242|
                  |L3.898|
000382  d17d              BNE      |L3.1152|
;;;197    		{
;;;198    			vu32 var16;
;;;199    			vu32 var32a;
;;;200    			vu32 var32b;
;;;201    			
;;;202    			vu32 var16a;
;;;203    			vu32 var32c;
;;;204    			vu32 var32d;
;;;205    			
;;;206    			Modify_B_READ = Imon1_value;
000384  8808              LDRH     r0,[r1,#0]  ; Imon1_value
000386  8128              STRH     r0,[r5,#8]
;;;207    			Modify_D_READ = Contr_Laod;
000388  f8b90000          LDRH     r0,[r9,#0]  ; Contr_Laod
00038c  8168              STRH     r0,[r5,#0xa]
;;;208    			Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
00038e  f89b0004          LDRB     r0,[r11,#4]  ; g_tModS
000392  f89b1003          LDRB     r1,[r11,#3]  ; g_tModS
000396  eb002001          ADD      r0,r0,r1,LSL #8
00039a  81a8              STRH     r0,[r5,#0xc]
;;;209    			
;;;210    			var32a = Modify_B_ACT;
00039c  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
00039e  9005              STR      r0,[sp,#0x14]
;;;211    			var32a = var32a - Modify_A_ACT;
0003a0  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
0003a2  9805              LDR      r0,[sp,#0x14]
0003a4  1a40              SUBS     r0,r0,r1
0003a6  9005              STR      r0,[sp,#0x14]
;;;212    			var32a = var32a << 12;
0003a8  9805              LDR      r0,[sp,#0x14]
0003aa  0300              LSLS     r0,r0,#12
0003ac  9005              STR      r0,[sp,#0x14]
;;;213    			var16 = Modify_B_READ - Modify_A_READ;
0003ae  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
0003b0  8869              LDRH     r1,[r5,#2]  ; Modify_A_READ
0003b2  1a40              SUBS     r0,r0,r1
0003b4  9006              STR      r0,[sp,#0x18]
;;;214    			var32a = var32a / var16;
0003b6  e9dd1005          LDRD     r1,r0,[sp,#0x14]
0003ba  fbb1f0f0          UDIV     r0,r1,r0
0003be  9005              STR      r0,[sp,#0x14]
;;;215    			REG_CorrectionA1 = var32a;
0003c0  9805              LDR      r0,[sp,#0x14]
0003c2  f8a80004          STRH     r0,[r8,#4]
;;;216    			var32a = Modify_B_ACT;
0003c6  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
0003c8  9005              STR      r0,[sp,#0x14]
;;;217    			var32a = var32a << 12;
0003ca  9805              LDR      r0,[sp,#0x14]
0003cc  0300              LSLS     r0,r0,#12
0003ce  9005              STR      r0,[sp,#0x14]
;;;218    			var32b = Modify_B_READ;
0003d0  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
0003d2  9004              STR      r0,[sp,#0x10]
;;;219    			var32b = var32b * REG_CorrectionA1;
0003d4  f8b80004          LDRH     r0,[r8,#4]  ; Correct_Parametet
0003d8  9904              LDR      r1,[sp,#0x10]
0003da  4348              MULS     r0,r1,r0
0003dc  9004              STR      r0,[sp,#0x10]
;;;220    			if (var32a < var32b)
0003de  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0003e2  4281              CMP      r1,r0
0003e4  d222              BCS      |L3.1068|
;;;221    			{
;;;222    				var32b = var32b - var32a;
0003e6  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0003ea  1a40              SUBS     r0,r0,r1
0003ec  9004              STR      r0,[sp,#0x10]
;;;223    				REG_ReadA1_Offset = var32b;
0003ee  9804              LDR      r0,[sp,#0x10]
0003f0  60a0              STR      r0,[r4,#8]  ; Correct_Strong
;;;224    				Polar1 |= 0x01;
0003f2  f8b80012          LDRH     r0,[r8,#0x12]  ; Correct_Parametet
0003f6  f0400001          ORR      r0,r0,#1
0003fa  f8a80012          STRH     r0,[r8,#0x12]
0003fe  e021              B        |L3.1092|
                  |L3.1024|
                          DCD      g_tModS
                  |L3.1028|
                          DCD      ||area_number.9||
                  |L3.1032|
                          DCD      UART_Buffer_Send
                  |L3.1036|
                          DCD      Transmit_BUFFERsize
                  |L3.1040|
                          DCD      flagA
                  |L3.1044|
                          DCD      ||.bss||+0x44
                  |L3.1048|
                          DCD      flagF
                  |L3.1052|
                          DCD      Vmon_value
                  |L3.1056|
                          DCD      flagB
                  |L3.1060|
                          DCD      Imon1_value
                  |L3.1064|
                          DCD      Contr_Laod
                  |L3.1068|
;;;225    			}
;;;226    			else 
;;;227    			{
;;;228    				var32a = var32a - var32b;
00042c  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000430  1a40              SUBS     r0,r0,r1
000432  9005              STR      r0,[sp,#0x14]
;;;229    				REG_ReadA1_Offset = var32a;
000434  9805              LDR      r0,[sp,#0x14]
000436  60a0              STR      r0,[r4,#8]  ; Correct_Strong
;;;230    				Polar1 &= ~0x01;					
000438  f8b80012          LDRH     r0,[r8,#0x12]  ; Correct_Parametet
00043c  f0200001          BIC      r0,r0,#1
000440  f8a80012          STRH     r0,[r8,#0x12]
                  |L3.1092|
;;;231    			}
;;;232    //---------------------------------------------------------------------------------//
;;;233    			var32c = Modify_B_ACT; 
000444  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000446  9002              STR      r0,[sp,#8]
;;;234    			var32c = var32c - Modify_A_ACT;
000448  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
00044a  9802              LDR      r0,[sp,#8]
00044c  1a40              SUBS     r0,r0,r1
00044e  9002              STR      r0,[sp,#8]
;;;235    			var32c = var32c << 12;
000450  9802              LDR      r0,[sp,#8]
000452  0300              LSLS     r0,r0,#12
000454  9002              STR      r0,[sp,#8]
;;;236    			var16a=Modify_D_READ-Modify_C_READ;
000456  8968              LDRH     r0,[r5,#0xa]  ; Modify_D_READ
000458  88a9              LDRH     r1,[r5,#4]  ; Modify_C_READ
00045a  1a40              SUBS     r0,r0,r1
00045c  9003              STR      r0,[sp,#0xc]
;;;237    			var16a=var16a*2;
00045e  9803              LDR      r0,[sp,#0xc]
000460  0040              LSLS     r0,r0,#1
000462  9003              STR      r0,[sp,#0xc]
;;;238    			var32c=var32c/var16a;
000464  e9dd0102          LDRD     r0,r1,[sp,#8]
000468  fbb0f0f1          UDIV     r0,r0,r1
00046c  9002              STR      r0,[sp,#8]
;;;239    			SET_CorrectionA1 = var32c;
00046e  9802              LDR      r0,[sp,#8]
000470  f8a8000e          STRH     r0,[r8,#0xe]
;;;240    			var32c = Modify_B_ACT;
000474  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000476  9002              STR      r0,[sp,#8]
;;;241    			var32c = var32c << 12;
000478  9802              LDR      r0,[sp,#8]
00047a  0300              LSLS     r0,r0,#12
00047c  9002              STR      r0,[sp,#8]
;;;242    			var32d = SET_CorrectionA1;
00047e  e000              B        |L3.1154|
                  |L3.1152|
000480  e02a              B        |L3.1240|
                  |L3.1154|
000482  f8b8000e          LDRH     r0,[r8,#0xe]  ; Correct_Parametet
000486  9001              STR      r0,[sp,#4]
;;;243    			var32d = var32d * (Modify_D_READ*2);
000488  8969              LDRH     r1,[r5,#0xa]  ; Modify_D_READ
00048a  9801              LDR      r0,[sp,#4]
00048c  4348              MULS     r0,r1,r0
00048e  0040              LSLS     r0,r0,#1
000490  9001              STR      r0,[sp,#4]
;;;244    			if (var32c < var32d)
000492  e9dd1001          LDRD     r1,r0,[sp,#4]
000496  4288              CMP      r0,r1
000498  d20c              BCS      |L3.1204|
;;;245    			{
;;;246    				var32d = var32d - var32c;
00049a  e9dd0101          LDRD     r0,r1,[sp,#4]
00049e  1a40              SUBS     r0,r0,r1
0004a0  9001              STR      r0,[sp,#4]
;;;247    				SET_ReadA1_Offset = var32d;
0004a2  9801              LDR      r0,[sp,#4]
0004a4  61a0              STR      r0,[r4,#0x18]  ; Correct_Strong
;;;248    				Polar1 |= 0x04;
0004a6  f8b80012          LDRH     r0,[r8,#0x12]  ; Correct_Parametet
0004aa  f0400004          ORR      r0,r0,#4
0004ae  f8a80012          STRH     r0,[r8,#0x12]
0004b2  e00b              B        |L3.1228|
                  |L3.1204|
;;;249    			}
;;;250    			else 
;;;251    			{
;;;252    				var32c = var32c - var32d;
0004b4  e9dd1001          LDRD     r1,r0,[sp,#4]
0004b8  1a40              SUBS     r0,r0,r1
0004ba  9002              STR      r0,[sp,#8]
;;;253    				SET_ReadA1_Offset = var32c;
0004bc  9802              LDR      r0,[sp,#8]
0004be  61a0              STR      r0,[r4,#0x18]  ; Correct_Strong
;;;254    				Polar1 &= ~0x04;
0004c0  f8b80012          LDRH     r0,[r8,#0x12]  ; Correct_Parametet
0004c4  f0200004          BIC      r0,r0,#4
0004c8  f8a80012          STRH     r0,[r8,#0x12]
                  |L3.1228|
;;;255    			}
;;;256    			Flash_Write_all ();	
0004cc  f7fffffe          BL       Flash_Write_all
;;;257    			Flag_DAC_OFF =0;
0004d0  6830              LDR      r0,[r6,#0]  ; flagB
0004d2  f0200008          BIC      r0,r0,#8
0004d6  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.1240|
;;;258    		}
;;;259    				/*******************************电源电压控制和测量校准******************************************/	
;;;260    			if (g_tModS.RxBuf[1] == 0x0B)			   //电流测量校准
0004d8  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
;;;261    			{
;;;262    				Modify_A_READ = Vmon1_value;//测量电流
0004dc  49fa              LDR      r1,|L3.2248|
;;;263    				Modify_C_READ = Contr_Voltage;//设置电流
0004de  f8dfa3ec          LDR      r10,|L3.2252|
0004e2  280b              CMP      r0,#0xb               ;260
0004e4  d10b              BNE      |L3.1278|
0004e6  880a              LDRH     r2,[r1,#0]            ;262  ; Vmon1_value
0004e8  806a              STRH     r2,[r5,#2]            ;262
0004ea  f8ba2000          LDRH     r2,[r10,#0]  ; Contr_Voltage
0004ee  80aa              STRH     r2,[r5,#4]
;;;264    				Modify_A_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
0004f0  f89b2004          LDRB     r2,[r11,#4]  ; g_tModS
0004f4  f89b3003          LDRB     r3,[r11,#3]  ; g_tModS
0004f8  eb022203          ADD      r2,r2,r3,LSL #8
0004fc  80ea              STRH     r2,[r5,#6]
                  |L3.1278|
;;;265    			}
;;;266    
;;;267    			if (g_tModS.RxBuf[1] == 0x0C)			   //电流测量校准完成
0004fe  280c              CMP      r0,#0xc
000500  d17d              BNE      |L3.1534|
;;;268    			{
;;;269    				vu32 var16;
;;;270    				vu32 var32a;
;;;271    				vu32 var32b;
;;;272    				
;;;273    				vu32 var16a;
;;;274    				vu32 var32c;
;;;275    				vu32 var32d;
;;;276    				Modify_D_READ = Contr_Voltage;
000502  f8ba0000          LDRH     r0,[r10,#0]  ; Contr_Voltage
000506  8168              STRH     r0,[r5,#0xa]
;;;277    				Modify_B_READ = Vmon1_value;
000508  8808              LDRH     r0,[r1,#0]  ; Vmon1_value
00050a  8128              STRH     r0,[r5,#8]
;;;278    				Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];//读取高段
00050c  f89b0004          LDRB     r0,[r11,#4]  ; g_tModS
000510  f89b1003          LDRB     r1,[r11,#3]  ; g_tModS
000514  eb002001          ADD      r0,r0,r1,LSL #8
000518  81a8              STRH     r0,[r5,#0xc]
;;;279    				var32a = Modify_B_ACT;
00051a  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
00051c  9005              STR      r0,[sp,#0x14]
;;;280    				var32a = var32a - Modify_A_ACT;
00051e  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
000520  9805              LDR      r0,[sp,#0x14]
000522  1a40              SUBS     r0,r0,r1
000524  9005              STR      r0,[sp,#0x14]
;;;281    				var32a = var32a << 14;
000526  9805              LDR      r0,[sp,#0x14]
000528  0380              LSLS     r0,r0,#14
00052a  9005              STR      r0,[sp,#0x14]
;;;282    				var16 = Modify_B_READ - Modify_A_READ;
00052c  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
00052e  8869              LDRH     r1,[r5,#2]  ; Modify_A_READ
000530  1a40              SUBS     r0,r0,r1
000532  9006              STR      r0,[sp,#0x18]
;;;283    				var32a = var32a / var16;
000534  e9dd0105          LDRD     r0,r1,[sp,#0x14]
000538  fbb0f0f1          UDIV     r0,r0,r1
00053c  9005              STR      r0,[sp,#0x14]
;;;284    				REG_CorrectionV1 = var32a;
00053e  9805              LDR      r0,[sp,#0x14]
000540  f8a80018          STRH     r0,[r8,#0x18]
;;;285    				var32a=0;
;;;286    				var32a = Modify_B_ACT;
000544  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000546  9005              STR      r0,[sp,#0x14]
;;;287    				var32a = var32a << 14;
000548  9805              LDR      r0,[sp,#0x14]
00054a  0380              LSLS     r0,r0,#14
00054c  9005              STR      r0,[sp,#0x14]
;;;288    				var32b = Modify_B_READ;
00054e  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
000550  9004              STR      r0,[sp,#0x10]
;;;289    				var32b = var32b * REG_CorrectionV1;
000552  f8b80018          LDRH     r0,[r8,#0x18]  ; Correct_Parametet
000556  9904              LDR      r1,[sp,#0x10]
000558  4348              MULS     r0,r1,r0
00055a  9004              STR      r0,[sp,#0x10]
;;;290    				if (var32a < var32b)
00055c  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000560  4288              CMP      r0,r1
000562  d20c              BCS      |L3.1406|
;;;291    				{
;;;292    					var32b = var32b - var32a;
000564  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000568  1a40              SUBS     r0,r0,r1
00056a  9004              STR      r0,[sp,#0x10]
;;;293    					REG_ReadV1_Offset = var32b;
00056c  9804              LDR      r0,[sp,#0x10]
00056e  6220              STR      r0,[r4,#0x20]  ; Correct_Strong
;;;294    					Polar2 |= 0x01;
000570  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
000574  f0400001          ORR      r0,r0,#1
000578  f8a80014          STRH     r0,[r8,#0x14]
00057c  e00b              B        |L3.1430|
                  |L3.1406|
;;;295    				}
;;;296    				else 
;;;297    				{
;;;298    					var32a = var32a - var32b;
00057e  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000582  1a40              SUBS     r0,r0,r1
000584  9005              STR      r0,[sp,#0x14]
;;;299    					REG_ReadV1_Offset = var32a;
000586  9805              LDR      r0,[sp,#0x14]
000588  6220              STR      r0,[r4,#0x20]  ; Correct_Strong
;;;300    					Polar2 &= ~0x01;
00058a  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
00058e  f0200001          BIC      r0,r0,#1
000592  f8a80014          STRH     r0,[r8,#0x14]
                  |L3.1430|
;;;301    				}			
;;;302    				
;;;303    //				vu16 var16;
;;;304    //				vu32 var32a;
;;;305    //				vu32 var32b;
;;;306    //				
;;;307    //				vu16 var16a;
;;;308    //				vu32 var32c;
;;;309    //				vu32 var32d;
;;;310    //				
;;;311    //				Modify_D_READ = Contr_Voltage;
;;;312    //				Modify_B_READ = Vmon1_value;
;;;313    //				Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
;;;314    //				var32a = Modify_B_ACT;
;;;315    //				var32a = var32a - Modify_A_ACT;
;;;316    //				var32a = var32a << 12;
;;;317    //				var16 = Modify_B_READ - Modify_A_READ;
;;;318    //				var32a = var32a / var16;
;;;319    //				REG_CorrectionV1 = var32a;
;;;320    //				var32a = Modify_B_ACT;
;;;321    //				var32a = var32a << 12;
;;;322    //				var32b = Modify_B_READ;
;;;323    //				var32b = var32b * REG_CorrectionV1;
;;;324    //				if (var32a < var32b)
;;;325    //				{
;;;326    //					var32b = var32b - var32a;
;;;327    //					REG_ReadV1_Offset = var32b;
;;;328    //					Polar2 |= 0x01;
;;;329    //				}
;;;330    //				else 
;;;331    //				{
;;;332    //					var32a = var32a - var32b;
;;;333    //					REG_ReadV1_Offset = var32a;
;;;334    //					Polar2 &= ~0x01;					
;;;335    //				}
;;;336    		//---------------------------------------------------------------------------------//
;;;337    				var32c = Modify_B_ACT; //设置电压校准
000596  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000598  9002              STR      r0,[sp,#8]
;;;338    				var32c = var32c - Modify_A_ACT;
00059a  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
00059c  9802              LDR      r0,[sp,#8]
00059e  1a40              SUBS     r0,r0,r1
0005a0  9002              STR      r0,[sp,#8]
;;;339    				var32c = var32c << 14;
0005a2  9802              LDR      r0,[sp,#8]
0005a4  0380              LSLS     r0,r0,#14
0005a6  9002              STR      r0,[sp,#8]
;;;340    				var16a=Modify_D_READ-Modify_C_READ;
0005a8  8968              LDRH     r0,[r5,#0xa]  ; Modify_D_READ
0005aa  88a9              LDRH     r1,[r5,#4]  ; Modify_C_READ
0005ac  1a40              SUBS     r0,r0,r1
0005ae  9003              STR      r0,[sp,#0xc]
;;;341    				var16a=var16a*2;
0005b0  9803              LDR      r0,[sp,#0xc]
0005b2  0040              LSLS     r0,r0,#1
0005b4  9003              STR      r0,[sp,#0xc]
;;;342    				var32c=var32c/var16a;
0005b6  e9dd0102          LDRD     r0,r1,[sp,#8]
0005ba  fbb0f0f1          UDIV     r0,r0,r1
0005be  9002              STR      r0,[sp,#8]
;;;343    				SET_CorrectionV = var32c;
0005c0  9802              LDR      r0,[sp,#8]
0005c2  f8a8000a          STRH     r0,[r8,#0xa]
;;;344    				var32c = Modify_B_ACT;
0005c6  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
0005c8  9002              STR      r0,[sp,#8]
;;;345    				var32c = var32c << 14;
0005ca  9802              LDR      r0,[sp,#8]
0005cc  0380              LSLS     r0,r0,#14
0005ce  9002              STR      r0,[sp,#8]
;;;346    				var32d = SET_CorrectionV;
0005d0  f8b8000a          LDRH     r0,[r8,#0xa]  ; Correct_Parametet
0005d4  9001              STR      r0,[sp,#4]
;;;347    				var32d = var32d * (Modify_D_READ*2);
0005d6  8969              LDRH     r1,[r5,#0xa]  ; Modify_D_READ
0005d8  9801              LDR      r0,[sp,#4]
0005da  4348              MULS     r0,r1,r0
0005dc  0040              LSLS     r0,r0,#1
0005de  9001              STR      r0,[sp,#4]
;;;348    				if (var32c < var32d)
0005e0  e9dd1001          LDRD     r1,r0,[sp,#4]
0005e4  4288              CMP      r0,r1
0005e6  d20e              BCS      |L3.1542|
;;;349    				{
;;;350    					var32d = var32d - var32c;
0005e8  e9dd0101          LDRD     r0,r1,[sp,#4]
0005ec  1a40              SUBS     r0,r0,r1
0005ee  9001              STR      r0,[sp,#4]
;;;351    					SET_ReadV_Offset = var32d;
0005f0  9801              LDR      r0,[sp,#4]
0005f2  6120              STR      r0,[r4,#0x10]  ; Correct_Strong
;;;352    					Polar2 |= 0x04;
0005f4  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
0005f8  f0400004          ORR      r0,r0,#4
0005fc  e000              B        |L3.1536|
                  |L3.1534|
0005fe  e014              B        |L3.1578|
                  |L3.1536|
000600  f8a80014          STRH     r0,[r8,#0x14]
000604  e00b              B        |L3.1566|
                  |L3.1542|
;;;353    				}
;;;354    				else 
;;;355    				{
;;;356    					var32c = var32c - var32d;
000606  e9dd1001          LDRD     r1,r0,[sp,#4]
00060a  1a40              SUBS     r0,r0,r1
00060c  9002              STR      r0,[sp,#8]
;;;357    					SET_ReadV_Offset = var32c;
00060e  9802              LDR      r0,[sp,#8]
000610  6120              STR      r0,[r4,#0x10]  ; Correct_Strong
;;;358    					Polar2 &= ~0x04;
000612  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
000616  f0200004          BIC      r0,r0,#4
00061a  f8a80014          STRH     r0,[r8,#0x14]
                  |L3.1566|
;;;359    				}
;;;360    				Flash_Write_all ();	
00061e  f7fffffe          BL       Flash_Write_all
;;;361    				Flag_DAC_OFF=0;
000622  6830              LDR      r0,[r6,#0]  ; flagB
000624  f0200008          BIC      r0,r0,#8
000628  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.1578|
;;;362    			}
;;;363    			/*******************************电源CC模式电流测量和控制校准******************************************/	
;;;364    			if (g_tModS.RxBuf[1] == 0x09||flag_ADJ_ALCC==1)			   //电流测量校准
00062a  4659              MOV      r1,r11
00062c  f89b0001          LDRB     r0,[r11,#1]  ; g_tModS
;;;365    			{
;;;366    				Modify_A_READ = Imon_value;//测量电流
000630  4aa7              LDR      r2,|L3.2256|
;;;367    				Modify_C_READ = Contr_Current;//设置电流
000632  f8dfb2a0          LDR      r11,|L3.2260|
000636  2809              CMP      r0,#9                 ;364
000638  d002              BEQ      |L3.1600|
00063a  783b              LDRB     r3,[r7,#0]            ;364  ; flagF
00063c  06db              LSLS     r3,r3,#27             ;364
00063e  d50a              BPL      |L3.1622|
                  |L3.1600|
000640  8813              LDRH     r3,[r2,#0]            ;366  ; Imon_value
000642  806b              STRH     r3,[r5,#2]            ;366
000644  f8bb3000          LDRH     r3,[r11,#0]  ; Contr_Current
000648  80ab              STRH     r3,[r5,#4]
;;;368    				Modify_A_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
00064a  790b              LDRB     r3,[r1,#4]  ; g_tModS
00064c  f891c003          LDRB     r12,[r1,#3]  ; g_tModS
000650  eb03230c          ADD      r3,r3,r12,LSL #8
000654  80eb              STRH     r3,[r5,#6]
                  |L3.1622|
;;;369    			}
;;;370    
;;;371    			if (g_tModS.RxBuf[1] == 0x0A||flag_ADJ_AHCC==1)			   //电流测量校准完成
000656  280a              CMP      r0,#0xa
000658  d002              BEQ      |L3.1632|
00065a  7838              LDRB     r0,[r7,#0]  ; flagF
00065c  0680              LSLS     r0,r0,#26
00065e  d57d              BPL      |L3.1884|
                  |L3.1632|
;;;372    			{
;;;373    				vu16 var16;
;;;374    				vu32 var32a;
;;;375    				vu32 var32b;
;;;376    				
;;;377    				vu16 var16a;
;;;378    				vu32 var32c;
;;;379    				vu32 var32d;
;;;380    				
;;;381    				Modify_D_READ = Contr_Current;
000660  f8bb0000          LDRH     r0,[r11,#0]  ; Contr_Current
000664  8168              STRH     r0,[r5,#0xa]
;;;382    				Modify_B_READ = Imon_value;
000666  8810              LDRH     r0,[r2,#0]  ; Imon_value
000668  8128              STRH     r0,[r5,#8]
;;;383    				Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
00066a  489b              LDR      r0,|L3.2264|
00066c  7901              LDRB     r1,[r0,#4]  ; g_tModS
00066e  78c0              LDRB     r0,[r0,#3]  ; g_tModS
000670  eb012000          ADD      r0,r1,r0,LSL #8
000674  81a8              STRH     r0,[r5,#0xc]
;;;384    				var32a = Modify_B_ACT;
000676  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000678  9005              STR      r0,[sp,#0x14]
;;;385    				var32a = var32a - Modify_A_ACT;
00067a  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
00067c  9805              LDR      r0,[sp,#0x14]
00067e  1a40              SUBS     r0,r0,r1
000680  9005              STR      r0,[sp,#0x14]
;;;386    				var32a = var32a << 12;
000682  9805              LDR      r0,[sp,#0x14]
000684  0300              LSLS     r0,r0,#12
000686  9005              STR      r0,[sp,#0x14]
;;;387    				var16 = Modify_B_READ - Modify_A_READ;
000688  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
00068a  8869              LDRH     r1,[r5,#2]  ; Modify_A_READ
00068c  1a40              SUBS     r0,r0,r1
00068e  9006              STR      r0,[sp,#0x18]
;;;388    				var32a = var32a / var16;
000690  f8bd1018          LDRH     r1,[sp,#0x18]
000694  9805              LDR      r0,[sp,#0x14]
000696  fbb0f0f1          UDIV     r0,r0,r1
00069a  9005              STR      r0,[sp,#0x14]
;;;389    				CON_CorrectionA = var32a;
00069c  9805              LDR      r0,[sp,#0x14]
00069e  f8a80010          STRH     r0,[r8,#0x10]
;;;390    				var32a = Modify_B_ACT;
0006a2  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
0006a4  9005              STR      r0,[sp,#0x14]
;;;391    				var32a = var32a << 12;
0006a6  9805              LDR      r0,[sp,#0x14]
0006a8  0300              LSLS     r0,r0,#12
0006aa  9005              STR      r0,[sp,#0x14]
;;;392    				var32b = Modify_B_READ;
0006ac  8928              LDRH     r0,[r5,#8]  ; Modify_B_READ
0006ae  9004              STR      r0,[sp,#0x10]
;;;393    				var32b = var32b * CON_CorrectionA;
0006b0  f8b80010          LDRH     r0,[r8,#0x10]  ; Correct_Parametet
0006b4  9904              LDR      r1,[sp,#0x10]
0006b6  4348              MULS     r0,r1,r0
0006b8  9004              STR      r0,[sp,#0x10]
;;;394    				if (var32a < var32b)
0006ba  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0006be  4281              CMP      r1,r0
0006c0  d20c              BCS      |L3.1756|
;;;395    				{
;;;396    					var32b = var32b - var32a;
0006c2  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0006c6  1a40              SUBS     r0,r0,r1
0006c8  9004              STR      r0,[sp,#0x10]
;;;397    					CON_ReadA_Offset = var32b;
0006ca  9804              LDR      r0,[sp,#0x10]
0006cc  61e0              STR      r0,[r4,#0x1c]  ; Correct_Strong
;;;398    					Polar2 |= 0x01;
0006ce  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
0006d2  f0400001          ORR      r0,r0,#1
0006d6  f8a80014          STRH     r0,[r8,#0x14]
0006da  e00b              B        |L3.1780|
                  |L3.1756|
;;;399    				}
;;;400    				else 
;;;401    				{
;;;402    					var32a = var32a - var32b;
0006dc  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0006e0  1a40              SUBS     r0,r0,r1
0006e2  9005              STR      r0,[sp,#0x14]
;;;403    					CON_ReadA_Offset = var32a;
0006e4  9805              LDR      r0,[sp,#0x14]
0006e6  61e0              STR      r0,[r4,#0x1c]  ; Correct_Strong
;;;404    					Polar2 &= ~0x01;					//电流测量系数和零点校准完成
0006e8  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
0006ec  f0200001          BIC      r0,r0,#1
0006f0  f8a80014          STRH     r0,[r8,#0x14]
                  |L3.1780|
;;;405    				}
;;;406    		//---------------------------------------------------------------------------------//
;;;407    				var32c = Modify_B_ACT; //设置电流校准
0006f4  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
0006f6  9002              STR      r0,[sp,#8]
;;;408    				var32c = var32c - Modify_A_ACT;
0006f8  88e9              LDRH     r1,[r5,#6]  ; Modify_A_ACT
0006fa  9802              LDR      r0,[sp,#8]
0006fc  1a40              SUBS     r0,r0,r1
0006fe  9002              STR      r0,[sp,#8]
;;;409    				var32c = var32c << 14;
000700  9802              LDR      r0,[sp,#8]
000702  0380              LSLS     r0,r0,#14
000704  9002              STR      r0,[sp,#8]
;;;410    				var16a=Modify_D_READ-Modify_C_READ;
000706  8968              LDRH     r0,[r5,#0xa]  ; Modify_D_READ
000708  88a9              LDRH     r1,[r5,#4]  ; Modify_C_READ
00070a  1a40              SUBS     r0,r0,r1
00070c  9003              STR      r0,[sp,#0xc]
;;;411    				var16a=var16a*2;
00070e  f8bd000c          LDRH     r0,[sp,#0xc]
000712  f64f71ff          MOV      r1,#0xffff
000716  ea010040          AND      r0,r1,r0,LSL #1
00071a  9003              STR      r0,[sp,#0xc]
;;;412    				var32c=var32c/var16a;
00071c  f8bd100c          LDRH     r1,[sp,#0xc]
000720  9802              LDR      r0,[sp,#8]
000722  fbb0f0f1          UDIV     r0,r0,r1
000726  9002              STR      r0,[sp,#8]
;;;413    				SET_CorrectionA = var32c;
000728  9802              LDR      r0,[sp,#8]
00072a  f8a8000c          STRH     r0,[r8,#0xc]
;;;414    				var32c = Modify_B_ACT;
00072e  89a8              LDRH     r0,[r5,#0xc]  ; Modify_B_ACT
000730  9002              STR      r0,[sp,#8]
;;;415    				var32c = var32c << 14;
000732  9802              LDR      r0,[sp,#8]
000734  0380              LSLS     r0,r0,#14
000736  9002              STR      r0,[sp,#8]
;;;416    				var32d = SET_CorrectionA;
000738  f8b8000c          LDRH     r0,[r8,#0xc]  ; Correct_Parametet
00073c  9001              STR      r0,[sp,#4]
;;;417    				var32d = var32d * (Modify_D_READ*2);
00073e  8969              LDRH     r1,[r5,#0xa]  ; Modify_D_READ
000740  9801              LDR      r0,[sp,#4]
000742  4348              MULS     r0,r1,r0
000744  0040              LSLS     r0,r0,#1
000746  9001              STR      r0,[sp,#4]
;;;418    				if (var32c < var32d)
000748  e9dd1001          LDRD     r1,r0,[sp,#4]
00074c  4288              CMP      r0,r1
00074e  d20e              BCS      |L3.1902|
;;;419    				{
;;;420    					var32d = var32d - var32c;
000750  e9dd1001          LDRD     r1,r0,[sp,#4]
000754  1a08              SUBS     r0,r1,r0
000756  9001              STR      r0,[sp,#4]
;;;421    					SET_ReadA_Offset = var32d;
000758  9801              LDR      r0,[sp,#4]
00075a  e000              B        |L3.1886|
                  |L3.1884|
00075c  e019              B        |L3.1938|
                  |L3.1886|
00075e  6160              STR      r0,[r4,#0x14]  ; Correct_Strong
;;;422    					Polar2 |= 0x04;
000760  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
000764  f0400004          ORR      r0,r0,#4
000768  f8a80014          STRH     r0,[r8,#0x14]
00076c  e00b              B        |L3.1926|
                  |L3.1902|
;;;423    				}
;;;424    				else 
;;;425    				{
;;;426    					var32c = var32c - var32d;
00076e  e9dd1001          LDRD     r1,r0,[sp,#4]
000772  1a40              SUBS     r0,r0,r1
000774  9002              STR      r0,[sp,#8]
;;;427    					SET_ReadA_Offset = var32c;
000776  9802              LDR      r0,[sp,#8]
000778  6160              STR      r0,[r4,#0x14]  ; Correct_Strong
;;;428    					Polar2 &= ~0x04;
00077a  f8b80014          LDRH     r0,[r8,#0x14]  ; Correct_Parametet
00077e  f0200004          BIC      r0,r0,#4
000782  f8a80014          STRH     r0,[r8,#0x14]
                  |L3.1926|
;;;429    				}
;;;430    				Flash_Write_all ();	
000786  f7fffffe          BL       Flash_Write_all
;;;431    				Flag_DAC_OFF=0;
00078a  6830              LDR      r0,[r6,#0]  ; flagB
00078c  f0200008          BIC      r0,r0,#8
000790  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.1938|
;;;432    			}
;;;433            /*************************************内阻校准**************************************************************************/
;;;434    		if(g_tModS.RxBuf[1] == 0x07||flag_ADJ_VL==1)
000792  4951              LDR      r1,|L3.2264|
;;;435    		{
;;;436    			Modify_A_READ = Rmon_value;//测量电压值
000794  4a51              LDR      r2,|L3.2268|
000796  7848              LDRB     r0,[r1,#1]            ;434  ; g_tModS
000798  2807              CMP      r0,#7                 ;434
00079a  d002              BEQ      |L3.1954|
00079c  783b              LDRB     r3,[r7,#0]            ;434  ; flagF
00079e  075b              LSLS     r3,r3,#29             ;434
0007a0  d507              BPL      |L3.1970|
                  |L3.1954|
0007a2  8813              LDRH     r3,[r2,#0]  ; Rmon_value
0007a4  806b              STRH     r3,[r5,#2]
;;;437    			Modify_A_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];//读取低段
0007a6  790b              LDRB     r3,[r1,#4]  ; g_tModS
0007a8  f891c003          LDRB     r12,[r1,#3]  ; g_tModS
0007ac  eb03230c          ADD      r3,r3,r12,LSL #8
0007b0  80eb              STRH     r3,[r5,#6]
                  |L3.1970|
;;;438    		}
;;;439    		if (g_tModS.RxBuf[1] == 0x08||flag_ADJ_VH==1)			   //电压测量校准完成
0007b2  2808              CMP      r0,#8
0007b4  d002              BEQ      |L3.1980|
0007b6  7838              LDRB     r0,[r7,#0]  ; flagF
0007b8  0700              LSLS     r0,r0,#28
0007ba  d55c              BPL      |L3.2166|
                  |L3.1980|
;;;440    		{
;;;441    			vu16 var16;
;;;442    			vu32 var32a;
;;;443    			vu32 var32b;
;;;444    			
;;;445    			vu16 var16a;
;;;446    			vu32 var32c;
;;;447    			vu32 var32d;
;;;448    			Modify_B_READ =Rmon_value;//测量电压值
0007bc  8811              LDRH     r1,[r2,#0]  ; Rmon_value
0007be  4628              MOV      r0,r5
0007c0  8129              STRH     r1,[r5,#8]
;;;449    			flag_OverV=1;
0007c2  4d47              LDR      r5,|L3.2272|
0007c4  6829              LDR      r1,[r5,#0]  ; flagG
0007c6  f0410102          ORR      r1,r1,#2
0007ca  6029              STR      r1,[r5,#0]  ; flagG
;;;450    			Modify_B_ACT = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];//读取高段
0007cc  4a42              LDR      r2,|L3.2264|
0007ce  7913              LDRB     r3,[r2,#4]  ; g_tModS
0007d0  78d2              LDRB     r2,[r2,#3]  ; g_tModS
0007d2  eb032202          ADD      r2,r3,r2,LSL #8
0007d6  8182              STRH     r2,[r0,#0xc]
;;;451    			if(flag_OverV==1)//只有当有数据写入时才能将校准数据写入FLASH
0007d8  0789              LSLS     r1,r1,#30
0007da  d548              BPL      |L3.2158|
;;;452    			{
;;;453    				var32a = Modify_B_ACT;
0007dc  8981              LDRH     r1,[r0,#0xc]  ; Modify_B_ACT
0007de  9105              STR      r1,[sp,#0x14]
;;;454    				var32a = var32a - Modify_A_ACT;
0007e0  88c2              LDRH     r2,[r0,#6]  ; Modify_A_ACT
0007e2  9905              LDR      r1,[sp,#0x14]
0007e4  1a89              SUBS     r1,r1,r2
0007e6  9105              STR      r1,[sp,#0x14]
;;;455    				var32a = var32a << 12;
0007e8  9905              LDR      r1,[sp,#0x14]
0007ea  0309              LSLS     r1,r1,#12
0007ec  9105              STR      r1,[sp,#0x14]
;;;456    				var16 = Modify_B_READ - Modify_A_READ;
0007ee  8901              LDRH     r1,[r0,#8]  ; Modify_B_READ
0007f0  8842              LDRH     r2,[r0,#2]  ; Modify_A_READ
0007f2  1a89              SUBS     r1,r1,r2
0007f4  9106              STR      r1,[sp,#0x18]
;;;457    				var32a = var32a / var16;
0007f6  f8bd1018          LDRH     r1,[sp,#0x18]
0007fa  9a05              LDR      r2,[sp,#0x14]
0007fc  fbb2f1f1          UDIV     r1,r2,r1
000800  9105              STR      r1,[sp,#0x14]
;;;458    				REG_CorrectionR = var32a;
000802  9905              LDR      r1,[sp,#0x14]
000804  f8a81006          STRH     r1,[r8,#6]
;;;459    				var32a=0;
;;;460    				var32a = Modify_B_ACT;
000808  8981              LDRH     r1,[r0,#0xc]  ; Modify_B_ACT
00080a  9105              STR      r1,[sp,#0x14]
;;;461    				var32a = var32a << 12;
00080c  9905              LDR      r1,[sp,#0x14]
00080e  0309              LSLS     r1,r1,#12
000810  9105              STR      r1,[sp,#0x14]
;;;462    				var32b = Modify_B_READ;
000812  8900              LDRH     r0,[r0,#8]  ; Modify_B_READ
000814  9004              STR      r0,[sp,#0x10]
;;;463    				var32b = var32b * REG_CorrectionR;
000816  f8b80006          LDRH     r0,[r8,#6]  ; Correct_Parametet
00081a  9904              LDR      r1,[sp,#0x10]
00081c  4348              MULS     r0,r1,r0
00081e  9004              STR      r0,[sp,#0x10]
;;;464    				if (var32a < var32b)
000820  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000824  4281              CMP      r1,r0
000826  d20c              BCS      |L3.2114|
;;;465    				{
;;;466    					var32b = var32b - var32a;
000828  e9dd0104          LDRD     r0,r1,[sp,#0x10]
00082c  1a40              SUBS     r0,r0,r1
00082e  9004              STR      r0,[sp,#0x10]
;;;467    					REG_ReadR_Offset = var32b;
000830  9804              LDR      r0,[sp,#0x10]
000832  60e0              STR      r0,[r4,#0xc]  ; Correct_Strong
;;;468    					Polar3 |= 0x01;
000834  f8b80016          LDRH     r0,[r8,#0x16]  ; Correct_Parametet
000838  f0400001          ORR      r0,r0,#1
00083c  f8a80016          STRH     r0,[r8,#0x16]
000840  e00b              B        |L3.2138|
                  |L3.2114|
;;;469    				}
;;;470    				else 
;;;471    				{
;;;472    					var32a = var32a - var32b;
000842  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000846  1a40              SUBS     r0,r0,r1
000848  9005              STR      r0,[sp,#0x14]
;;;473    					REG_ReadR_Offset = var32a;
00084a  9805              LDR      r0,[sp,#0x14]
00084c  60e0              STR      r0,[r4,#0xc]  ; Correct_Strong
;;;474    					Polar3 &= ~0x01;
00084e  f8b80016          LDRH     r0,[r8,#0x16]  ; Correct_Parametet
000852  f0200001          BIC      r0,r0,#1
000856  f8a80016          STRH     r0,[r8,#0x16]
                  |L3.2138|
;;;475    				}
;;;476    	//---------------------------------------------------------------------------------------//
;;;477    				Flash_Write_all();	//参数写进FLASH
00085a  f7fffffe          BL       Flash_Write_all
;;;478    				flag_OverV=0;
00085e  6828              LDR      r0,[r5,#0]  ; flagG
000860  f0200002          BIC      r0,r0,#2
000864  6028              STR      r0,[r5,#0]  ; flagG
;;;479    				Flag_DAC_OFF=0;
000866  6830              LDR      r0,[r6,#0]  ; flagB
000868  f0200008          BIC      r0,r0,#8
00086c  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.2158|
;;;480    			}
;;;481    			flag_ADJ_VH=0;//清掉标志位防止一直进入
00086e  6838              LDR      r0,[r7,#0]  ; flagF
000870  f0200008          BIC      r0,r0,#8
000874  6038              STR      r0,[r7,#0]  ; flagF
                  |L3.2166|
;;;482    		}	
;;;483    /***********??DAC*******************************************/
;;;484    		if (g_tModS.RxBuf[1] == 0x0F)			   
000876  4918              LDR      r1,|L3.2264|
000878  7848              LDRB     r0,[r1,#1]  ; g_tModS
00087a  280f              CMP      r0,#0xf
00087c  d109              BNE      |L3.2194|
;;;485    		{
;;;486    			Contr_Laod = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
00087e  790a              LDRB     r2,[r1,#4]  ; g_tModS
000880  78cb              LDRB     r3,[r1,#3]  ; g_tModS
000882  eb022203          ADD      r2,r2,r3,LSL #8
000886  f8a92000          STRH     r2,[r9,#0]
;;;487    			Flag_DAC_OFF=1;
00088a  6832              LDR      r2,[r6,#0]  ; flagB
00088c  f0420208          ORR      r2,r2,#8
000890  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2194|
;;;488    		}
;;;489    		if (g_tModS.RxBuf[1] == 0x20)			   
000892  2820              CMP      r0,#0x20
000894  d109              BNE      |L3.2218|
;;;490    		{
;;;491    			Contr_Voltage = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
000896  790a              LDRB     r2,[r1,#4]  ; g_tModS
000898  78cb              LDRB     r3,[r1,#3]  ; g_tModS
00089a  eb022203          ADD      r2,r2,r3,LSL #8
00089e  f8aa2000          STRH     r2,[r10,#0]
;;;492    			Flag_DAC_OFF=1;
0008a2  6832              LDR      r2,[r6,#0]  ; flagB
0008a4  f0420208          ORR      r2,r2,#8
0008a8  6032              STR      r2,[r6,#0]  ; flagB
                  |L3.2218|
;;;493    		}
;;;494    		if (g_tModS.RxBuf[1] == 0x21)			   
0008aa  2821              CMP      r0,#0x21
0008ac  d109              BNE      |L3.2242|
;;;495    		{
;;;496    			Contr_Current = (g_tModS.RxBuf[3] << 8) + g_tModS.RxBuf[4];
0008ae  7908              LDRB     r0,[r1,#4]  ; g_tModS
0008b0  78c9              LDRB     r1,[r1,#3]  ; g_tModS
0008b2  eb002001          ADD      r0,r0,r1,LSL #8
0008b6  f8ab0000          STRH     r0,[r11,#0]
;;;497    			Flag_DAC_OFF=1;
0008ba  6830              LDR      r0,[r6,#0]  ; flagB
0008bc  f0400008          ORR      r0,r0,#8
0008c0  6030              STR      r0,[r6,#0]  ; flagB
                  |L3.2242|
;;;498    		}		
;;;499        }
;;;500    }
0008c2  b007              ADD      sp,sp,#0x1c
0008c4  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.2248|
                          DCD      Vmon1_value
                  |L3.2252|
                          DCD      Contr_Voltage
                  |L3.2256|
                          DCD      Imon_value
                  |L3.2260|
                          DCD      Contr_Current
                  |L3.2264|
                          DCD      g_tModS
                  |L3.2268|
                          DCD      Rmon_value
                  |L3.2272|
                          DCD      flagG
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        28
                  Correct_Strong
                          %        40
                  Run_Control
                          %        86

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.data||
                  ADDR
000000  0000              DCB      0x00,0x00
                  Modify_A_READ
000002  0000              DCB      0x00,0x00
                  Modify_C_READ
000004  0000              DCB      0x00,0x00
                  Modify_A_ACT
000006  0000              DCB      0x00,0x00
                  Modify_B_READ
000008  0000              DCB      0x00,0x00
                  Modify_D_READ
00000a  0000              DCB      0x00,0x00
                  Modify_B_ACT
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 129 "D:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 144
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
