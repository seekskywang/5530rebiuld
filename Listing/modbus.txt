; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\modbus.crf ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;369    //-----------------------------CRC检测--------------------------------------------//
;;;370    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b530              PUSH     {r4,r5,lr}
;;;371    {
000002  4603              MOV      r3,r0
;;;372    	vu16 CRC_Result=0xffff;
000004  f64f70ff          MOV      r0,#0xffff
;;;373    	vu8 i;
;;;374    	if(count==0)
000008  b901              CBNZ     r1,|L1.12|
;;;375    	{
;;;376    		count=1;
00000a  2101              MOVS     r1,#1
                  |L1.12|
;;;377    	}
;;;378    	while(count--)
;;;379    	{
;;;380    		CRC_Result^=*p_buffer;
;;;381    		for(i=0;i<8;i++)
;;;382    		{
;;;383    			if(CRC_Result&1)
;;;384    			{
;;;385    				CRC_Result>>=1;
;;;386    				CRC_Result^=0xA001;
00000c  f24a0401          MOV      r4,#0xa001
;;;387    			}
;;;388    			else 
;;;389    			{
;;;390    				CRC_Result>>=1;
;;;391    			}
;;;392    		}
;;;393    		p_buffer++;
000010  e00e              B        |L1.48|
                  |L1.18|
000012  781a              LDRB     r2,[r3,#0]            ;380
000014  4050              EORS     r0,r0,r2              ;380
000016  2200              MOVS     r2,#0                 ;381
000018  e007              B        |L1.42|
                  |L1.26|
00001a  07c5              LSLS     r5,r0,#31             ;383
00001c  d002              BEQ      |L1.36|
00001e  0840              LSRS     r0,r0,#1              ;385
000020  4060              EORS     r0,r0,r4              ;386
000022  e000              B        |L1.38|
                  |L1.36|
000024  0840              LSRS     r0,r0,#1              ;390
                  |L1.38|
000026  1c52              ADDS     r2,r2,#1              ;381
000028  b2d2              UXTB     r2,r2                 ;381
                  |L1.42|
00002a  2a08              CMP      r2,#8                 ;381
00002c  d3f5              BCC      |L1.26|
00002e  1c5b              ADDS     r3,r3,#1
                  |L1.48|
000030  000a              MOVS     r2,r1                 ;378
000032  f1a10101          SUB      r1,r1,#1              ;378
000036  b2c9              UXTB     r1,r1                 ;378
000038  d1eb              BNE      |L1.18|
;;;394    	}
;;;395    	return CRC_Result;
;;;396    }
00003a  bd30              POP      {r4,r5,pc}
;;;397    
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;195    //===============================AD值转换成测量值============================================//
;;;196    void Transformation_ADC(void)  
000000  b570              PUSH     {r4-r6,lr}
;;;197    {
;;;198    	vu32 var32;
;;;199    	vu32 var32a;
;;;200    /*****************************测量电压转换*******************************************/
;;;201    	var32 = Vmon_value;
000002  4874              LDR      r0,|L2.468|
000004  8800              LDRH     r0,[r0,#0]  ; Vmon_value
;;;202    	var32 = var32 * REG_CorrectionV;  
000006  4a74              LDR      r2,|L2.472|
000008  8811              LDRH     r1,[r2,#0]  ; Correct_Parametet
00000a  4341              MULS     r1,r0,r1
;;;203    	if ((Polar & 0x01) == 0x01)		  
00000c  8910              LDRH     r0,[r2,#8]  ; Correct_Parametet
00000e  07c3              LSLS     r3,r0,#31
;;;204    	{
;;;205    		if (var32 < REG_ReadV_Offset) 
000010  f102001c          ADD      r0,r2,#0x1c
000014  d007              BEQ      |L2.38|
000016  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000018  428b              CMP      r3,r1
00001a  d901              BLS      |L2.32|
;;;206    		{
;;;207    			var32 = 0;
00001c  2100              MOVS     r1,#0
00001e  e004              B        |L2.42|
                  |L2.32|
;;;208    		}
;;;209    		else var32 = var32 - REG_ReadV_Offset;
000020  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000022  1ac9              SUBS     r1,r1,r3
000024  e001              B        |L2.42|
                  |L2.38|
;;;210    	}
;;;211    	else var32 = var32 + REG_ReadV_Offset;
000026  6803              LDR      r3,[r0,#0]  ; Correct_Strong
000028  4419              ADD      r1,r1,r3
                  |L2.42|
;;;212    	var32 = var32 >> 12;
00002a  0b09              LSRS     r1,r1,#12
;;;213    	if (var32 < 5) var32 = 0;				  //40mV以下清零
00002c  2905              CMP      r1,#5
00002e  d200              BCS      |L2.50|
000030  2100              MOVS     r1,#0
                  |L2.50|
;;;214    	Voltage = var32;
000032  4b69              LDR      r3,|L2.472|
000034  3340              ADDS     r3,r3,#0x40
000036  8299              STRH     r1,[r3,#0x14]
;;;215    	DISS_Voltage=Voltage;
000038  8a99              LDRH     r1,[r3,#0x14]  ; Run_Control
00003a  ee001a10          VMOV     s0,r1
00003e  4967              LDR      r1,|L2.476|
000040  eeb80a40          VCVT.F32.U32 s0,s0
;;;216    	DISS_Voltage=DISS_Voltage/100;//计算显示电压
000044  eddf0a66          VLDR     s1,|L2.480|
000048  ee801a20          VDIV.F32 s2,s0,s1
00004c  ed811a00          VSTR     s2,[r1,#0]
;;;217    	var32 = 0;
;;;218    /*****************************稳压电源测量电压转换*******************************************/
;;;219    	var32 = Vmon1_value;
000050  4964              LDR      r1,|L2.484|
000052  880c              LDRH     r4,[r1,#0]  ; Vmon1_value
;;;220    	var32 = var32 * REG_CorrectionV1;  
000054  8b11              LDRH     r1,[r2,#0x18]  ; Correct_Parametet
000056  4361              MULS     r1,r4,r1
;;;221    	if ((Polar3 & 0x01) == 0x01)		  
000058  8ad4              LDRH     r4,[r2,#0x16]  ; Correct_Parametet
00005a  07e4              LSLS     r4,r4,#31
00005c  d007              BEQ      |L2.110|
;;;222    	{
;;;223    		if (var32 < REG_ReadV1_Offset) 
00005e  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000060  428c              CMP      r4,r1
000062  d901              BLS      |L2.104|
;;;224    		{
;;;225    			var32 = 0;
000064  2100              MOVS     r1,#0
000066  e004              B        |L2.114|
                  |L2.104|
;;;226    		}
;;;227    		else var32 = var32 - REG_ReadV1_Offset;
000068  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
00006a  1b09              SUBS     r1,r1,r4
00006c  e001              B        |L2.114|
                  |L2.110|
;;;228    	}
;;;229    	else var32 = var32 + REG_ReadV1_Offset;
00006e  6a04              LDR      r4,[r0,#0x20]  ; Correct_Strong
000070  4421              ADD      r1,r1,r4
                  |L2.114|
;;;230    	var32 = var32 >> 14;
000072  0b89              LSRS     r1,r1,#14
;;;231    	if (var32 < 5) var32 = 0;				  //40mV以下清零
000074  2905              CMP      r1,#5
000076  d200              BCS      |L2.122|
000078  2100              MOVS     r1,#0
                  |L2.122|
;;;232    	POW_Voltage = var32;
00007a  8259              STRH     r1,[r3,#0x12]
;;;233    	DISS_POW_Voltage=POW_Voltage;
00007c  8a59              LDRH     r1,[r3,#0x12]  ; Run_Control
00007e  ee001a10          VMOV     s0,r1
000082  4959              LDR      r1,|L2.488|
000084  eeb80a40          VCVT.F32.U32 s0,s0
;;;234    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
000088  ee801a20          VDIV.F32 s2,s0,s1
00008c  ed811a00          VSTR     s2,[r1,#0]
;;;235    	var32 = 0;
;;;236    /*****************************内阻值转换*******************************************/
;;;237    // 	var32 = Rmon_value;
;;;238    // 	var32 = var32 * 6040;  
;;;239    // // 	if ((Polar1 & 0x04) == 0x04)		  
;;;240    // // 	{
;;;241    // 		if (var32 < 38926) 
;;;242    // 		{
;;;243    // 			var32 = 0;
;;;244    // 		}
;;;245    // 		else {
;;;246    //             var32 = var32 - 38926;
;;;247    //         }
;;;248    // // 	}
;;;249    // // 	else var32 = var32 + REG_ReadR_Offset;
;;;250    // // 	var32 = var32 >> 12;
;;;251    // 	if (var32 < 5) var32 = 0;				  //40mV以下清零
;;;252    // 	R_VLUE = var32/10000;
;;;253    // 	var32 = 0;	
;;;254        var32 = Rmon_value;
000090  4956              LDR      r1,|L2.492|
000092  880c              LDRH     r4,[r1,#0]  ; Rmon_value
;;;255    	var32 = var32 * REG_CorrectionR;  
000094  88d1              LDRH     r1,[r2,#6]  ; Correct_Parametet
000096  4361              MULS     r1,r4,r1
;;;256    	if ((Polar1 & 0x04) == 0x04)		  
000098  8a54              LDRH     r4,[r2,#0x12]  ; Correct_Parametet
00009a  0764              LSLS     r4,r4,#29
00009c  d507              BPL      |L2.174|
;;;257    	{
;;;258    		if (var32 < REG_ReadR_Offset) 
00009e  68c4              LDR      r4,[r0,#0xc]  ; Correct_Strong
0000a0  428c              CMP      r4,r1
0000a2  d901              BLS      |L2.168|
;;;259    		{
;;;260    			var32 = 0;
0000a4  2100              MOVS     r1,#0
0000a6  e004              B        |L2.178|
                  |L2.168|
;;;261    		}
;;;262    		else var32 = var32 - REG_ReadR_Offset;
0000a8  68c4              LDR      r4,[r0,#0xc]  ; Correct_Strong
0000aa  1b09              SUBS     r1,r1,r4
0000ac  e001              B        |L2.178|
                  |L2.174|
;;;263    	}
;;;264    	else var32 = var32 + REG_ReadR_Offset;
0000ae  68c4              LDR      r4,[r0,#0xc]  ; Correct_Strong
0000b0  4421              ADD      r1,r1,r4
                  |L2.178|
;;;265    	var32 = var32 >> 12;
0000b2  0b09              LSRS     r1,r1,#12
;;;266    	if (var32 < 5) var32 = 0;				  //40mV以下清零
0000b4  2905              CMP      r1,#5
0000b6  d200              BCS      |L2.186|
0000b8  2100              MOVS     r1,#0
                  |L2.186|
;;;267    	R_VLUE = var32;
0000ba  8359              STRH     r1,[r3,#0x1a]
;;;268    	var32 = 0;	
;;;269        
;;;270    /*****************************稳压电源测量电流转换*******************************************/
;;;271    	var32 = Imon_value;
0000bc  494c              LDR      r1,|L2.496|
0000be  880c              LDRH     r4,[r1,#0]  ; Imon_value
;;;272    	var32 = var32 * CON_CorrectionA;	   
0000c0  8a11              LDRH     r1,[r2,#0x10]  ; Correct_Parametet
0000c2  4361              MULS     r1,r4,r1
;;;273    	if ((Polar2 & 0x01) == 0x01)			   
0000c4  8a94              LDRH     r4,[r2,#0x14]  ; Correct_Parametet
0000c6  07e4              LSLS     r4,r4,#31
0000c8  d007              BEQ      |L2.218|
;;;274    	{
;;;275    		if (var32 < CON_ReadA_Offset) var32 = 0;
0000ca  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000cc  428c              CMP      r4,r1
0000ce  d901              BLS      |L2.212|
0000d0  2100              MOVS     r1,#0
0000d2  e004              B        |L2.222|
                  |L2.212|
;;;276    		else var32 = var32 - CON_ReadA_Offset;
0000d4  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000d6  1b09              SUBS     r1,r1,r4
0000d8  e001              B        |L2.222|
                  |L2.218|
;;;277    	}
;;;278    	else
;;;279    	{
;;;280    		var32 = var32 + CON_ReadA_Offset;
0000da  69c4              LDR      r4,[r0,#0x1c]  ; Correct_Strong
0000dc  4421              ADD      r1,r1,r4
                  |L2.222|
;;;281    	}	
;;;282    	var32 = var32 >> 12;
0000de  0b09              LSRS     r1,r1,#12
;;;283    	Current = var32;;
0000e0  82d9              STRH     r1,[r3,#0x16]
;;;284    	DISS_POW_Current=Current;
0000e2  8ad9              LDRH     r1,[r3,#0x16]  ; Run_Control
0000e4  ee001a10          VMOV     s0,r1
0000e8  4942              LDR      r1,|L2.500|
0000ea  eeb80a40          VCVT.F32.U32 s0,s0
;;;285    	DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0000ee  ed9f1a42          VLDR     s2,|L2.504|
0000f2  eec01a01          VDIV.F32 s3,s0,s2
0000f6  edc11a00          VSTR     s3,[r1,#0]
;;;286    /**************************稳压电源设置电压转换******************************************/
;;;287    	var32 = SET_Voltage;
0000fa  8859              LDRH     r1,[r3,#2]  ; Run_Control
;;;288    	var32=var32<<14;   
0000fc  0389              LSLS     r1,r1,#14
;;;289    	if ((Polar1 & 0x01) == 0)			   
0000fe  8a54              LDRH     r4,[r2,#0x12]  ; Correct_Parametet
000100  07e4              LSLS     r4,r4,#31
000102  d00b              BEQ      |L2.284|
;;;290    	{
;;;291    		if (var32 < SET_ReadV_Offset) var32 = 0;
;;;292    		else var32 = var32 - SET_ReadV_Offset;
;;;293    	}
;;;294    	else var32 = var32 + SET_ReadV_Offset;
000104  6904              LDR      r4,[r0,#0x10]  ; Correct_Strong
000106  4421              ADD      r1,r1,r4
                  |L2.264|
;;;295    	var32 = var32/SET_CorrectionV;
000108  8954              LDRH     r4,[r2,#0xa]  ; Correct_Parametet
00010a  fbb1f1f4          UDIV     r1,r1,r4
;;;296    	var32=var32>>1;
00010e  0849              LSRS     r1,r1,#1
;;;297    	Contr_Voltage = var32;
000110  4d3a              LDR      r5,|L2.508|
000112  8029              STRH     r1,[r5,#0]
;;;298    	if(SET_Voltage==0)
000114  8859              LDRH     r1,[r3,#2]  ; Run_Control
000116  2400              MOVS     r4,#0                 ;207
000118  b141              CBZ      r1,|L2.300|
00011a  e008              B        |L2.302|
                  |L2.284|
00011c  6904              LDR      r4,[r0,#0x10]         ;291  ; Correct_Strong
00011e  428c              CMP      r4,r1                 ;291
000120  d901              BLS      |L2.294|
000122  2100              MOVS     r1,#0                 ;291
000124  e7f0              B        |L2.264|
                  |L2.294|
000126  6904              LDR      r4,[r0,#0x10]         ;292  ; Correct_Strong
000128  1b09              SUBS     r1,r1,r4              ;292
00012a  e7ed              B        |L2.264|
                  |L2.300|
;;;299    	{
;;;300    		Contr_Voltage=0;
00012c  802c              STRH     r4,[r5,#0]
                  |L2.302|
;;;301    	}
;;;302    	var32 = 0;
;;;303    /**************************稳压电源设置电流转换**************************************/
;;;304    	var32 = SET_Current;
00012e  8899              LDRH     r1,[r3,#4]  ; Run_Control
;;;305    	var32=var32<<14;   
000130  0389              LSLS     r1,r1,#14
;;;306    	if ((Polar1 & 0x08) == 0)			   
000132  8a55              LDRH     r5,[r2,#0x12]  ; Correct_Parametet
000134  072d              LSLS     r5,r5,#28
000136  d407              BMI      |L2.328|
;;;307    	{
;;;308    		if (var32 < SET_ReadA_Offset) var32 = 0;
000138  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
00013a  428d              CMP      r5,r1
00013c  d901              BLS      |L2.322|
00013e  2100              MOVS     r1,#0
000140  e004              B        |L2.332|
                  |L2.322|
;;;309    		else var32 = var32 - SET_ReadA_Offset;
000142  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
000144  1b49              SUBS     r1,r1,r5
000146  e001              B        |L2.332|
                  |L2.328|
;;;310    	}
;;;311    	else var32 = var32 + SET_ReadA_Offset;
000148  6945              LDR      r5,[r0,#0x14]  ; Correct_Strong
00014a  4429              ADD      r1,r1,r5
                  |L2.332|
;;;312    	var32 = var32/SET_CorrectionA;
00014c  8995              LDRH     r5,[r2,#0xc]  ; Correct_Parametet
00014e  fbb1f1f5          UDIV     r1,r1,r5
;;;313    	var32=var32>>1;
000152  0849              LSRS     r1,r1,#1
;;;314    	Contr_Current = var32;
000154  4d2a              LDR      r5,|L2.512|
000156  8029              STRH     r1,[r5,#0]
;;;315    	if(SET_Current==0)
000158  8899              LDRH     r1,[r3,#4]  ; Run_Control
00015a  b901              CBNZ     r1,|L2.350|
;;;316    	{
;;;317    		Contr_Current=0;
00015c  802c              STRH     r4,[r5,#0]
                  |L2.350|
;;;318    	}
;;;319    	
;;;320    	var32 = 0;
;;;321    
;;;322    /*************************负载电流控制转换**************************************/
;;;323    	var32 = SET_Current_Laod;
00015e  8919              LDRH     r1,[r3,#8]  ; Run_Control
;;;324    	var32=var32<<12;   
000160  0309              LSLS     r1,r1,#12
;;;325    	if ((Polar2 & 0x08) == 0)			   
000162  8a95              LDRH     r5,[r2,#0x14]  ; Correct_Parametet
000164  072d              LSLS     r5,r5,#28
000166  d407              BMI      |L2.376|
;;;326    	{
;;;327    		if (var32 < SET_ReadA1_Offset) var32 = 0;
000168  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
00016a  428d              CMP      r5,r1
00016c  d901              BLS      |L2.370|
00016e  2100              MOVS     r1,#0
000170  e004              B        |L2.380|
                  |L2.370|
;;;328    		else var32 = var32 - SET_ReadA1_Offset;
000172  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
000174  1b49              SUBS     r1,r1,r5
000176  e001              B        |L2.380|
                  |L2.376|
;;;329    	}
;;;330    	else var32 = var32 + SET_ReadA1_Offset;
000178  6985              LDR      r5,[r0,#0x18]  ; Correct_Strong
00017a  4429              ADD      r1,r1,r5
                  |L2.380|
;;;331    	var32 = var32/SET_CorrectionA1;
00017c  89d5              LDRH     r5,[r2,#0xe]  ; Correct_Parametet
00017e  fbb1f1f5          UDIV     r1,r1,r5
;;;332    	var32=var32>>1;
000182  0849              LSRS     r1,r1,#1
;;;333    	if(Flag_DAC_OFF==0)
000184  4d1f              LDR      r5,|L2.516|
000186  682d              LDR      r5,[r5,#0]  ; flagB
000188  072e              LSLS     r6,r5,#28
;;;334    	{
;;;335    		Contr_Laod = var32;
00018a  4d1f              LDR      r5,|L2.520|
00018c  d400              BMI      |L2.400|
00018e  8029              STRH     r1,[r5,#0]
                  |L2.400|
;;;336    	}
;;;337    	if(SET_Current_Laod==0)
000190  8919              LDRH     r1,[r3,#8]  ; Run_Control
000192  b901              CBNZ     r1,|L2.406|
;;;338    	{
;;;339    		Contr_Laod=0;
000194  802c              STRH     r4,[r5,#0]
                  |L2.406|
;;;340    	}
;;;341    	
;;;342    	var32 = 0;
;;;343    /*******************负载测量电流转换**************************************/
;;;344    	var32 = Imon1_value;
000196  491d              LDR      r1,|L2.524|
000198  880c              LDRH     r4,[r1,#0]  ; Imon1_value
;;;345    	var32 = var32 * REG_CorrectionA1;  
00019a  8891              LDRH     r1,[r2,#4]  ; Correct_Parametet
00019c  4361              MULS     r1,r4,r1
;;;346    	if ((Polar2 & 0x04) == 0x04)		  
00019e  8a92              LDRH     r2,[r2,#0x14]  ; Correct_Parametet
0001a0  0752              LSLS     r2,r2,#29
0001a2  d507              BPL      |L2.436|
;;;347    	{
;;;348    		if (var32 < REG_ReadA1_Offset) 
0001a4  6882              LDR      r2,[r0,#8]  ; Correct_Strong
0001a6  428a              CMP      r2,r1
0001a8  d901              BLS      |L2.430|
;;;349    		{
;;;350    			var32 = 0;
0001aa  2000              MOVS     r0,#0
0001ac  e004              B        |L2.440|
                  |L2.430|
;;;351    		}
;;;352    		else var32 = var32 - REG_ReadA1_Offset;
0001ae  6880              LDR      r0,[r0,#8]  ; Correct_Strong
0001b0  1a08              SUBS     r0,r1,r0
0001b2  e001              B        |L2.440|
                  |L2.436|
;;;353    	}
;;;354    	else var32 = var32 + REG_ReadA1_Offset;
0001b4  6880              LDR      r0,[r0,#8]  ; Correct_Strong
0001b6  4408              ADD      r0,r0,r1
                  |L2.440|
;;;355    	var32 = var32 >> 12;
0001b8  0b00              LSRS     r0,r0,#12
;;;356    	Laod_Current = var32;
0001ba  8318              STRH     r0,[r3,#0x18]
;;;357    	DISS_Current=Laod_Current;
0001bc  8b18              LDRH     r0,[r3,#0x18]  ; Run_Control
0001be  ee000a10          VMOV     s0,r0
0001c2  4813              LDR      r0,|L2.528|
0001c4  eeb80a40          VCVT.F32.U32 s0,s0
;;;358    	DISS_Current=DISS_Current/100;//计算显示电流
0001c8  ee801a20          VDIV.F32 s2,s0,s1
0001cc  ed801a00          VSTR     s2,[r0,#0]
;;;359    	var32 = 0;		
;;;360    	
;;;361    }
0001d0  bd70              POP      {r4-r6,pc}
;;;362    /********************************************************************************
                          ENDP

0001d2  0000              DCW      0x0000
                  |L2.468|
                          DCD      Vmon_value
                  |L2.472|
                          DCD      ||.bss||
                  |L2.476|
                          DCD      DISS_Voltage
                  |L2.480|
0001e0  42c80000          DCFS     0x42c80000 ; 100
                  |L2.484|
                          DCD      Vmon1_value
                  |L2.488|
                          DCD      DISS_POW_Voltage
                  |L2.492|
                          DCD      Rmon_value
                  |L2.496|
                          DCD      Imon_value
                  |L2.500|
                          DCD      DISS_POW_Current
                  |L2.504|
0001f8  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.508|
                          DCD      Contr_Voltage
                  |L2.512|
                          DCD      Contr_Current
                  |L2.516|
                          DCD      flagB
                  |L2.520|
                          DCD      Contr_Laod
                  |L2.524|
                          DCD      Imon1_value
                  |L2.528|
                          DCD      DISS_Current

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;43     //===========================MODBUS协议=============================//
;;;44     void UART_Action(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;45     {//RUT格式：
;;;46     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;47     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;48     	if (UART_Buffer_Rece[0] == ADDR)
000004  4e9e              LDR      r6,|L3.640|
000006  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
000008  4c9e              LDR      r4,|L3.644|
00000a  7821              LDRB     r1,[r4,#0]  ; ADDR
;;;49     	{
;;;50     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;51     		{																		 
;;;52     			vu8 i;
;;;53     			vu16 crc_result;
;;;54     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;55     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;56     			{
;;;57     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;58     				{
;;;59     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;60     					{							
;;;61     						UART_Buffer_Send[0] = ADDR;
00000c  4f9e              LDR      r7,|L3.648|
;;;62     						UART_Buffer_Send[1] = 0x03;
;;;63     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;64     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;65     						{
;;;66     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;67     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;68     						}
;;;69     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;70     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;71     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;72     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
00000e  f8dfa27c          LDR      r10,|L3.652|
;;;73     						UART_SEND_flag=1;
000012  f8df827c          LDR      r8,|L3.656|
000016  f8df927c          LDR      r9,|L3.660|
00001a  4288              CMP      r0,r1                 ;48
00001c  d145              BNE      |L3.170|
00001e  7870              LDRB     r0,[r6,#1]            ;50  ; UART_Buffer_Rece
000020  2803              CMP      r0,#3                 ;50
000022  d142              BNE      |L3.170|
000024  79f0              LDRB     r0,[r6,#7]            ;54  ; UART_Buffer_Rece
000026  79b1              LDRB     r1,[r6,#6]            ;54  ; UART_Buffer_Rece
000028  eb002001          ADD      r0,r0,r1,LSL #8       ;54
00002c  b285              UXTH     r5,r0                 ;54
00002e  2106              MOVS     r1,#6                 ;55
000030  4630              MOV      r0,r6                 ;55
000032  f7fffffe          BL       Hardware_CRC
000036  42a8              CMP      r0,r5                 ;55
000038  d000              BEQ      |L3.60|
00003a  bbb5              CBNZ     r5,|L3.170|
                  |L3.60|
00003c  78f0              LDRB     r0,[r6,#3]            ;57  ; UART_Buffer_Rece
00003e  2807              CMP      r0,#7                 ;57
000040  d233              BCS      |L3.170|
000042  78f0              LDRB     r0,[r6,#3]            ;59  ; UART_Buffer_Rece
000044  7971              LDRB     r1,[r6,#5]            ;59  ; UART_Buffer_Rece
000046  4408              ADD      r0,r0,r1              ;59
000048  280f              CMP      r0,#0xf               ;59
00004a  d22e              BCS      |L3.170|
00004c  7820              LDRB     r0,[r4,#0]            ;61  ; ADDR
00004e  7038              STRB     r0,[r7,#0]            ;61
000050  2003              MOVS     r0,#3                 ;62
000052  7078              STRB     r0,[r7,#1]            ;62
000054  7970              LDRB     r0,[r6,#5]            ;63  ; UART_Buffer_Rece
000056  0040              LSLS     r0,r0,#1              ;63
000058  70b8              STRB     r0,[r7,#2]            ;63
00005a  2000              MOVS     r0,#0                 ;64
00005c  e00a              B        |L3.116|
                  |L3.94|
00005e  07c1              LSLS     r1,r0,#31             ;66
000060  d03a              BEQ      |L3.216|
000062  78f1              LDRB     r1,[r6,#3]            ;67  ; UART_Buffer_Rece
000064  eb010150          ADD      r1,r1,r0,LSR #1       ;67
000068  f8391011          LDRH     r1,[r9,r1,LSL #1]     ;67
00006c  183a              ADDS     r2,r7,r0              ;67
00006e  70d1              STRB     r1,[r2,#3]            ;67
                  |L3.112|
000070  1c40              ADDS     r0,r0,#1              ;64
000072  b2c0              UXTB     r0,r0                 ;64
                  |L3.116|
000074  78b9              LDRB     r1,[r7,#2]            ;64  ; UART_Buffer_Send
000076  4281              CMP      r1,r0                 ;64
000078  d8f1              BHI      |L3.94|
00007a  78b8              LDRB     r0,[r7,#2]            ;69  ; UART_Buffer_Send
00007c  1cc0              ADDS     r0,r0,#3              ;69
00007e  b2c1              UXTB     r1,r0                 ;69
000080  4881              LDR      r0,|L3.648|
000082  f7fffffe          BL       Hardware_CRC
000086  78bb              LDRB     r3,[r7,#2]            ;70  ; UART_Buffer_Send
000088  0a02              LSRS     r2,r0,#8              ;70
00008a  497f              LDR      r1,|L3.648|
00008c  1cc9              ADDS     r1,r1,#3              ;70
00008e  545a              STRB     r2,[r3,r1]            ;70
000090  78ba              LDRB     r2,[r7,#2]            ;71  ; UART_Buffer_Send
000092  1c49              ADDS     r1,r1,#1              ;71
000094  5450              STRB     r0,[r2,r1]            ;71
000096  78b8              LDRB     r0,[r7,#2]            ;72  ; UART_Buffer_Send
000098  1d40              ADDS     r0,r0,#5              ;72
00009a  f88a0000          STRB     r0,[r10,#0]           ;72
00009e  f8d80000          LDR      r0,[r8,#0]  ; flagA
0000a2  f0400010          ORR      r0,r0,#0x10
0000a6  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.170|
;;;74     					}
;;;75     				}
;;;76     			}	
;;;77     		}
;;;78     	} 
;;;79     //===============================写寄存器=================================
;;;80     	if ((UART_Buffer_Rece[0] == 0) || (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000aa  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
0000ac  b170              CBZ      r0,|L3.204|
0000ae  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
0000b0  7821              LDRB     r1,[r4,#0]  ; ADDR
0000b2  4288              CMP      r0,r1
0000b4  d00a              BEQ      |L3.204|
0000b6  7820              LDRB     r0,[r4,#0]  ; ADDR
0000b8  1e40              SUBS     r0,r0,#1
0000ba  17c1              ASRS     r1,r0,#31
0000bc  eb007091          ADD      r0,r0,r1,LSR #30
0000c0  2164              MOVS     r1,#0x64
0000c2  eb0100a0          ADD      r0,r1,r0,ASR #2
0000c6  7831              LDRB     r1,[r6,#0]  ; UART_Buffer_Rece
0000c8  4288              CMP      r0,r1
0000ca  d179              BNE      |L3.448|
                  |L3.204|
;;;81     	{
;;;82     		vu8 var8;
;;;83     		vu8 a=0;
;;;84     		vu16 var16;
;;;85     		vu16 crc_result;
;;;86     //=========================以下命令6 写单个寄存器===========================
;;;87     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
0000cc  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
;;;88     		{
;;;89     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;90     			{
;;;91     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;92     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;93     				{
;;;94     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;95     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;96     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;97     
;;;98     					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;99     					{
;;;100    						for (a=0;a<8;a++)
;;;101    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;102    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
0000ce  f04f0b08          MOV      r11,#8
0000d2  2806              CMP      r0,#6                 ;87
0000d4  d009              BEQ      |L3.234|
0000d6  e032              B        |L3.318|
                  |L3.216|
0000d8  78f1              LDRB     r1,[r6,#3]            ;66  ; UART_Buffer_Rece
0000da  eb010150          ADD      r1,r1,r0,LSR #1       ;66
0000de  f8391011          LDRH     r1,[r9,r1,LSL #1]     ;66
0000e2  0a09              LSRS     r1,r1,#8              ;66
0000e4  183a              ADDS     r2,r7,r0              ;66
0000e6  70d1              STRB     r1,[r2,#3]            ;66
0000e8  e7c2              B        |L3.112|
                  |L3.234|
0000ea  78f0              LDRB     r0,[r6,#3]            ;89  ; UART_Buffer_Rece
0000ec  2805              CMP      r0,#5                 ;89
0000ee  d226              BCS      |L3.318|
0000f0  79f0              LDRB     r0,[r6,#7]            ;91  ; UART_Buffer_Rece
0000f2  79b1              LDRB     r1,[r6,#6]            ;91  ; UART_Buffer_Rece
0000f4  eb002001          ADD      r0,r0,r1,LSL #8       ;91
0000f8  b285              UXTH     r5,r0                 ;91
0000fa  2106              MOVS     r1,#6                 ;92
0000fc  4860              LDR      r0,|L3.640|
0000fe  f7fffffe          BL       Hardware_CRC
000102  42a8              CMP      r0,r5                 ;92
000104  d000              BEQ      |L3.264|
000106  b9d5              CBNZ     r5,|L3.318|
                  |L3.264|
000108  7970              LDRB     r0,[r6,#5]            ;94  ; UART_Buffer_Rece
00010a  7931              LDRB     r1,[r6,#4]            ;94  ; UART_Buffer_Rece
00010c  eb002001          ADD      r0,r0,r1,LSL #8       ;94
000110  78f1              LDRB     r1,[r6,#3]            ;95  ; UART_Buffer_Rece
000112  f8290011          STRH     r0,[r9,r1,LSL #1]     ;96
000116  7830              LDRB     r0,[r6,#0]            ;98  ; UART_Buffer_Rece
000118  7821              LDRB     r1,[r4,#0]            ;98  ; ADDR
00011a  4288              CMP      r0,r1                 ;98
00011c  d10f              BNE      |L3.318|
00011e  2000              MOVS     r0,#0                 ;100
000120  e003              B        |L3.298|
                  |L3.290|
000122  5c31              LDRB     r1,[r6,r0]            ;101
000124  5439              STRB     r1,[r7,r0]            ;101
000126  1c40              ADDS     r0,r0,#1              ;100
000128  b2c0              UXTB     r0,r0                 ;100
                  |L3.298|
00012a  2808              CMP      r0,#8                 ;100
00012c  d3f9              BCC      |L3.290|
00012e  f88ab000          STRB     r11,[r10,#0]
;;;103    						UART_SEND_flag=1;
000132  f8d80000          LDR      r0,[r8,#0]  ; flagA
000136  f0400010          ORR      r0,r0,#0x10
00013a  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.318|
;;;104    					}
;;;105    				}
;;;106    			}
;;;107    		}
;;;108    //=======================================以下是命令16，连写寄存器===========================================
;;;109    //功能码16格式:
;;;110    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;111    //返回数据格式:
;;;112    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;113    		if (UART_Buffer_Rece[1] == 16)										  
00013e  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
000140  2810              CMP      r0,#0x10
000142  d13d              BNE      |L3.448|
;;;114    		{	
;;;115    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
000144  79b0              LDRB     r0,[r6,#6]  ; UART_Buffer_Rece
000146  2806              CMP      r0,#6
000148  d13a              BNE      |L3.448|
00014a  78f0              LDRB     r0,[r6,#3]  ; UART_Buffer_Rece
00014c  bbc0              CBNZ     r0,|L3.448|
;;;116    			{
;;;117    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
00014e  7bb0              LDRB     r0,[r6,#0xe]  ; UART_Buffer_Rece
000150  7b71              LDRB     r1,[r6,#0xd]  ; UART_Buffer_Rece
000152  eb002001          ADD      r0,r0,r1,LSL #8
000156  b285              UXTH     r5,r0
;;;118    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
000158  210d              MOVS     r1,#0xd
00015a  4849              LDR      r0,|L3.640|
00015c  f7fffffe          BL       Hardware_CRC
000160  42a8              CMP      r0,r5
000162  d000              BEQ      |L3.358|
000164  bb65              CBNZ     r5,|L3.448|
                  |L3.358|
;;;119    				{												
;;;120    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
000166  2000              MOVS     r0,#0
000168  e009              B        |L3.382|
                  |L3.362|
00016a  eb060140          ADD      r1,r6,r0,LSL #1
00016e  7a0a              LDRB     r2,[r1,#8]
000170  79c9              LDRB     r1,[r1,#7]
000172  eb022101          ADD      r1,r2,r1,LSL #8
000176  f8291010          STRH     r1,[r9,r0,LSL #1]
00017a  1c40              ADDS     r0,r0,#1
00017c  b2c0              UXTB     r0,r0
                  |L3.382|
00017e  2803              CMP      r0,#3
000180  d3f3              BCC      |L3.362|
;;;121    
;;;122    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000182  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
000184  7821              LDRB     r1,[r4,#0]  ; ADDR
000186  4288              CMP      r0,r1
000188  d11a              BNE      |L3.448|
;;;123    					{
;;;124    						UART_Buffer_Send[0] = ADDR;
00018a  7820              LDRB     r0,[r4,#0]  ; ADDR
00018c  7038              STRB     r0,[r7,#0]
;;;125    						UART_Buffer_Send[1] = 16;
00018e  2010              MOVS     r0,#0x10
000190  7078              STRB     r0,[r7,#1]
;;;126    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000192  78b0              LDRB     r0,[r6,#2]  ; UART_Buffer_Rece
000194  70b8              STRB     r0,[r7,#2]
;;;127    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
000196  78f0              LDRB     r0,[r6,#3]  ; UART_Buffer_Rece
000198  70f8              STRB     r0,[r7,#3]
;;;128    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
00019a  7930              LDRB     r0,[r6,#4]  ; UART_Buffer_Rece
00019c  7138              STRB     r0,[r7,#4]
;;;129    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
00019e  7970              LDRB     r0,[r6,#5]  ; UART_Buffer_Rece
0001a0  7178              STRB     r0,[r7,#5]
;;;130    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
0001a2  2106              MOVS     r1,#6
0001a4  4838              LDR      r0,|L3.648|
0001a6  f7fffffe          BL       Hardware_CRC
;;;131    						UART_Buffer_Send[6] = crc_result>>8;
0001aa  0a01              LSRS     r1,r0,#8
0001ac  71b9              STRB     r1,[r7,#6]
;;;132    						UART_Buffer_Send[7] = crc_result;				 
0001ae  71f8              STRB     r0,[r7,#7]
;;;133    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
0001b0  f88ab000          STRB     r11,[r10,#0]
;;;134    						UART_SEND_flag=1;
0001b4  f8d80000          LDR      r0,[r8,#0]  ; flagA
0001b8  f0400010          ORR      r0,r0,#0x10
0001bc  f8c80000          STR      r0,[r8,#0]  ; flagA
                  |L3.448|
;;;135    					}
;;;136    				}
;;;137    			}			 
;;;138    		}
;;;139    	}
;;;140    //===================================================================================
;;;141        if (((UART_Buffer_Rece[0] == 0x01)&&(UART_Buffer_Rece[2] == 0xA5))||(flag_ADJ_ON==1))			   //电压校准
0001c0  7830              LDRB     r0,[r6,#0]  ; UART_Buffer_Rece
0001c2  4d35              LDR      r5,|L3.664|
0001c4  2801              CMP      r0,#1
0001c6  d102              BNE      |L3.462|
0001c8  78b0              LDRB     r0,[r6,#2]  ; UART_Buffer_Rece
0001ca  28a5              CMP      r0,#0xa5
0001cc  d002              BEQ      |L3.468|
                  |L3.462|
0001ce  6828              LDR      r0,[r5,#0]  ; flagF
0001d0  0780              LSLS     r0,r0,#30
0001d2  d553              BPL      |L3.636|
                  |L3.468|
;;;142    	{
;;;143            /*************************************内阻校准**************************************************************************/
;;;144    		if(UART_Buffer_Rece[1] == 0x07||flag_ADJ_VL==1)
0001d4  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
;;;145    		{
;;;146    			Modify_A_READ = Rmon_value;//测量电压值
0001d6  4931              LDR      r1,|L3.668|
0001d8  2807              CMP      r0,#7                 ;144
0001da  d002              BEQ      |L3.482|
0001dc  6828              LDR      r0,[r5,#0]            ;144  ; flagF
0001de  0740              LSLS     r0,r0,#29             ;144
0001e0  d506              BPL      |L3.496|
                  |L3.482|
0001e2  8808              LDRH     r0,[r1,#0]  ; Rmon_value
0001e4  8060              STRH     r0,[r4,#2]
;;;147    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0001e6  7930              LDRB     r0,[r6,#4]  ; UART_Buffer_Rece
0001e8  78f2              LDRB     r2,[r6,#3]  ; UART_Buffer_Rece
0001ea  eb002002          ADD      r0,r0,r2,LSL #8
0001ee  80a0              STRH     r0,[r4,#4]
                  |L3.496|
;;;148    		}
;;;149    		if (UART_Buffer_Rece[1] == 0x08||flag_ADJ_VH==1)			   //电压测量校准完成
0001f0  7870              LDRB     r0,[r6,#1]  ; UART_Buffer_Rece
0001f2  2808              CMP      r0,#8
0001f4  d002              BEQ      |L3.508|
0001f6  6828              LDR      r0,[r5,#0]  ; flagF
0001f8  0700              LSLS     r0,r0,#28
0001fa  d53f              BPL      |L3.636|
                  |L3.508|
;;;150    		{
;;;151    			vu16 var16;
;;;152    			vu32 var32a;
;;;153    			vu32 var32b;
;;;154    			
;;;155    			vu16 var16a;
;;;156    			vu32 var32c;
;;;157    			vu32 var32d;
;;;158    			Modify_B_READ =Rmon_value;//测量电压值
0001fc  8808              LDRH     r0,[r1,#0]  ; Rmon_value
0001fe  80e0              STRH     r0,[r4,#6]
;;;159    			flag_OverV=1;
000200  4f27              LDR      r7,|L3.672|
000202  6838              LDR      r0,[r7,#0]  ; flagG
000204  f0400002          ORR      r0,r0,#2
000208  6038              STR      r0,[r7,#0]  ; flagG
;;;160    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
00020a  7931              LDRB     r1,[r6,#4]  ; UART_Buffer_Rece
00020c  78f2              LDRB     r2,[r6,#3]  ; UART_Buffer_Rece
00020e  eb012102          ADD      r1,r1,r2,LSL #8
000212  8121              STRH     r1,[r4,#8]
;;;161    			if(flag_OverV==1)//只有当有数据写入时才能将校准数据写入FLASH
000214  0780              LSLS     r0,r0,#30
000216  d52d              BPL      |L3.628|
;;;162    			{
;;;163    				var32a = Modify_B_ACT;
000218  8920              LDRH     r0,[r4,#8]  ; Modify_B_ACT
;;;164    				var32a = var32a - Modify_A_ACT;
00021a  88a1              LDRH     r1,[r4,#4]  ; Modify_A_ACT
00021c  1a40              SUBS     r0,r0,r1
;;;165    				var32a = var32a << 12;
00021e  0301              LSLS     r1,r0,#12
;;;166    				var16 = Modify_B_READ - Modify_A_READ;
000220  88e0              LDRH     r0,[r4,#6]  ; Modify_B_READ
000222  8862              LDRH     r2,[r4,#2]  ; Modify_A_READ
000224  1a80              SUBS     r0,r0,r2
000226  b280              UXTH     r0,r0
;;;167    				var32a = var32a / var16;
000228  fbb1f0f0          UDIV     r0,r1,r0
;;;168    				REG_CorrectionR = var32a;
00022c  4a19              LDR      r2,|L3.660|
00022e  3a40              SUBS     r2,r2,#0x40
000230  80d0              STRH     r0,[r2,#6]
;;;169    				var32a=0;
;;;170    				var32a = Modify_B_ACT;
000232  8920              LDRH     r0,[r4,#8]  ; Modify_B_ACT
;;;171    				var32a = var32a << 12;
000234  0301              LSLS     r1,r0,#12
;;;172    				var32b = Modify_B_READ;
000236  88e3              LDRH     r3,[r4,#6]  ; Modify_B_READ
;;;173    				var32b = var32b * REG_CorrectionR;
000238  88d0              LDRH     r0,[r2,#6]  ; Correct_Parametet
00023a  4358              MULS     r0,r3,r0
;;;174    				if (var32a < var32b)
;;;175    				{
;;;176    					var32b = var32b - var32a;
;;;177    					REG_ReadR_Offset = var32b;
00023c  f102031c          ADD      r3,r2,#0x1c
000240  4281              CMP      r1,r0                 ;174
000242  d206              BCS      |L3.594|
000244  1a40              SUBS     r0,r0,r1              ;176
000246  60d8              STR      r0,[r3,#0xc]  ; Correct_Strong
;;;178    					Polar3 |= 0x01;
000248  8ad0              LDRH     r0,[r2,#0x16]  ; Correct_Parametet
00024a  f0400001          ORR      r0,r0,#1
00024e  82d0              STRH     r0,[r2,#0x16]
000250  e005              B        |L3.606|
                  |L3.594|
;;;179    				}
;;;180    				else 
;;;181    				{
;;;182    					var32a = var32a - var32b;
000252  1a08              SUBS     r0,r1,r0
;;;183    					REG_ReadR_Offset = var32a;
000254  60d8              STR      r0,[r3,#0xc]  ; Correct_Strong
;;;184    					Polar3 &= ~0x01;
000256  8ad0              LDRH     r0,[r2,#0x16]  ; Correct_Parametet
000258  f0200001          BIC      r0,r0,#1
00025c  82d0              STRH     r0,[r2,#0x16]
                  |L3.606|
;;;185    				}
;;;186    	//---------------------------------------------------------------------------------------//
;;;187    				Flash_Write_all();	//参数写进FLASH
00025e  f7fffffe          BL       Flash_Write_all
;;;188    				flag_OverV=0;
000262  6838              LDR      r0,[r7,#0]  ; flagG
000264  f0200002          BIC      r0,r0,#2
000268  6038              STR      r0,[r7,#0]  ; flagG
;;;189    				Flag_DAC_OFF=0;
00026a  480e              LDR      r0,|L3.676|
00026c  6801              LDR      r1,[r0,#0]  ; flagB
00026e  f0210108          BIC      r1,r1,#8
000272  6001              STR      r1,[r0,#0]  ; flagB
                  |L3.628|
;;;190    			}
;;;191    			flag_ADJ_VH=0;//清掉标志位防止一直进入
000274  6828              LDR      r0,[r5,#0]  ; flagF
000276  f0200008          BIC      r0,r0,#8
00027a  6028              STR      r0,[r5,#0]  ; flagF
                  |L3.636|
;;;192    		}		
;;;193        }
;;;194    }
00027c  e8bd9ff0          POP      {r4-r12,pc}
;;;195    //===============================AD值转换成测量值============================================//
                          ENDP

                  |L3.640|
                          DCD      UART_Buffer_Rece
                  |L3.644|
                          DCD      ||area_number.9||
                  |L3.648|
                          DCD      UART_Buffer_Send
                  |L3.652|
                          DCD      Transmit_BUFFERsize
                  |L3.656|
                          DCD      flagA
                  |L3.660|
                          DCD      ||.bss||+0x40
                  |L3.664|
                          DCD      flagF
                  |L3.668|
                          DCD      Rmon_value
                  |L3.672|
                          DCD      flagG
                  |L3.676|
                          DCD      flagB

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        28
                  Correct_Strong
                          %        36
                  Run_Control
                          %        86

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=0

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00

                          AREA ||area_number.9||, DATA, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.data||
                  ADDR
000000  0000              DCB      0x00,0x00
                  Modify_A_READ
000002  0000              DCB      0x00,0x00
                  Modify_A_ACT
000004  0000              DCB      0x00,0x00
                  Modify_B_READ
000006  0000              DCB      0x00,0x00
                  Modify_B_ACT
000008  0000              DCB      0x00,0x00

                          AREA ||area_number.10||, DATA, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.data||
                  Modify_C_READ
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.11||, DATA, ALIGN=1

                          EXPORTAS ||area_number.11||, ||.data||
                  Modify_D_READ
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 128
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
